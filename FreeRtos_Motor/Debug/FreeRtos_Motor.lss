
FreeRtos_Motor.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003d40  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000002c  20000000  00003d40  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000372c  2000002c  00003d6c  0002002c  2**2
                  ALLOC
  3 .stack        00002000  20003758  00007498  0002002c  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  0002002c  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020054  2**0
                  CONTENTS, READONLY
  6 .debug_info   00037f05  00000000  00000000  000200ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000058b2  00000000  00000000  00057fb2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00019367  00000000  00000000  0005d864  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001468  00000000  00000000  00076bcb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000018e8  00000000  00000000  00078033  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00023695  00000000  00000000  0007991b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00019fe9  00000000  00000000  0009cfb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a4a2d  00000000  00000000  000b6f99  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000036cc  00000000  00000000  0015b9c8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	58 57 00 20 a5 01 00 00 a1 01 00 00 a1 01 00 00     XW. ............
	...
      2c:	a1 01 00 00 00 00 00 00 00 00 00 00 b1 0a 00 00     ................
      3c:	f5 0a 00 00 a1 01 00 00 a1 01 00 00 a1 01 00 00     ................
      4c:	a1 01 00 00 a1 01 00 00 a1 01 00 00 71 2c 00 00     ............q,..
      5c:	a1 01 00 00 a1 01 00 00 a1 01 00 00 a1 01 00 00     ................
      6c:	a1 01 00 00 a1 01 00 00 a1 01 00 00 a1 01 00 00     ................
      7c:	ed 29 00 00 5d 2a 00 00 a1 01 00 00 a1 01 00 00     .)..]*..........
      8c:	a1 01 00 00 d5 32 00 00 e9 32 00 00 a1 01 00 00     .....2...2......
      9c:	a1 01 00 00 a1 01 00 00 a1 01 00 00 a1 01 00 00     ................
      ac:	a1 01 00 00 a1 01 00 00 a1 01 00 00 a1 01 00 00     ................

000000bc <__do_global_dtors_aux>:
      bc:	b510      	push	{r4, lr}
      be:	4c06      	ldr	r4, [pc, #24]	; (d8 <__do_global_dtors_aux+0x1c>)
      c0:	7823      	ldrb	r3, [r4, #0]
      c2:	2b00      	cmp	r3, #0
      c4:	d107      	bne.n	d6 <__do_global_dtors_aux+0x1a>
      c6:	4b05      	ldr	r3, [pc, #20]	; (dc <__do_global_dtors_aux+0x20>)
      c8:	2b00      	cmp	r3, #0
      ca:	d002      	beq.n	d2 <__do_global_dtors_aux+0x16>
      cc:	4804      	ldr	r0, [pc, #16]	; (e0 <__do_global_dtors_aux+0x24>)
      ce:	e000      	b.n	d2 <__do_global_dtors_aux+0x16>
      d0:	bf00      	nop
      d2:	2301      	movs	r3, #1
      d4:	7023      	strb	r3, [r4, #0]
      d6:	bd10      	pop	{r4, pc}
      d8:	2000002c 	.word	0x2000002c
      dc:	00000000 	.word	0x00000000
      e0:	00003d40 	.word	0x00003d40

000000e4 <frame_dummy>:
      e4:	4b08      	ldr	r3, [pc, #32]	; (108 <frame_dummy+0x24>)
      e6:	b510      	push	{r4, lr}
      e8:	2b00      	cmp	r3, #0
      ea:	d003      	beq.n	f4 <frame_dummy+0x10>
      ec:	4907      	ldr	r1, [pc, #28]	; (10c <frame_dummy+0x28>)
      ee:	4808      	ldr	r0, [pc, #32]	; (110 <frame_dummy+0x2c>)
      f0:	e000      	b.n	f4 <frame_dummy+0x10>
      f2:	bf00      	nop
      f4:	4807      	ldr	r0, [pc, #28]	; (114 <frame_dummy+0x30>)
      f6:	6803      	ldr	r3, [r0, #0]
      f8:	2b00      	cmp	r3, #0
      fa:	d100      	bne.n	fe <frame_dummy+0x1a>
      fc:	bd10      	pop	{r4, pc}
      fe:	4b06      	ldr	r3, [pc, #24]	; (118 <frame_dummy+0x34>)
     100:	2b00      	cmp	r3, #0
     102:	d0fb      	beq.n	fc <frame_dummy+0x18>
     104:	4798      	blx	r3
     106:	e7f9      	b.n	fc <frame_dummy+0x18>
     108:	00000000 	.word	0x00000000
     10c:	20000030 	.word	0x20000030
     110:	00003d40 	.word	0x00003d40
     114:	00003d40 	.word	0x00003d40
     118:	00000000 	.word	0x00000000

0000011c <comm_task>:
#define TASK_COMM_STACK_PRIORITY (tskIDLE_PRIORITY + 1)
static TaskHandle_t      xCreatedCOMMTask;

static uint32_t u32comm_cnt = 0;
static void comm_task(void *p)
{
     11c:	b510      	push	{r4, lr}

	while (1) {
		u32comm_cnt++;
     11e:	4b09      	ldr	r3, [pc, #36]	; (144 <comm_task+0x28>)
     120:	681a      	ldr	r2, [r3, #0]
     122:	3201      	adds	r2, #1
     124:	601a      	str	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].DIRTGL.reg = mask;
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     126:	2080      	movs	r0, #128	; 0x80
     128:	0200      	lsls	r0, r0, #8
     12a:	2398      	movs	r3, #152	; 0x98
     12c:	21c0      	movs	r1, #192	; 0xc0
     12e:	05c9      	lsls	r1, r1, #23
     130:	50c8      	str	r0, [r1, r3]
		gpio_set_pin_level(LED_PIN, true);
		SEGGER_RTT_printf(0,"u32comm_cnt = %d \r\n",u32comm_cnt);
     132:	4905      	ldr	r1, [pc, #20]	; (148 <comm_task+0x2c>)
     134:	2000      	movs	r0, #0
     136:	4b05      	ldr	r3, [pc, #20]	; (14c <comm_task+0x30>)
     138:	4798      	blx	r3
		vTaskDelay(1);
     13a:	2001      	movs	r0, #1
     13c:	4b04      	ldr	r3, [pc, #16]	; (150 <comm_task+0x34>)
     13e:	4798      	blx	r3
     140:	e7ed      	b.n	11e <comm_task+0x2>
     142:	46c0      	nop			; (mov r8, r8)
     144:	20000048 	.word	0x20000048
     148:	00003aa8 	.word	0x00003aa8
     14c:	00003a1d 	.word	0x00003a1d
     150:	00001839 	.word	0x00001839

00000154 <create_comm_task>:
	}
}


void create_comm_task(void)
{
     154:	b510      	push	{r4, lr}
     156:	b082      	sub	sp, #8
	taskENTER_CRITICAL();
     158:	4b09      	ldr	r3, [pc, #36]	; (180 <create_comm_task+0x2c>)
     15a:	4798      	blx	r3
	if (xTaskCreate(comm_task, 
     15c:	2300      	movs	r3, #0
     15e:	9301      	str	r3, [sp, #4]
     160:	3301      	adds	r3, #1
     162:	9300      	str	r3, [sp, #0]
     164:	2300      	movs	r3, #0
     166:	2280      	movs	r2, #128	; 0x80
     168:	4906      	ldr	r1, [pc, #24]	; (184 <create_comm_task+0x30>)
     16a:	4807      	ldr	r0, [pc, #28]	; (188 <create_comm_task+0x34>)
     16c:	4c07      	ldr	r4, [pc, #28]	; (18c <create_comm_task+0x38>)
     16e:	47a0      	blx	r4
     170:	2801      	cmp	r0, #1
     172:	d000      	beq.n	176 <create_comm_task+0x22>
     174:	e7fe      	b.n	174 <create_comm_task+0x20>
					TASK_COMM_STACK_PRIORITY, 
					xCreatedCOMMTask)
	!= pdPASS) {
		while (1);
	}
	taskEXIT_CRITICAL();
     176:	4b06      	ldr	r3, [pc, #24]	; (190 <create_comm_task+0x3c>)
     178:	4798      	blx	r3
	
     17a:	b002      	add	sp, #8
     17c:	bd10      	pop	{r4, pc}
     17e:	46c0      	nop			; (mov r8, r8)
     180:	00000a61 	.word	0x00000a61
     184:	00003abc 	.word	0x00003abc
     188:	0000011d 	.word	0x0000011d
     18c:	00001551 	.word	0x00001551
     190:	00000a79 	.word	0x00000a79

00000194 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     194:	b510      	push	{r4, lr}
	system_init();
     196:	4b01      	ldr	r3, [pc, #4]	; (19c <atmel_start_init+0x8>)
     198:	4798      	blx	r3
}
     19a:	bd10      	pop	{r4, pc}
     19c:	00000505 	.word	0x00000505

000001a0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     1a0:	e7fe      	b.n	1a0 <Dummy_Handler>
	...

000001a4 <Reset_Handler>:
{
     1a4:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
     1a6:	4a10      	ldr	r2, [pc, #64]	; (1e8 <Reset_Handler+0x44>)
     1a8:	4b10      	ldr	r3, [pc, #64]	; (1ec <Reset_Handler+0x48>)
     1aa:	429a      	cmp	r2, r3
     1ac:	d009      	beq.n	1c2 <Reset_Handler+0x1e>
     1ae:	4b0f      	ldr	r3, [pc, #60]	; (1ec <Reset_Handler+0x48>)
     1b0:	4a0d      	ldr	r2, [pc, #52]	; (1e8 <Reset_Handler+0x44>)
     1b2:	e003      	b.n	1bc <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     1b4:	6811      	ldr	r1, [r2, #0]
     1b6:	6019      	str	r1, [r3, #0]
     1b8:	3304      	adds	r3, #4
     1ba:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     1bc:	490c      	ldr	r1, [pc, #48]	; (1f0 <Reset_Handler+0x4c>)
     1be:	428b      	cmp	r3, r1
     1c0:	d3f8      	bcc.n	1b4 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     1c2:	4b0c      	ldr	r3, [pc, #48]	; (1f4 <Reset_Handler+0x50>)
     1c4:	e002      	b.n	1cc <Reset_Handler+0x28>
                *pDest++ = 0;
     1c6:	2200      	movs	r2, #0
     1c8:	601a      	str	r2, [r3, #0]
     1ca:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     1cc:	4a0a      	ldr	r2, [pc, #40]	; (1f8 <Reset_Handler+0x54>)
     1ce:	4293      	cmp	r3, r2
     1d0:	d3f9      	bcc.n	1c6 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     1d2:	4a0a      	ldr	r2, [pc, #40]	; (1fc <Reset_Handler+0x58>)
     1d4:	21ff      	movs	r1, #255	; 0xff
     1d6:	4b0a      	ldr	r3, [pc, #40]	; (200 <Reset_Handler+0x5c>)
     1d8:	438b      	bics	r3, r1
     1da:	6093      	str	r3, [r2, #8]
        __libc_init_array();
     1dc:	4b09      	ldr	r3, [pc, #36]	; (204 <Reset_Handler+0x60>)
     1de:	4798      	blx	r3
        main();
     1e0:	4b09      	ldr	r3, [pc, #36]	; (208 <Reset_Handler+0x64>)
     1e2:	4798      	blx	r3
     1e4:	e7fe      	b.n	1e4 <Reset_Handler+0x40>
     1e6:	46c0      	nop			; (mov r8, r8)
     1e8:	00003d40 	.word	0x00003d40
     1ec:	20000000 	.word	0x20000000
     1f0:	2000002c 	.word	0x2000002c
     1f4:	2000002c 	.word	0x2000002c
     1f8:	20003758 	.word	0x20003758
     1fc:	e000ed00 	.word	0xe000ed00
     200:	00000000 	.word	0x00000000
     204:	00003a3d 	.word	0x00003a3d
     208:	0000336d 	.word	0x0000336d

0000020c <TIMER_0_init>:
 * \brief Timer initialization function
 *
 * Enables Timer peripheral, clocks and initializes Timer driver
 */
static void TIMER_0_init(void)
{
     20c:	b510      	push	{r4, lr}
}

static inline void hri_mclk_set_APBCMASK_TC0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TC0;
     20e:	4a09      	ldr	r2, [pc, #36]	; (234 <TIMER_0_init+0x28>)
     210:	69d1      	ldr	r1, [r2, #28]
     212:	2380      	movs	r3, #128	; 0x80
     214:	015b      	lsls	r3, r3, #5
     216:	430b      	orrs	r3, r1
     218:	61d3      	str	r3, [r2, #28]
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     21a:	2140      	movs	r1, #64	; 0x40
     21c:	23f8      	movs	r3, #248	; 0xf8
     21e:	4a06      	ldr	r2, [pc, #24]	; (238 <TIMER_0_init+0x2c>)
     220:	50d1      	str	r1, [r2, r3]
	hri_mclk_set_APBCMASK_TC0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, TC0_GCLK_ID, CONF_GCLK_TC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	timer_init(&TIMER_0, TC0, _tc_get_timer());
     222:	4b06      	ldr	r3, [pc, #24]	; (23c <TIMER_0_init+0x30>)
     224:	4798      	blx	r3
     226:	0002      	movs	r2, r0
     228:	4905      	ldr	r1, [pc, #20]	; (240 <TIMER_0_init+0x34>)
     22a:	4806      	ldr	r0, [pc, #24]	; (244 <TIMER_0_init+0x38>)
     22c:	4b06      	ldr	r3, [pc, #24]	; (248 <TIMER_0_init+0x3c>)
     22e:	4798      	blx	r3
}
     230:	bd10      	pop	{r4, pc}
     232:	46c0      	nop			; (mov r8, r8)
     234:	40000800 	.word	0x40000800
     238:	40001c00 	.word	0x40001c00
     23c:	00003295 	.word	0x00003295
     240:	42003000 	.word	0x42003000
     244:	20003094 	.word	0x20003094
     248:	0000232d 	.word	0x0000232d

0000024c <TIMER_1_init>:
 * \brief Timer initialization function
 *
 * Enables Timer peripheral, clocks and initializes Timer driver
 */
static void TIMER_1_init(void)
{
     24c:	b510      	push	{r4, lr}
}

static inline void hri_mclk_set_APBCMASK_TC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TC1;
     24e:	4a09      	ldr	r2, [pc, #36]	; (274 <TIMER_1_init+0x28>)
     250:	69d1      	ldr	r1, [r2, #28]
     252:	2380      	movs	r3, #128	; 0x80
     254:	019b      	lsls	r3, r3, #6
     256:	430b      	orrs	r3, r1
     258:	61d3      	str	r3, [r2, #28]
     25a:	2140      	movs	r1, #64	; 0x40
     25c:	23f8      	movs	r3, #248	; 0xf8
     25e:	4a06      	ldr	r2, [pc, #24]	; (278 <TIMER_1_init+0x2c>)
     260:	50d1      	str	r1, [r2, r3]
	hri_mclk_set_APBCMASK_TC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, TC1_GCLK_ID, CONF_GCLK_TC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	timer_init(&TIMER_1, TC1, _tc_get_timer());
     262:	4b06      	ldr	r3, [pc, #24]	; (27c <TIMER_1_init+0x30>)
     264:	4798      	blx	r3
     266:	0002      	movs	r2, r0
     268:	4905      	ldr	r1, [pc, #20]	; (280 <TIMER_1_init+0x34>)
     26a:	4806      	ldr	r0, [pc, #24]	; (284 <TIMER_1_init+0x38>)
     26c:	4b06      	ldr	r3, [pc, #24]	; (288 <TIMER_1_init+0x3c>)
     26e:	4798      	blx	r3
}
     270:	bd10      	pop	{r4, pc}
     272:	46c0      	nop			; (mov r8, r8)
     274:	40000800 	.word	0x40000800
     278:	40001c00 	.word	0x40001c00
     27c:	00003295 	.word	0x00003295
     280:	42003400 	.word	0x42003400
     284:	20003060 	.word	0x20003060
     288:	0000232d 	.word	0x0000232d

0000028c <FLASH_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_NVMCTRL;
     28c:	4a02      	ldr	r2, [pc, #8]	; (298 <FLASH_0_CLOCK_init+0xc>)
     28e:	6913      	ldr	r3, [r2, #16]
     290:	2120      	movs	r1, #32
     292:	430b      	orrs	r3, r1
     294:	6113      	str	r3, [r2, #16]
}
     296:	4770      	bx	lr
     298:	40000800 	.word	0x40000800

0000029c <FLASH_0_init>:
{
     29c:	b510      	push	{r4, lr}
	FLASH_0_CLOCK_init();
     29e:	4b03      	ldr	r3, [pc, #12]	; (2ac <FLASH_0_init+0x10>)
     2a0:	4798      	blx	r3
	flash_init(&FLASH_0, NVMCTRL);
     2a2:	4903      	ldr	r1, [pc, #12]	; (2b0 <FLASH_0_init+0x14>)
     2a4:	4803      	ldr	r0, [pc, #12]	; (2b4 <FLASH_0_init+0x18>)
     2a6:	4b04      	ldr	r3, [pc, #16]	; (2b8 <FLASH_0_init+0x1c>)
     2a8:	4798      	blx	r3
}
     2aa:	bd10      	pop	{r4, pc}
     2ac:	0000028d 	.word	0x0000028d
     2b0:	41004000 	.word	0x41004000
     2b4:	20003018 	.word	0x20003018
     2b8:	0000210d 	.word	0x0000210d

000002bc <SPI_0_PORT_init>:
{
     2bc:	b5f0      	push	{r4, r5, r6, r7, lr}
     2be:	46c6      	mov	lr, r8
     2c0:	b500      	push	{lr}
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     2c2:	24c0      	movs	r4, #192	; 0xc0
     2c4:	05e4      	lsls	r4, r4, #23
     2c6:	2380      	movs	r3, #128	; 0x80
     2c8:	025b      	lsls	r3, r3, #9
     2ca:	6063      	str	r3, [r4, #4]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     2cc:	2382      	movs	r3, #130	; 0x82
     2ce:	05db      	lsls	r3, r3, #23
     2d0:	4a23      	ldr	r2, [pc, #140]	; (360 <SPI_0_PORT_init+0xa4>)
     2d2:	629a      	str	r2, [r3, #40]	; 0x28
     2d4:	4a23      	ldr	r2, [pc, #140]	; (364 <SPI_0_PORT_init+0xa8>)
     2d6:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     2d8:	2150      	movs	r1, #80	; 0x50
     2da:	5c5a      	ldrb	r2, [r3, r1]
     2dc:	2004      	movs	r0, #4
     2de:	4382      	bics	r2, r0
     2e0:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     2e2:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     2e4:	2601      	movs	r6, #1
     2e6:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     2e8:	2501      	movs	r5, #1
     2ea:	432a      	orrs	r2, r5
     2ec:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     2ee:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     2f0:	3918      	subs	r1, #24
     2f2:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     2f4:	300b      	adds	r0, #11
     2f6:	4684      	mov	ip, r0
     2f8:	4382      	bics	r2, r0
	tmp |= PORT_PMUX_PMUXE(data);
     2fa:	2702      	movs	r7, #2
     2fc:	433a      	orrs	r2, r7
     2fe:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     300:	545a      	strb	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     302:	2280      	movs	r2, #128	; 0x80
     304:	02d2      	lsls	r2, r2, #11
     306:	6162      	str	r2, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     308:	60a2      	str	r2, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     30a:	2280      	movs	r2, #128	; 0x80
     30c:	05d2      	lsls	r2, r2, #23
     30e:	4690      	mov	r8, r2
     310:	629a      	str	r2, [r3, #40]	; 0x28
     312:	4915      	ldr	r1, [pc, #84]	; (368 <SPI_0_PORT_init+0xac>)
     314:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     316:	2152      	movs	r1, #82	; 0x52
     318:	5c58      	ldrb	r0, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     31a:	43b0      	bics	r0, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     31c:	4328      	orrs	r0, r5
     31e:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     320:	5458      	strb	r0, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     322:	2039      	movs	r0, #57	; 0x39
     324:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     326:	4662      	mov	r2, ip
     328:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     32a:	4339      	orrs	r1, r7
     32c:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     32e:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     330:	2180      	movs	r1, #128	; 0x80
     332:	0309      	lsls	r1, r1, #12
     334:	6161      	str	r1, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     336:	60a1      	str	r1, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     338:	4642      	mov	r2, r8
     33a:	629a      	str	r2, [r3, #40]	; 0x28
     33c:	4a0b      	ldr	r2, [pc, #44]	; (36c <SPI_0_PORT_init+0xb0>)
     33e:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     340:	2153      	movs	r1, #83	; 0x53
     342:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     344:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     346:	432a      	orrs	r2, r5
     348:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     34a:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     34c:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     34e:	3944      	subs	r1, #68	; 0x44
     350:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     352:	2120      	movs	r1, #32
     354:	430a      	orrs	r2, r1
     356:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     358:	541a      	strb	r2, [r3, r0]
}
     35a:	bc04      	pop	{r2}
     35c:	4690      	mov	r8, r2
     35e:	bdf0      	pop	{r4, r5, r6, r7, pc}
     360:	40020000 	.word	0x40020000
     364:	c0020001 	.word	0xc0020001
     368:	c0000004 	.word	0xc0000004
     36c:	c0000008 	.word	0xc0000008

00000370 <SPI_0_CLOCK_init>:
     370:	4b06      	ldr	r3, [pc, #24]	; (38c <SPI_0_CLOCK_init+0x1c>)
     372:	2140      	movs	r1, #64	; 0x40
     374:	22d0      	movs	r2, #208	; 0xd0
     376:	5099      	str	r1, [r3, r2]
     378:	3103      	adds	r1, #3
     37a:	3a08      	subs	r2, #8
     37c:	5099      	str	r1, [r3, r2]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM1;
     37e:	4a04      	ldr	r2, [pc, #16]	; (390 <SPI_0_CLOCK_init+0x20>)
     380:	69d3      	ldr	r3, [r2, #28]
     382:	393f      	subs	r1, #63	; 0x3f
     384:	430b      	orrs	r3, r1
     386:	61d3      	str	r3, [r2, #28]
}
     388:	4770      	bx	lr
     38a:	46c0      	nop			; (mov r8, r8)
     38c:	40001c00 	.word	0x40001c00
     390:	40000800 	.word	0x40000800

00000394 <SPI_0_init>:
{
     394:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
     396:	4b04      	ldr	r3, [pc, #16]	; (3a8 <SPI_0_init+0x14>)
     398:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SERCOM1);
     39a:	4904      	ldr	r1, [pc, #16]	; (3ac <SPI_0_init+0x18>)
     39c:	4804      	ldr	r0, [pc, #16]	; (3b0 <SPI_0_init+0x1c>)
     39e:	4b05      	ldr	r3, [pc, #20]	; (3b4 <SPI_0_init+0x20>)
     3a0:	4798      	blx	r3
	SPI_0_PORT_init();
     3a2:	4b05      	ldr	r3, [pc, #20]	; (3b8 <SPI_0_init+0x24>)
     3a4:	4798      	blx	r3
}
     3a6:	bd10      	pop	{r4, pc}
     3a8:	00000371 	.word	0x00000371
     3ac:	42000800 	.word	0x42000800
     3b0:	2000307c 	.word	0x2000307c
     3b4:	00002159 	.word	0x00002159
     3b8:	000002bd 	.word	0x000002bd

000003bc <WDT_0_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_WDT;
     3bc:	4a03      	ldr	r2, [pc, #12]	; (3cc <WDT_0_CLOCK_init+0x10>)
     3be:	6951      	ldr	r1, [r2, #20]
     3c0:	2380      	movs	r3, #128	; 0x80
     3c2:	005b      	lsls	r3, r3, #1
     3c4:	430b      	orrs	r3, r1
     3c6:	6153      	str	r3, [r2, #20]

void WDT_0_CLOCK_init(void)
{
	hri_mclk_set_APBAMASK_WDT_bit(MCLK);
}
     3c8:	4770      	bx	lr
     3ca:	46c0      	nop			; (mov r8, r8)
     3cc:	40000800 	.word	0x40000800

000003d0 <WDT_0_init>:

void WDT_0_init(void)
{
     3d0:	b510      	push	{r4, lr}
	WDT_0_CLOCK_init();
     3d2:	4b06      	ldr	r3, [pc, #24]	; (3ec <WDT_0_init+0x1c>)
     3d4:	4798      	blx	r3
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
	ASSERT(wdt && hw);
     3d6:	2248      	movs	r2, #72	; 0x48
     3d8:	4905      	ldr	r1, [pc, #20]	; (3f0 <WDT_0_init+0x20>)
     3da:	2001      	movs	r0, #1
     3dc:	4b05      	ldr	r3, [pc, #20]	; (3f4 <WDT_0_init+0x24>)
     3de:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
     3e0:	4805      	ldr	r0, [pc, #20]	; (3f8 <WDT_0_init+0x28>)
     3e2:	4b06      	ldr	r3, [pc, #24]	; (3fc <WDT_0_init+0x2c>)
     3e4:	6003      	str	r3, [r0, #0]

	return _wdt_init(&wdt->dev);
     3e6:	4b06      	ldr	r3, [pc, #24]	; (400 <WDT_0_init+0x30>)
     3e8:	4798      	blx	r3
	wdt_init(&WDT_0, WDT);
}
     3ea:	bd10      	pop	{r4, pc}
     3ec:	000003bd 	.word	0x000003bd
     3f0:	00003ac4 	.word	0x00003ac4
     3f4:	0000245d 	.word	0x0000245d
     3f8:	2000305c 	.word	0x2000305c
     3fc:	40002000 	.word	0x40002000
     400:	000032fd 	.word	0x000032fd

00000404 <CAN_1_PORT_init>:

void CAN_1_PORT_init(void)
{
     404:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     406:	2382      	movs	r3, #130	; 0x82
     408:	05db      	lsls	r3, r3, #23
     40a:	2259      	movs	r2, #89	; 0x59
     40c:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     40e:	2501      	movs	r5, #1
     410:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     412:	2401      	movs	r4, #1
     414:	4321      	orrs	r1, r4
     416:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     418:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     41a:	203c      	movs	r0, #60	; 0x3c
     41c:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     41e:	3a4a      	subs	r2, #74	; 0x4a
     420:	4011      	ands	r1, r2
	tmp |= PORT_PMUX_PMUXO(data);
     422:	2260      	movs	r2, #96	; 0x60
     424:	4311      	orrs	r1, r2
     426:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     428:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     42a:	2158      	movs	r1, #88	; 0x58
     42c:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     42e:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     430:	4322      	orrs	r2, r4
     432:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     434:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     436:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     438:	3949      	subs	r1, #73	; 0x49
     43a:	438a      	bics	r2, r1
	tmp |= PORT_PMUX_PMUXE(data);
     43c:	2106      	movs	r1, #6
     43e:	430a      	orrs	r2, r1
     440:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     442:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PA25, PINMUX_PA25G_CAN0_RX);

	gpio_set_pin_function(PA24, PINMUX_PA24G_CAN0_TX);
}
     444:	bd30      	pop	{r4, r5, pc}
	...

00000448 <CAN_1_init>:
 * \brief CAN initialization function
 *
 * Enables CAN peripheral, clocks and initializes CAN driver
 */
void CAN_1_init(void)
{
     448:	b510      	push	{r4, lr}
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_CAN0;
     44a:	4a08      	ldr	r2, [pc, #32]	; (46c <CAN_1_init+0x24>)
     44c:	6911      	ldr	r1, [r2, #16]
     44e:	2380      	movs	r3, #128	; 0x80
     450:	005b      	lsls	r3, r3, #1
     452:	430b      	orrs	r3, r1
     454:	6113      	str	r3, [r2, #16]
     456:	2140      	movs	r1, #64	; 0x40
     458:	23e8      	movs	r3, #232	; 0xe8
     45a:	4a05      	ldr	r2, [pc, #20]	; (470 <CAN_1_init+0x28>)
     45c:	50d1      	str	r1, [r2, r3]
	hri_mclk_set_AHBMASK_CAN0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, CAN0_GCLK_ID, CONF_GCLK_CAN0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	can_async_init(&CAN_1, CAN0);
     45e:	4905      	ldr	r1, [pc, #20]	; (474 <CAN_1_init+0x2c>)
     460:	4805      	ldr	r0, [pc, #20]	; (478 <CAN_1_init+0x30>)
     462:	4b06      	ldr	r3, [pc, #24]	; (47c <CAN_1_init+0x34>)
     464:	4798      	blx	r3
	CAN_1_PORT_init();
     466:	4b06      	ldr	r3, [pc, #24]	; (480 <CAN_1_init+0x38>)
     468:	4798      	blx	r3
}
     46a:	bd10      	pop	{r4, pc}
     46c:	40000800 	.word	0x40000800
     470:	40001c00 	.word	0x40001c00
     474:	42001c00 	.word	0x42001c00
     478:	20003034 	.word	0x20003034
     47c:	00001f85 	.word	0x00001f85
     480:	00000405 	.word	0x00000405

00000484 <CAN_0_PORT_init>:

void CAN_0_PORT_init(void)
{
     484:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     486:	2382      	movs	r3, #130	; 0x82
     488:	05db      	lsls	r3, r3, #23
     48a:	22cb      	movs	r2, #203	; 0xcb
     48c:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     48e:	2501      	movs	r5, #1
     490:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     492:	2401      	movs	r4, #1
     494:	4321      	orrs	r1, r4
     496:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     498:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     49a:	20b5      	movs	r0, #181	; 0xb5
     49c:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     49e:	3abc      	subs	r2, #188	; 0xbc
     4a0:	4011      	ands	r1, r2
	tmp |= PORT_PMUX_PMUXO(data);
     4a2:	2260      	movs	r2, #96	; 0x60
     4a4:	4311      	orrs	r1, r2
     4a6:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     4a8:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4aa:	21ca      	movs	r1, #202	; 0xca
     4ac:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     4ae:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     4b0:	4322      	orrs	r2, r4
     4b2:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4b4:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     4b6:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     4b8:	39bb      	subs	r1, #187	; 0xbb
     4ba:	438a      	bics	r2, r1
	tmp |= PORT_PMUX_PMUXE(data);
     4bc:	2106      	movs	r1, #6
     4be:	430a      	orrs	r2, r1
     4c0:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     4c2:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PB11, PINMUX_PB11G_CAN1_RX);

	gpio_set_pin_function(PB10, PINMUX_PB10G_CAN1_TX);
}
     4c4:	bd30      	pop	{r4, r5, pc}
	...

000004c8 <CAN_0_init>:
 * \brief CAN initialization function
 *
 * Enables CAN peripheral, clocks and initializes CAN driver
 */
void CAN_0_init(void)
{
     4c8:	b510      	push	{r4, lr}
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_CAN1;
     4ca:	4a08      	ldr	r2, [pc, #32]	; (4ec <CAN_0_init+0x24>)
     4cc:	6911      	ldr	r1, [r2, #16]
     4ce:	2380      	movs	r3, #128	; 0x80
     4d0:	009b      	lsls	r3, r3, #2
     4d2:	430b      	orrs	r3, r1
     4d4:	6113      	str	r3, [r2, #16]
     4d6:	2140      	movs	r1, #64	; 0x40
     4d8:	23ec      	movs	r3, #236	; 0xec
     4da:	4a05      	ldr	r2, [pc, #20]	; (4f0 <CAN_0_init+0x28>)
     4dc:	50d1      	str	r1, [r2, r3]
	hri_mclk_set_AHBMASK_CAN1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, CAN1_GCLK_ID, CONF_GCLK_CAN1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	can_async_init(&CAN_0, CAN1);
     4de:	4905      	ldr	r1, [pc, #20]	; (4f4 <CAN_0_init+0x2c>)
     4e0:	4805      	ldr	r0, [pc, #20]	; (4f8 <CAN_0_init+0x30>)
     4e2:	4b06      	ldr	r3, [pc, #24]	; (4fc <CAN_0_init+0x34>)
     4e4:	4798      	blx	r3
	CAN_0_PORT_init();
     4e6:	4b06      	ldr	r3, [pc, #24]	; (500 <CAN_0_init+0x38>)
     4e8:	4798      	blx	r3
}
     4ea:	bd10      	pop	{r4, pc}
     4ec:	40000800 	.word	0x40000800
     4f0:	40001c00 	.word	0x40001c00
     4f4:	42002000 	.word	0x42002000
     4f8:	20002ff0 	.word	0x20002ff0
     4fc:	00001f85 	.word	0x00001f85
     500:	00000485 	.word	0x00000485

00000504 <system_init>:

void system_init(void)
{
     504:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     506:	4b13      	ldr	r3, [pc, #76]	; (554 <system_init+0x50>)
     508:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     50a:	23c0      	movs	r3, #192	; 0xc0
     50c:	05db      	lsls	r3, r3, #23
     50e:	2280      	movs	r2, #128	; 0x80
     510:	0212      	lsls	r2, r2, #8
     512:	2198      	movs	r1, #152	; 0x98
     514:	505a      	str	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     516:	3910      	subs	r1, #16
     518:	505a      	str	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     51a:	2382      	movs	r3, #130	; 0x82
     51c:	05db      	lsls	r3, r3, #23
     51e:	22a8      	movs	r2, #168	; 0xa8
     520:	490d      	ldr	r1, [pc, #52]	; (558 <system_init+0x54>)
     522:	5099      	str	r1, [r3, r2]
     524:	21c0      	movs	r1, #192	; 0xc0
     526:	0609      	lsls	r1, r1, #24
     528:	5099      	str	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     52a:	21cf      	movs	r1, #207	; 0xcf
     52c:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     52e:	2001      	movs	r0, #1
     530:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     532:	545a      	strb	r2, [r3, r1]
	// Set pin direction to output
	gpio_set_pin_direction(LED_PIN, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED_PIN, GPIO_PIN_FUNCTION_OFF);

	FLASH_0_init();
     534:	4b09      	ldr	r3, [pc, #36]	; (55c <system_init+0x58>)
     536:	4798      	blx	r3

	SPI_0_init();
     538:	4b09      	ldr	r3, [pc, #36]	; (560 <system_init+0x5c>)
     53a:	4798      	blx	r3

	TIMER_0_init();
     53c:	4b09      	ldr	r3, [pc, #36]	; (564 <system_init+0x60>)
     53e:	4798      	blx	r3
	TIMER_1_init();
     540:	4b09      	ldr	r3, [pc, #36]	; (568 <system_init+0x64>)
     542:	4798      	blx	r3
	WDT_0_init();
     544:	4b09      	ldr	r3, [pc, #36]	; (56c <system_init+0x68>)
     546:	4798      	blx	r3
	CAN_1_init();
     548:	4b09      	ldr	r3, [pc, #36]	; (570 <system_init+0x6c>)
     54a:	4798      	blx	r3
	CAN_0_init();
     54c:	4b09      	ldr	r3, [pc, #36]	; (574 <system_init+0x70>)
     54e:	4798      	blx	r3
}
     550:	bd10      	pop	{r4, pc}
     552:	46c0      	nop			; (mov r8, r8)
     554:	00002ae9 	.word	0x00002ae9
     558:	40008000 	.word	0x40008000
     55c:	0000029d 	.word	0x0000029d
     560:	00000395 	.word	0x00000395
     564:	0000020d 	.word	0x0000020d
     568:	0000024d 	.word	0x0000024d
     56c:	000003d1 	.word	0x000003d1
     570:	00000449 	.word	0x00000449
     574:	000004c9 	.word	0x000004c9

00000578 <CAN1_tx_callback>:
uint32_t u32cnt = 0;

void CAN1_tx_callback(struct can_async_descriptor *const descr)
{
	(void)descr;
}
     578:	4770      	bx	lr
	...

0000057c <CAN1_rx_callback>:

void CAN1_rx_callback(struct can_async_descriptor *const descr)
{
     57c:	b510      	push	{r4, lr}
     57e:	b094      	sub	sp, #80	; 0x50

	struct can_message msg;
	uint8_t            data[64];
	msg.data = data;
     580:	466b      	mov	r3, sp
     582:	9312      	str	r3, [sp, #72]	; 0x48
	can_async_read(descr, &msg);
     584:	a910      	add	r1, sp, #64	; 0x40
     586:	4b0b      	ldr	r3, [pc, #44]	; (5b4 <CAN1_rx_callback+0x38>)
     588:	4798      	blx	r3
		//u32cnt++;
		//SEGGER_RTT_printf(0,"CAN ID IS CAN_FMT_EXTID \r\n");
		//SEGGER_RTT_printf(0,"CAN ID  = %08x \r\n", msg.id);
	}
	
	for (uint8_t i =0; i < msg.len; i++)
     58a:	2400      	movs	r4, #0
     58c:	e007      	b.n	59e <CAN1_rx_callback+0x22>
	{	
		SEGGER_RTT_printf(0,"CAN1 data = %02x \r\n", msg.data[i]);	
     58e:	9b12      	ldr	r3, [sp, #72]	; 0x48
     590:	5d1a      	ldrb	r2, [r3, r4]
     592:	4909      	ldr	r1, [pc, #36]	; (5b8 <CAN1_rx_callback+0x3c>)
     594:	2000      	movs	r0, #0
     596:	4b09      	ldr	r3, [pc, #36]	; (5bc <CAN1_rx_callback+0x40>)
     598:	4798      	blx	r3
	for (uint8_t i =0; i < msg.len; i++)
     59a:	3401      	adds	r4, #1
     59c:	b2e4      	uxtb	r4, r4
     59e:	ab10      	add	r3, sp, #64	; 0x40
     5a0:	7b1a      	ldrb	r2, [r3, #12]
     5a2:	4294      	cmp	r4, r2
     5a4:	d3f3      	bcc.n	58e <CAN1_rx_callback+0x12>
	}
	SEGGER_RTT_printf(0,"len = %d \r\n", msg.len);
     5a6:	4906      	ldr	r1, [pc, #24]	; (5c0 <CAN1_rx_callback+0x44>)
     5a8:	2000      	movs	r0, #0
     5aa:	4b04      	ldr	r3, [pc, #16]	; (5bc <CAN1_rx_callback+0x40>)
     5ac:	4798      	blx	r3
	return;
}
     5ae:	b014      	add	sp, #80	; 0x50
     5b0:	bd10      	pop	{r4, pc}
     5b2:	46c0      	nop			; (mov r8, r8)
     5b4:	00002001 	.word	0x00002001
     5b8:	00003ae0 	.word	0x00003ae0
     5bc:	00003a1d 	.word	0x00003a1d
     5c0:	00003af4 	.word	0x00003af4

000005c4 <CAN1_Init>:


void CAN1_Init(void)
{
     5c4:	b5f0      	push	{r4, r5, r6, r7, lr}
     5c6:	46ce      	mov	lr, r9
     5c8:	4647      	mov	r7, r8
     5ca:	b580      	push	{r7, lr}
     5cc:	b089      	sub	sp, #36	; 0x24
	struct can_message msg;
	struct can_filter  filter;
	uint8_t            send_data[4];
	send_data[0] = 0x00;
     5ce:	ab01      	add	r3, sp, #4
     5d0:	2600      	movs	r6, #0
     5d2:	701e      	strb	r6, [r3, #0]
	send_data[1] = 0x01;
     5d4:	2201      	movs	r2, #1
     5d6:	4691      	mov	r9, r2
     5d8:	705a      	strb	r2, [r3, #1]
	send_data[2] = 0x02;
     5da:	2202      	movs	r2, #2
     5dc:	709a      	strb	r2, [r3, #2]
	send_data[3] = 0x03;
     5de:	3201      	adds	r2, #1
     5e0:	70da      	strb	r2, [r3, #3]

	msg.id   = 0x45A;
     5e2:	ad04      	add	r5, sp, #16
     5e4:	4a1b      	ldr	r2, [pc, #108]	; (654 <CAN1_Init+0x90>)
     5e6:	9204      	str	r2, [sp, #16]
	msg.type = CAN_TYPE_DATA;
     5e8:	712e      	strb	r6, [r5, #4]
	msg.data = send_data;
     5ea:	9306      	str	r3, [sp, #24]
	msg.len  = 4;
     5ec:	2304      	movs	r3, #4
     5ee:	732b      	strb	r3, [r5, #12]
	msg.fmt  = CAN_FMT_STDID;
     5f0:	736e      	strb	r6, [r5, #13]
	can_async_register_callback(&CAN_1, CAN_ASYNC_TX_CB, (FUNC_PTR)CAN1_tx_callback);
     5f2:	4c19      	ldr	r4, [pc, #100]	; (658 <CAN1_Init+0x94>)
     5f4:	4a19      	ldr	r2, [pc, #100]	; (65c <CAN1_Init+0x98>)
     5f6:	2101      	movs	r1, #1
     5f8:	0020      	movs	r0, r4
     5fa:	4f19      	ldr	r7, [pc, #100]	; (660 <CAN1_Init+0x9c>)
     5fc:	47b8      	blx	r7
	can_async_enable(&CAN_1);
     5fe:	0020      	movs	r0, r4
     600:	4b18      	ldr	r3, [pc, #96]	; (664 <CAN1_Init+0xa0>)
     602:	4798      	blx	r3

	/**
	 * CAN_1_tx_callback callback should be invoked after call
	 * can_async_write, and remote device should recieve message with ID=0x45A
	 */
	can_async_write(&CAN_1, &msg);
     604:	0029      	movs	r1, r5
     606:	0020      	movs	r0, r4
     608:	4b17      	ldr	r3, [pc, #92]	; (668 <CAN1_Init+0xa4>)
     60a:	4698      	mov	r8, r3
     60c:	4798      	blx	r3

	msg.id  = 0x100000A5;
     60e:	4b17      	ldr	r3, [pc, #92]	; (66c <CAN1_Init+0xa8>)
     610:	9304      	str	r3, [sp, #16]
	msg.fmt = CAN_FMT_EXTID;
     612:	464b      	mov	r3, r9
     614:	736b      	strb	r3, [r5, #13]
	/**
	 * remote device should recieve message with ID=0x100000A5
	 */
	can_async_write(&CAN_1, &msg);
     616:	0029      	movs	r1, r5
     618:	0020      	movs	r0, r4
     61a:	47c0      	blx	r8
	/**
	 * CAN_1_rx_callback callback should be invoked after call
	 * can_async_set_filter and remote device send CAN Message with the same
	 * content as the filter.
	 */
	can_async_register_callback(&CAN_1, CAN_ASYNC_RX_CB, (FUNC_PTR)CAN1_rx_callback);
     61c:	4a14      	ldr	r2, [pc, #80]	; (670 <CAN1_Init+0xac>)
     61e:	2100      	movs	r1, #0
     620:	0020      	movs	r0, r4
     622:	47b8      	blx	r7
	filter.id   = 0x469;
     624:	4b13      	ldr	r3, [pc, #76]	; (674 <CAN1_Init+0xb0>)
     626:	9302      	str	r3, [sp, #8]
	filter.mask = 0x100;
     628:	2380      	movs	r3, #128	; 0x80
     62a:	005b      	lsls	r3, r3, #1
     62c:	9303      	str	r3, [sp, #12]
	can_async_set_filter(&CAN_1, 0, CAN_FMT_STDID, &filter);
     62e:	ab02      	add	r3, sp, #8
     630:	2200      	movs	r2, #0
     632:	2100      	movs	r1, #0
     634:	0020      	movs	r0, r4
     636:	4d10      	ldr	r5, [pc, #64]	; (678 <CAN1_Init+0xb4>)
     638:	47a8      	blx	r5

	filter.id   = 0x10000096;
     63a:	4b10      	ldr	r3, [pc, #64]	; (67c <CAN1_Init+0xb8>)
     63c:	9302      	str	r3, [sp, #8]
	filter.mask = 0;
     63e:	9603      	str	r6, [sp, #12]
	can_async_set_filter(&CAN_1, 1, CAN_FMT_EXTID, &filter);
     640:	ab02      	add	r3, sp, #8
     642:	2201      	movs	r2, #1
     644:	2101      	movs	r1, #1
     646:	0020      	movs	r0, r4
     648:	47a8      	blx	r5
}
     64a:	b009      	add	sp, #36	; 0x24
     64c:	bc0c      	pop	{r2, r3}
     64e:	4690      	mov	r8, r2
     650:	4699      	mov	r9, r3
     652:	bdf0      	pop	{r4, r5, r6, r7, pc}
     654:	0000045a 	.word	0x0000045a
     658:	20003034 	.word	0x20003034
     65c:	00000579 	.word	0x00000579
     660:	00002071 	.word	0x00002071
     664:	00001fd9 	.word	0x00001fd9
     668:	00002039 	.word	0x00002039
     66c:	100000a5 	.word	0x100000a5
     670:	0000057d 	.word	0x0000057d
     674:	00000469 	.word	0x00000469
     678:	000020c1 	.word	0x000020c1
     67c:	10000096 	.word	0x10000096

00000680 <TIMER_0_task1_cb>:
 * Example of using TIMER_0.
 */
static void TIMER_0_task1_cb(const struct timer_task *const timer_task)
{

}
     680:	4770      	bx	lr

00000682 <TIMER_0_task2_cb>:

static void TIMER_0_task2_cb(const struct timer_task *const timer_task)
{
}
     682:	4770      	bx	lr

00000684 <TIMER_0_example>:

void TIMER_0_example(void)
{
     684:	b570      	push	{r4, r5, r6, lr}
	TIMER_0_task1.interval = 1;
     686:	4c0c      	ldr	r4, [pc, #48]	; (6b8 <TIMER_0_example+0x34>)
     688:	2301      	movs	r3, #1
     68a:	60a3      	str	r3, [r4, #8]
	TIMER_0_task1.cb       = TIMER_0_task1_cb;
     68c:	4a0b      	ldr	r2, [pc, #44]	; (6bc <TIMER_0_example+0x38>)
     68e:	60e2      	str	r2, [r4, #12]
	TIMER_0_task1.mode     = TIMER_TASK_REPEAT;
     690:	7423      	strb	r3, [r4, #16]
	TIMER_0_task2.interval = 200;
     692:	22c8      	movs	r2, #200	; 0xc8
     694:	61e2      	str	r2, [r4, #28]
	TIMER_0_task2.cb       = TIMER_0_task2_cb;
     696:	4a0a      	ldr	r2, [pc, #40]	; (6c0 <TIMER_0_example+0x3c>)
     698:	6222      	str	r2, [r4, #32]
	TIMER_0_task2.mode     = TIMER_TASK_REPEAT;
     69a:	2224      	movs	r2, #36	; 0x24
     69c:	54a3      	strb	r3, [r4, r2]

	timer_add_task(&TIMER_0, &TIMER_0_task1);
     69e:	4d09      	ldr	r5, [pc, #36]	; (6c4 <TIMER_0_example+0x40>)
     6a0:	0021      	movs	r1, r4
     6a2:	0028      	movs	r0, r5
     6a4:	4e08      	ldr	r6, [pc, #32]	; (6c8 <TIMER_0_example+0x44>)
     6a6:	47b0      	blx	r6
	timer_add_task(&TIMER_0, &TIMER_0_task2);
     6a8:	0021      	movs	r1, r4
     6aa:	3114      	adds	r1, #20
     6ac:	0028      	movs	r0, r5
     6ae:	47b0      	blx	r6
	timer_start(&TIMER_0);
     6b0:	0028      	movs	r0, r5
     6b2:	4b06      	ldr	r3, [pc, #24]	; (6cc <TIMER_0_example+0x48>)
     6b4:	4798      	blx	r3
}
     6b6:	bd70      	pop	{r4, r5, r6, pc}
     6b8:	2000014c 	.word	0x2000014c
     6bc:	00000681 	.word	0x00000681
     6c0:	00000683 	.word	0x00000683
     6c4:	20003094 	.word	0x20003094
     6c8:	000023ad 	.word	0x000023ad
     6cc:	00002371 	.word	0x00002371

000006d0 <start_tasks>:
	start_tasks();
}


void start_tasks(void)
{
     6d0:	b510      	push	{r4, lr}
	create_afe_task();
     6d2:	4b03      	ldr	r3, [pc, #12]	; (6e0 <start_tasks+0x10>)
     6d4:	4798      	blx	r3
	create_comm_task();
     6d6:	4b03      	ldr	r3, [pc, #12]	; (6e4 <start_tasks+0x14>)
     6d8:	4798      	blx	r3
	
	vTaskStartScheduler();
     6da:	4b03      	ldr	r3, [pc, #12]	; (6e8 <start_tasks+0x18>)
     6dc:	4798      	blx	r3
     6de:	bd10      	pop	{r4, pc}
     6e0:	000033c9 	.word	0x000033c9
     6e4:	00000155 	.word	0x00000155
     6e8:	000015c1 	.word	0x000015c1

000006ec <FREERTOS_Init>:
{
     6ec:	b510      	push	{r4, lr}
	start_tasks();
     6ee:	4b01      	ldr	r3, [pc, #4]	; (6f4 <FREERTOS_Init+0x8>)
     6f0:	4798      	blx	r3
}
     6f2:	bd10      	pop	{r4, pc}
     6f4:	000006d1 	.word	0x000006d1

000006f8 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6f8:	0003      	movs	r3, r0
     6fa:	3308      	adds	r3, #8
     6fc:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6fe:	2201      	movs	r2, #1
     700:	4252      	negs	r2, r2
     702:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     704:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     706:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     708:	2300      	movs	r3, #0
     70a:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     70c:	4770      	bx	lr

0000070e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     70e:	2300      	movs	r3, #0
     710:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     712:	4770      	bx	lr

00000714 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
     714:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     716:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     718:	689a      	ldr	r2, [r3, #8]
     71a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     71c:	689a      	ldr	r2, [r3, #8]
     71e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
     720:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     722:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     724:	6803      	ldr	r3, [r0, #0]
     726:	3301      	adds	r3, #1
     728:	6003      	str	r3, [r0, #0]
}
     72a:	4770      	bx	lr

0000072c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     72c:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     72e:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     730:	1c63      	adds	r3, r4, #1
     732:	d002      	beq.n	73a <vListInsert+0xe>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     734:	0002      	movs	r2, r0
     736:	3208      	adds	r2, #8
     738:	e002      	b.n	740 <vListInsert+0x14>
		pxIterator = pxList->xListEnd.pxPrevious;
     73a:	6902      	ldr	r2, [r0, #16]
     73c:	e004      	b.n	748 <vListInsert+0x1c>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     73e:	001a      	movs	r2, r3
     740:	6853      	ldr	r3, [r2, #4]
     742:	681d      	ldr	r5, [r3, #0]
     744:	42ac      	cmp	r4, r5
     746:	d2fa      	bcs.n	73e <vListInsert+0x12>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     748:	6853      	ldr	r3, [r2, #4]
     74a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     74c:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
     74e:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
     750:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     752:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     754:	6803      	ldr	r3, [r0, #0]
     756:	3301      	adds	r3, #1
     758:	6003      	str	r3, [r0, #0]
}
     75a:	bd30      	pop	{r4, r5, pc}

0000075c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     75c:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     75e:	6842      	ldr	r2, [r0, #4]
     760:	6881      	ldr	r1, [r0, #8]
     762:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     764:	6882      	ldr	r2, [r0, #8]
     766:	6841      	ldr	r1, [r0, #4]
     768:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     76a:	685a      	ldr	r2, [r3, #4]
     76c:	4290      	cmp	r0, r2
     76e:	d006      	beq.n	77e <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     770:	2200      	movs	r2, #0
     772:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
     774:	681a      	ldr	r2, [r3, #0]
     776:	3a01      	subs	r2, #1
     778:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     77a:	6818      	ldr	r0, [r3, #0]
}
     77c:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     77e:	6882      	ldr	r2, [r0, #8]
     780:	605a      	str	r2, [r3, #4]
     782:	e7f5      	b.n	770 <uxListRemove+0x14>

00000784 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
     784:	b510      	push	{r4, lr}
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
     786:	4a11      	ldr	r2, [pc, #68]	; (7cc <prvHeapInit+0x48>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
     788:	0753      	lsls	r3, r2, #29
     78a:	d01b      	beq.n	7c4 <prvHeapInit+0x40>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
     78c:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
     78e:	2307      	movs	r3, #7
     790:	4399      	bics	r1, r3
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
     792:	23a0      	movs	r3, #160	; 0xa0
     794:	019b      	lsls	r3, r3, #6
     796:	1a5b      	subs	r3, r3, r1
     798:	189b      	adds	r3, r3, r2
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
     79a:	000a      	movs	r2, r1

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     79c:	490c      	ldr	r1, [pc, #48]	; (7d0 <prvHeapInit+0x4c>)
     79e:	600a      	str	r2, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
     7a0:	2000      	movs	r0, #0
     7a2:	6048      	str	r0, [r1, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
     7a4:	18d3      	adds	r3, r2, r3
	uxAddress -= xHeapStructSize;
     7a6:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
     7a8:	2407      	movs	r4, #7
     7aa:	43a3      	bics	r3, r4
	pxEnd = ( void * ) uxAddress;
     7ac:	608b      	str	r3, [r1, #8]
	pxEnd->xBlockSize = 0;
     7ae:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
     7b0:	6018      	str	r0, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     7b2:	1a98      	subs	r0, r3, r2
     7b4:	6050      	str	r0, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     7b6:	6013      	str	r3, [r2, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     7b8:	60c8      	str	r0, [r1, #12]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     7ba:	6108      	str	r0, [r1, #16]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     7bc:	2380      	movs	r3, #128	; 0x80
     7be:	061b      	lsls	r3, r3, #24
     7c0:	614b      	str	r3, [r1, #20]
}
     7c2:	bd10      	pop	{r4, pc}
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
     7c4:	23a0      	movs	r3, #160	; 0xa0
     7c6:	019b      	lsls	r3, r3, #6
     7c8:	e7e8      	b.n	79c <prvHeapInit+0x18>
     7ca:	46c0      	nop			; (mov r8, r8)
     7cc:	2000019c 	.word	0x2000019c
     7d0:	2000299c 	.word	0x2000299c

000007d4 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     7d4:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     7d6:	4b12      	ldr	r3, [pc, #72]	; (820 <prvInsertBlockIntoFreeList+0x4c>)
     7d8:	681a      	ldr	r2, [r3, #0]
     7da:	4282      	cmp	r2, r0
     7dc:	d319      	bcc.n	812 <prvInsertBlockIntoFreeList+0x3e>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     7de:	6859      	ldr	r1, [r3, #4]
     7e0:	185c      	adds	r4, r3, r1
     7e2:	42a0      	cmp	r0, r4
     7e4:	d103      	bne.n	7ee <prvInsertBlockIntoFreeList+0x1a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     7e6:	6840      	ldr	r0, [r0, #4]
     7e8:	1809      	adds	r1, r1, r0
     7ea:	6059      	str	r1, [r3, #4]
		pxBlockToInsert = pxIterator;
     7ec:	0018      	movs	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     7ee:	6841      	ldr	r1, [r0, #4]
     7f0:	1844      	adds	r4, r0, r1
     7f2:	42a2      	cmp	r2, r4
     7f4:	d111      	bne.n	81a <prvInsertBlockIntoFreeList+0x46>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     7f6:	4c0a      	ldr	r4, [pc, #40]	; (820 <prvInsertBlockIntoFreeList+0x4c>)
     7f8:	68a4      	ldr	r4, [r4, #8]
     7fa:	42a2      	cmp	r2, r4
     7fc:	d00b      	beq.n	816 <prvInsertBlockIntoFreeList+0x42>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     7fe:	6852      	ldr	r2, [r2, #4]
     800:	1889      	adds	r1, r1, r2
     802:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     804:	681a      	ldr	r2, [r3, #0]
     806:	6812      	ldr	r2, [r2, #0]
     808:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     80a:	4298      	cmp	r0, r3
     80c:	d000      	beq.n	810 <prvInsertBlockIntoFreeList+0x3c>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     80e:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     810:	bd10      	pop	{r4, pc}
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     812:	0013      	movs	r3, r2
     814:	e7e0      	b.n	7d8 <prvInsertBlockIntoFreeList+0x4>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     816:	6004      	str	r4, [r0, #0]
     818:	e7f7      	b.n	80a <prvInsertBlockIntoFreeList+0x36>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     81a:	6002      	str	r2, [r0, #0]
     81c:	e7f5      	b.n	80a <prvInsertBlockIntoFreeList+0x36>
     81e:	46c0      	nop			; (mov r8, r8)
     820:	2000299c 	.word	0x2000299c

00000824 <pvPortMalloc>:
{
     824:	b570      	push	{r4, r5, r6, lr}
     826:	0004      	movs	r4, r0
	vTaskSuspendAll();
     828:	4b2f      	ldr	r3, [pc, #188]	; (8e8 <pvPortMalloc+0xc4>)
     82a:	4798      	blx	r3
		if( pxEnd == NULL )
     82c:	4b2f      	ldr	r3, [pc, #188]	; (8ec <pvPortMalloc+0xc8>)
     82e:	689b      	ldr	r3, [r3, #8]
     830:	2b00      	cmp	r3, #0
     832:	d00f      	beq.n	854 <pvPortMalloc+0x30>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     834:	4b2d      	ldr	r3, [pc, #180]	; (8ec <pvPortMalloc+0xc8>)
     836:	695b      	ldr	r3, [r3, #20]
     838:	4223      	tst	r3, r4
     83a:	d14a      	bne.n	8d2 <pvPortMalloc+0xae>
			if( xWantedSize > 0 )
     83c:	2c00      	cmp	r4, #0
     83e:	d00c      	beq.n	85a <pvPortMalloc+0x36>
				xWantedSize += xHeapStructSize;
     840:	3408      	adds	r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
     842:	0763      	lsls	r3, r4, #29
     844:	d009      	beq.n	85a <pvPortMalloc+0x36>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
     846:	2307      	movs	r3, #7
     848:	439c      	bics	r4, r3
     84a:	3408      	adds	r4, #8
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
     84c:	4223      	tst	r3, r4
     84e:	d004      	beq.n	85a <pvPortMalloc+0x36>
     850:	b672      	cpsid	i
     852:	e7fe      	b.n	852 <pvPortMalloc+0x2e>
			prvHeapInit();
     854:	4b26      	ldr	r3, [pc, #152]	; (8f0 <pvPortMalloc+0xcc>)
     856:	4798      	blx	r3
     858:	e7ec      	b.n	834 <pvPortMalloc+0x10>
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     85a:	2c00      	cmp	r4, #0
     85c:	d03b      	beq.n	8d6 <pvPortMalloc+0xb2>
     85e:	4b23      	ldr	r3, [pc, #140]	; (8ec <pvPortMalloc+0xc8>)
     860:	691b      	ldr	r3, [r3, #16]
     862:	429c      	cmp	r4, r3
     864:	d839      	bhi.n	8da <pvPortMalloc+0xb6>
				pxBlock = xStart.pxNextFreeBlock;
     866:	4b21      	ldr	r3, [pc, #132]	; (8ec <pvPortMalloc+0xc8>)
     868:	681d      	ldr	r5, [r3, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     86a:	e001      	b.n	870 <pvPortMalloc+0x4c>
					pxPreviousBlock = pxBlock;
     86c:	002b      	movs	r3, r5
					pxBlock = pxBlock->pxNextFreeBlock;
     86e:	0015      	movs	r5, r2
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     870:	686a      	ldr	r2, [r5, #4]
     872:	4294      	cmp	r4, r2
     874:	d902      	bls.n	87c <pvPortMalloc+0x58>
     876:	682a      	ldr	r2, [r5, #0]
     878:	2a00      	cmp	r2, #0
     87a:	d1f7      	bne.n	86c <pvPortMalloc+0x48>
				if( pxBlock != pxEnd )
     87c:	4a1b      	ldr	r2, [pc, #108]	; (8ec <pvPortMalloc+0xc8>)
     87e:	6892      	ldr	r2, [r2, #8]
     880:	4295      	cmp	r5, r2
     882:	d02c      	beq.n	8de <pvPortMalloc+0xba>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     884:	681e      	ldr	r6, [r3, #0]
     886:	3608      	adds	r6, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     888:	682a      	ldr	r2, [r5, #0]
     88a:	601a      	str	r2, [r3, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     88c:	686b      	ldr	r3, [r5, #4]
     88e:	1b1b      	subs	r3, r3, r4
     890:	2b10      	cmp	r3, #16
     892:	d908      	bls.n	8a6 <pvPortMalloc+0x82>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     894:	1928      	adds	r0, r5, r4
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
     896:	0742      	lsls	r2, r0, #29
     898:	d001      	beq.n	89e <pvPortMalloc+0x7a>
     89a:	b672      	cpsid	i
     89c:	e7fe      	b.n	89c <pvPortMalloc+0x78>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     89e:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
     8a0:	606c      	str	r4, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     8a2:	4b14      	ldr	r3, [pc, #80]	; (8f4 <pvPortMalloc+0xd0>)
     8a4:	4798      	blx	r3
					xFreeBytesRemaining -= pxBlock->xBlockSize;
     8a6:	6869      	ldr	r1, [r5, #4]
     8a8:	4a10      	ldr	r2, [pc, #64]	; (8ec <pvPortMalloc+0xc8>)
     8aa:	6913      	ldr	r3, [r2, #16]
     8ac:	1a5b      	subs	r3, r3, r1
     8ae:	6113      	str	r3, [r2, #16]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     8b0:	68d2      	ldr	r2, [r2, #12]
     8b2:	4293      	cmp	r3, r2
     8b4:	d201      	bcs.n	8ba <pvPortMalloc+0x96>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     8b6:	4a0d      	ldr	r2, [pc, #52]	; (8ec <pvPortMalloc+0xc8>)
     8b8:	60d3      	str	r3, [r2, #12]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     8ba:	4b0c      	ldr	r3, [pc, #48]	; (8ec <pvPortMalloc+0xc8>)
     8bc:	695b      	ldr	r3, [r3, #20]
     8be:	430b      	orrs	r3, r1
     8c0:	606b      	str	r3, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
     8c2:	2300      	movs	r3, #0
     8c4:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
     8c6:	4b0c      	ldr	r3, [pc, #48]	; (8f8 <pvPortMalloc+0xd4>)
     8c8:	4798      	blx	r3
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
     8ca:	0773      	lsls	r3, r6, #29
     8cc:	d009      	beq.n	8e2 <pvPortMalloc+0xbe>
     8ce:	b672      	cpsid	i
     8d0:	e7fe      	b.n	8d0 <pvPortMalloc+0xac>
void *pvReturn = NULL;
     8d2:	2600      	movs	r6, #0
     8d4:	e7f7      	b.n	8c6 <pvPortMalloc+0xa2>
     8d6:	2600      	movs	r6, #0
     8d8:	e7f5      	b.n	8c6 <pvPortMalloc+0xa2>
     8da:	2600      	movs	r6, #0
     8dc:	e7f3      	b.n	8c6 <pvPortMalloc+0xa2>
     8de:	2600      	movs	r6, #0
     8e0:	e7f1      	b.n	8c6 <pvPortMalloc+0xa2>
}
     8e2:	0030      	movs	r0, r6
     8e4:	bd70      	pop	{r4, r5, r6, pc}
     8e6:	46c0      	nop			; (mov r8, r8)
     8e8:	00001629 	.word	0x00001629
     8ec:	2000299c 	.word	0x2000299c
     8f0:	00000785 	.word	0x00000785
     8f4:	000007d5 	.word	0x000007d5
     8f8:	00001745 	.word	0x00001745

000008fc <vPortFree>:
{
     8fc:	b570      	push	{r4, r5, r6, lr}
	if( pv != NULL )
     8fe:	2800      	cmp	r0, #0
     900:	d020      	beq.n	944 <vPortFree+0x48>
		puc -= xHeapStructSize;
     902:	0005      	movs	r5, r0
     904:	3d08      	subs	r5, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
     906:	686b      	ldr	r3, [r5, #4]
     908:	4a0f      	ldr	r2, [pc, #60]	; (948 <vPortFree+0x4c>)
     90a:	6952      	ldr	r2, [r2, #20]
     90c:	421a      	tst	r2, r3
     90e:	d101      	bne.n	914 <vPortFree+0x18>
     910:	b672      	cpsid	i
     912:	e7fe      	b.n	912 <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
     914:	0001      	movs	r1, r0
     916:	3908      	subs	r1, #8
     918:	6809      	ldr	r1, [r1, #0]
     91a:	2900      	cmp	r1, #0
     91c:	d001      	beq.n	922 <vPortFree+0x26>
     91e:	b672      	cpsid	i
     920:	e7fe      	b.n	920 <vPortFree+0x24>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     922:	3808      	subs	r0, #8
     924:	0004      	movs	r4, r0
     926:	4393      	bics	r3, r2
     928:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
     92a:	4b08      	ldr	r3, [pc, #32]	; (94c <vPortFree+0x50>)
     92c:	4798      	blx	r3
					xFreeBytesRemaining += pxLink->xBlockSize;
     92e:	6863      	ldr	r3, [r4, #4]
     930:	4a05      	ldr	r2, [pc, #20]	; (948 <vPortFree+0x4c>)
     932:	6911      	ldr	r1, [r2, #16]
     934:	468c      	mov	ip, r1
     936:	4463      	add	r3, ip
     938:	6113      	str	r3, [r2, #16]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     93a:	0028      	movs	r0, r5
     93c:	4b04      	ldr	r3, [pc, #16]	; (950 <vPortFree+0x54>)
     93e:	4798      	blx	r3
				( void ) xTaskResumeAll();
     940:	4b04      	ldr	r3, [pc, #16]	; (954 <vPortFree+0x58>)
     942:	4798      	blx	r3
}
     944:	bd70      	pop	{r4, r5, r6, pc}
     946:	46c0      	nop			; (mov r8, r8)
     948:	2000299c 	.word	0x2000299c
     94c:	00001629 	.word	0x00001629
     950:	000007d5 	.word	0x000007d5
     954:	00001745 	.word	0x00001745

00000958 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
     958:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0UL;
     95a:	2300      	movs	r3, #0
     95c:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
     95e:	4b06      	ldr	r3, [pc, #24]	; (978 <prvTaskExitError+0x20>)
     960:	681b      	ldr	r3, [r3, #0]
     962:	3301      	adds	r3, #1
     964:	d001      	beq.n	96a <prvTaskExitError+0x12>
     966:	b672      	cpsid	i
     968:	e7fe      	b.n	968 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
     96a:	b672      	cpsid	i
	while( ulDummy == 0 )
     96c:	9b01      	ldr	r3, [sp, #4]
     96e:	2b00      	cmp	r3, #0
     970:	d0fc      	beq.n	96c <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
     972:	b002      	add	sp, #8
     974:	4770      	bx	lr
     976:	46c0      	nop			; (mov r8, r8)
     978:	20000000 	.word	0x20000000
     97c:	00000000 	.word	0x00000000

00000980 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
     980:	4a0b      	ldr	r2, [pc, #44]	; (9b0 <pxCurrentTCBConst2>)
     982:	6813      	ldr	r3, [r2, #0]
     984:	6818      	ldr	r0, [r3, #0]
     986:	3020      	adds	r0, #32
     988:	f380 8809 	msr	PSP, r0
     98c:	2002      	movs	r0, #2
     98e:	f380 8814 	msr	CONTROL, r0
     992:	f3bf 8f6f 	isb	sy
     996:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
     998:	46ae      	mov	lr, r5
     99a:	bc08      	pop	{r3}
     99c:	bc04      	pop	{r2}
     99e:	b662      	cpsie	i
     9a0:	4718      	bx	r3
     9a2:	46c0      	nop			; (mov r8, r8)
     9a4:	46c0      	nop			; (mov r8, r8)
     9a6:	46c0      	nop			; (mov r8, r8)
     9a8:	46c0      	nop			; (mov r8, r8)
     9aa:	46c0      	nop			; (mov r8, r8)
     9ac:	46c0      	nop			; (mov r8, r8)
     9ae:	46c0      	nop			; (mov r8, r8)

000009b0 <pxCurrentTCBConst2>:
     9b0:	20002a8c 	.word	0x20002a8c

000009b4 <prvSetupTimerInterrupt>:
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL) = 0UL;
     9b4:	4b05      	ldr	r3, [pc, #20]	; (9cc <prvSetupTimerInterrupt+0x18>)
     9b6:	2200      	movs	r2, #0
     9b8:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
     9ba:	4905      	ldr	r1, [pc, #20]	; (9d0 <prvSetupTimerInterrupt+0x1c>)
     9bc:	600a      	str	r2, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
     9be:	4905      	ldr	r1, [pc, #20]	; (9d4 <prvSetupTimerInterrupt+0x20>)
     9c0:	4a05      	ldr	r2, [pc, #20]	; (9d8 <prvSetupTimerInterrupt+0x24>)
     9c2:	6011      	str	r1, [r2, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
     9c4:	2207      	movs	r2, #7
     9c6:	601a      	str	r2, [r3, #0]
}
     9c8:	4770      	bx	lr
     9ca:	46c0      	nop			; (mov r8, r8)
     9cc:	e000e010 	.word	0xe000e010
     9d0:	e000e018 	.word	0xe000e018
     9d4:	00000f9f 	.word	0x00000f9f
     9d8:	e000e014 	.word	0xe000e014

000009dc <pxPortInitialiseStack>:
{
     9dc:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
     9de:	1f03      	subs	r3, r0, #4
     9e0:	2480      	movs	r4, #128	; 0x80
     9e2:	0464      	lsls	r4, r4, #17
     9e4:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
     9e6:	3b04      	subs	r3, #4
     9e8:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
     9ea:	3b04      	subs	r3, #4
     9ec:	4902      	ldr	r1, [pc, #8]	; (9f8 <pxPortInitialiseStack+0x1c>)
     9ee:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
     9f0:	3b14      	subs	r3, #20
     9f2:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8; /* R11..R4. */
     9f4:	3840      	subs	r0, #64	; 0x40
}
     9f6:	bd10      	pop	{r4, pc}
     9f8:	00000959 	.word	0x00000959

000009fc <xPortStartScheduler>:
{
     9fc:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
     9fe:	4b0c      	ldr	r3, [pc, #48]	; (a30 <xPortStartScheduler+0x34>)
     a00:	6819      	ldr	r1, [r3, #0]
     a02:	22ff      	movs	r2, #255	; 0xff
     a04:	0412      	lsls	r2, r2, #16
     a06:	430a      	orrs	r2, r1
     a08:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
     a0a:	6819      	ldr	r1, [r3, #0]
     a0c:	22ff      	movs	r2, #255	; 0xff
     a0e:	0612      	lsls	r2, r2, #24
     a10:	430a      	orrs	r2, r1
     a12:	601a      	str	r2, [r3, #0]
	prvSetupTimerInterrupt();
     a14:	4b07      	ldr	r3, [pc, #28]	; (a34 <xPortStartScheduler+0x38>)
     a16:	4798      	blx	r3
	uxCriticalNesting = 0;
     a18:	2200      	movs	r2, #0
     a1a:	4b07      	ldr	r3, [pc, #28]	; (a38 <xPortStartScheduler+0x3c>)
     a1c:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
     a1e:	4b07      	ldr	r3, [pc, #28]	; (a3c <xPortStartScheduler+0x40>)
     a20:	4798      	blx	r3
	vTaskSwitchContext();
     a22:	4b07      	ldr	r3, [pc, #28]	; (a40 <xPortStartScheduler+0x44>)
     a24:	4798      	blx	r3
	prvTaskExitError();
     a26:	4b07      	ldr	r3, [pc, #28]	; (a44 <xPortStartScheduler+0x48>)
     a28:	4798      	blx	r3
}
     a2a:	2000      	movs	r0, #0
     a2c:	bd10      	pop	{r4, pc}
     a2e:	46c0      	nop			; (mov r8, r8)
     a30:	e000ed20 	.word	0xe000ed20
     a34:	000009b5 	.word	0x000009b5
     a38:	20000000 	.word	0x20000000
     a3c:	00000981 	.word	0x00000981
     a40:	0000187d 	.word	0x0000187d
     a44:	00000959 	.word	0x00000959

00000a48 <vPortYield>:
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
     a48:	2280      	movs	r2, #128	; 0x80
     a4a:	0552      	lsls	r2, r2, #21
     a4c:	4b03      	ldr	r3, [pc, #12]	; (a5c <vPortYield+0x14>)
     a4e:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" ::: "memory" );
     a50:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     a54:	f3bf 8f6f 	isb	sy
}
     a58:	4770      	bx	lr
     a5a:	46c0      	nop			; (mov r8, r8)
     a5c:	e000ed04 	.word	0xe000ed04

00000a60 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
     a60:	b672      	cpsid	i
    uxCriticalNesting++;
     a62:	4a04      	ldr	r2, [pc, #16]	; (a74 <vPortEnterCritical+0x14>)
     a64:	6813      	ldr	r3, [r2, #0]
     a66:	3301      	adds	r3, #1
     a68:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" ::: "memory" );
     a6a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
     a6e:	f3bf 8f6f 	isb	sy
}
     a72:	4770      	bx	lr
     a74:	20000000 	.word	0x20000000

00000a78 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
     a78:	4b06      	ldr	r3, [pc, #24]	; (a94 <vPortExitCritical+0x1c>)
     a7a:	681b      	ldr	r3, [r3, #0]
     a7c:	2b00      	cmp	r3, #0
     a7e:	d101      	bne.n	a84 <vPortExitCritical+0xc>
     a80:	b672      	cpsid	i
     a82:	e7fe      	b.n	a82 <vPortExitCritical+0xa>
    uxCriticalNesting--;
     a84:	3b01      	subs	r3, #1
     a86:	4a03      	ldr	r2, [pc, #12]	; (a94 <vPortExitCritical+0x1c>)
     a88:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
     a8a:	2b00      	cmp	r3, #0
     a8c:	d100      	bne.n	a90 <vPortExitCritical+0x18>
        portENABLE_INTERRUPTS();
     a8e:	b662      	cpsie	i
}
     a90:	4770      	bx	lr
     a92:	46c0      	nop			; (mov r8, r8)
     a94:	20000000 	.word	0x20000000

00000a98 <ulSetInterruptMaskFromISR>:
	__asm volatile(
     a98:	f3ef 8010 	mrs	r0, PRIMASK
     a9c:	b672      	cpsid	i
     a9e:	4770      	bx	lr

00000aa0 <vClearInterruptMaskFromISR>:
	__asm volatile(
     aa0:	f380 8810 	msr	PRIMASK, r0
     aa4:	4770      	bx	lr
	...

00000ab0 <PendSV_Handler>:
	__asm volatile
     ab0:	f3ef 8009 	mrs	r0, PSP
     ab4:	4b0e      	ldr	r3, [pc, #56]	; (af0 <pxCurrentTCBConst>)
     ab6:	681a      	ldr	r2, [r3, #0]
     ab8:	3820      	subs	r0, #32
     aba:	6010      	str	r0, [r2, #0]
     abc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     abe:	4644      	mov	r4, r8
     ac0:	464d      	mov	r5, r9
     ac2:	4656      	mov	r6, sl
     ac4:	465f      	mov	r7, fp
     ac6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     ac8:	b508      	push	{r3, lr}
     aca:	b672      	cpsid	i
     acc:	f000 fed6 	bl	187c <vTaskSwitchContext>
     ad0:	b662      	cpsie	i
     ad2:	bc0c      	pop	{r2, r3}
     ad4:	6811      	ldr	r1, [r2, #0]
     ad6:	6808      	ldr	r0, [r1, #0]
     ad8:	3010      	adds	r0, #16
     ada:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     adc:	46a0      	mov	r8, r4
     ade:	46a9      	mov	r9, r5
     ae0:	46b2      	mov	sl, r6
     ae2:	46bb      	mov	fp, r7
     ae4:	f380 8809 	msr	PSP, r0
     ae8:	3820      	subs	r0, #32
     aea:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     aec:	4718      	bx	r3
     aee:	46c0      	nop			; (mov r8, r8)

00000af0 <pxCurrentTCBConst>:
     af0:	20002a8c 	.word	0x20002a8c

00000af4 <SysTick_Handler>:
{
     af4:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     af6:	4b07      	ldr	r3, [pc, #28]	; (b14 <SysTick_Handler+0x20>)
     af8:	4798      	blx	r3
     afa:	0004      	movs	r4, r0
		if( xTaskIncrementTick() != pdFALSE )
     afc:	4b06      	ldr	r3, [pc, #24]	; (b18 <SysTick_Handler+0x24>)
     afe:	4798      	blx	r3
     b00:	2800      	cmp	r0, #0
     b02:	d003      	beq.n	b0c <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     b04:	2280      	movs	r2, #128	; 0x80
     b06:	0552      	lsls	r2, r2, #21
     b08:	4b04      	ldr	r3, [pc, #16]	; (b1c <SysTick_Handler+0x28>)
     b0a:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
     b0c:	0020      	movs	r0, r4
     b0e:	4b04      	ldr	r3, [pc, #16]	; (b20 <SysTick_Handler+0x2c>)
     b10:	4798      	blx	r3
}
     b12:	bd10      	pop	{r4, pc}
     b14:	00000a99 	.word	0x00000a99
     b18:	00001645 	.word	0x00001645
     b1c:	e000ed04 	.word	0xe000ed04
     b20:	00000aa1 	.word	0x00000aa1

00000b24 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
     b24:	b510      	push	{r4, lr}
     b26:	0004      	movs	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b28:	4b06      	ldr	r3, [pc, #24]	; (b44 <prvIsQueueFull+0x20>)
     b2a:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     b2c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
     b2e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     b30:	429a      	cmp	r2, r3
     b32:	d004      	beq.n	b3e <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
     b34:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
     b36:	4b04      	ldr	r3, [pc, #16]	; (b48 <prvIsQueueFull+0x24>)
     b38:	4798      	blx	r3

	return xReturn;
}
     b3a:	0020      	movs	r0, r4
     b3c:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
     b3e:	2401      	movs	r4, #1
     b40:	e7f9      	b.n	b36 <prvIsQueueFull+0x12>
     b42:	46c0      	nop			; (mov r8, r8)
     b44:	00000a61 	.word	0x00000a61
     b48:	00000a79 	.word	0x00000a79

00000b4c <prvIsQueueEmpty>:
{
     b4c:	b510      	push	{r4, lr}
     b4e:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
     b50:	4b05      	ldr	r3, [pc, #20]	; (b68 <prvIsQueueEmpty+0x1c>)
     b52:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     b54:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     b56:	2b00      	cmp	r3, #0
     b58:	d004      	beq.n	b64 <prvIsQueueEmpty+0x18>
			xReturn = pdFALSE;
     b5a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
     b5c:	4b03      	ldr	r3, [pc, #12]	; (b6c <prvIsQueueEmpty+0x20>)
     b5e:	4798      	blx	r3
}
     b60:	0020      	movs	r0, r4
     b62:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
     b64:	2401      	movs	r4, #1
     b66:	e7f9      	b.n	b5c <prvIsQueueEmpty+0x10>
     b68:	00000a61 	.word	0x00000a61
     b6c:	00000a79 	.word	0x00000a79

00000b70 <prvCopyDataToQueue>:
{
     b70:	b570      	push	{r4, r5, r6, lr}
     b72:	0004      	movs	r4, r0
     b74:	0016      	movs	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     b76:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     b78:	6c02      	ldr	r2, [r0, #64]	; 0x40
     b7a:	2a00      	cmp	r2, #0
     b7c:	d10a      	bne.n	b94 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b7e:	6803      	ldr	r3, [r0, #0]
     b80:	2b00      	cmp	r3, #0
     b82:	d12e      	bne.n	be2 <prvCopyDataToQueue+0x72>
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
     b84:	6880      	ldr	r0, [r0, #8]
     b86:	4b1b      	ldr	r3, [pc, #108]	; (bf4 <prvCopyDataToQueue+0x84>)
     b88:	4798      	blx	r3
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
     b8a:	2300      	movs	r3, #0
     b8c:	60a3      	str	r3, [r4, #8]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
     b8e:	3501      	adds	r5, #1
     b90:	63a5      	str	r5, [r4, #56]	; 0x38
}
     b92:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
     b94:	2e00      	cmp	r6, #0
     b96:	d10e      	bne.n	bb6 <prvCopyDataToQueue+0x46>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
     b98:	6840      	ldr	r0, [r0, #4]
     b9a:	4b17      	ldr	r3, [pc, #92]	; (bf8 <prvCopyDataToQueue+0x88>)
     b9c:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
     b9e:	6863      	ldr	r3, [r4, #4]
     ba0:	6c22      	ldr	r2, [r4, #64]	; 0x40
     ba2:	4694      	mov	ip, r2
     ba4:	4463      	add	r3, ip
     ba6:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     ba8:	68a2      	ldr	r2, [r4, #8]
     baa:	4293      	cmp	r3, r2
     bac:	d31b      	bcc.n	be6 <prvCopyDataToQueue+0x76>
			pxQueue->pcWriteTo = pxQueue->pcHead;
     bae:	6823      	ldr	r3, [r4, #0]
     bb0:	6063      	str	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
     bb2:	2000      	movs	r0, #0
     bb4:	e7eb      	b.n	b8e <prvCopyDataToQueue+0x1e>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
     bb6:	68c0      	ldr	r0, [r0, #12]
     bb8:	4b0f      	ldr	r3, [pc, #60]	; (bf8 <prvCopyDataToQueue+0x88>)
     bba:	4798      	blx	r3
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
     bbc:	6c23      	ldr	r3, [r4, #64]	; 0x40
     bbe:	425b      	negs	r3, r3
     bc0:	68e2      	ldr	r2, [r4, #12]
     bc2:	18d2      	adds	r2, r2, r3
     bc4:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     bc6:	6821      	ldr	r1, [r4, #0]
     bc8:	428a      	cmp	r2, r1
     bca:	d203      	bcs.n	bd4 <prvCopyDataToQueue+0x64>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
     bcc:	68a2      	ldr	r2, [r4, #8]
     bce:	4694      	mov	ip, r2
     bd0:	4463      	add	r3, ip
     bd2:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
     bd4:	2e02      	cmp	r6, #2
     bd6:	d108      	bne.n	bea <prvCopyDataToQueue+0x7a>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     bd8:	2d00      	cmp	r5, #0
     bda:	d008      	beq.n	bee <prvCopyDataToQueue+0x7e>
				--uxMessagesWaiting;
     bdc:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
     bde:	2000      	movs	r0, #0
     be0:	e7d5      	b.n	b8e <prvCopyDataToQueue+0x1e>
     be2:	2000      	movs	r0, #0
     be4:	e7d3      	b.n	b8e <prvCopyDataToQueue+0x1e>
     be6:	2000      	movs	r0, #0
     be8:	e7d1      	b.n	b8e <prvCopyDataToQueue+0x1e>
     bea:	2000      	movs	r0, #0
     bec:	e7cf      	b.n	b8e <prvCopyDataToQueue+0x1e>
     bee:	2000      	movs	r0, #0
     bf0:	e7cd      	b.n	b8e <prvCopyDataToQueue+0x1e>
     bf2:	46c0      	nop			; (mov r8, r8)
     bf4:	00001a95 	.word	0x00001a95
     bf8:	00003a85 	.word	0x00003a85

00000bfc <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
     bfc:	b570      	push	{r4, r5, r6, lr}
     bfe:	b082      	sub	sp, #8
     c00:	9001      	str	r0, [sp, #4]
     c02:	000a      	movs	r2, r1
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
     c04:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
     c06:	2c00      	cmp	r4, #0
     c08:	d005      	beq.n	c16 <prvNotifyQueueSetContainer+0x1a>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
     c0a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     c0c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     c0e:	4299      	cmp	r1, r3
     c10:	d303      	bcc.n	c1a <prvNotifyQueueSetContainer+0x1e>
     c12:	b672      	cpsid	i
     c14:	e7fe      	b.n	c14 <prvNotifyQueueSetContainer+0x18>
		configASSERT( pxQueueSetContainer );
     c16:	b672      	cpsid	i
     c18:	e7fe      	b.n	c18 <prvNotifyQueueSetContainer+0x1c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
     c1a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
     c1c:	428b      	cmp	r3, r1
     c1e:	d803      	bhi.n	c28 <prvNotifyQueueSetContainer+0x2c>
	BaseType_t xReturn = pdFALSE;
     c20:	2600      	movs	r6, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
     c22:	0030      	movs	r0, r6
     c24:	b002      	add	sp, #8
     c26:	bd70      	pop	{r4, r5, r6, pc}
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
     c28:	2345      	movs	r3, #69	; 0x45
     c2a:	5ce5      	ldrb	r5, [r4, r3]
     c2c:	b26d      	sxtb	r5, r5
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
     c2e:	a901      	add	r1, sp, #4
     c30:	0020      	movs	r0, r4
     c32:	4b0a      	ldr	r3, [pc, #40]	; (c5c <prvNotifyQueueSetContainer+0x60>)
     c34:	4798      	blx	r3
     c36:	0006      	movs	r6, r0
			if( cTxLock == queueUNLOCKED )
     c38:	1c6b      	adds	r3, r5, #1
     c3a:	d10a      	bne.n	c52 <prvNotifyQueueSetContainer+0x56>
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
     c3c:	6a63      	ldr	r3, [r4, #36]	; 0x24
     c3e:	2b00      	cmp	r3, #0
     c40:	d0ef      	beq.n	c22 <prvNotifyQueueSetContainer+0x26>
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
     c42:	0020      	movs	r0, r4
     c44:	3024      	adds	r0, #36	; 0x24
     c46:	4b06      	ldr	r3, [pc, #24]	; (c60 <prvNotifyQueueSetContainer+0x64>)
     c48:	4798      	blx	r3
     c4a:	2800      	cmp	r0, #0
     c4c:	d0e9      	beq.n	c22 <prvNotifyQueueSetContainer+0x26>
						xReturn = pdTRUE;
     c4e:	2601      	movs	r6, #1
		return xReturn;
     c50:	e7e7      	b.n	c22 <prvNotifyQueueSetContainer+0x26>
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
     c52:	3501      	adds	r5, #1
     c54:	b26d      	sxtb	r5, r5
     c56:	2345      	movs	r3, #69	; 0x45
     c58:	54e5      	strb	r5, [r4, r3]
     c5a:	e7e2      	b.n	c22 <prvNotifyQueueSetContainer+0x26>
     c5c:	00000b71 	.word	0x00000b71
     c60:	00001965 	.word	0x00001965

00000c64 <prvCopyDataFromQueue>:
{
     c64:	b510      	push	{r4, lr}
     c66:	000c      	movs	r4, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     c68:	6c02      	ldr	r2, [r0, #64]	; 0x40
     c6a:	2a00      	cmp	r2, #0
     c6c:	d00b      	beq.n	c86 <prvCopyDataFromQueue+0x22>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
     c6e:	68c3      	ldr	r3, [r0, #12]
     c70:	189b      	adds	r3, r3, r2
     c72:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     c74:	6881      	ldr	r1, [r0, #8]
     c76:	428b      	cmp	r3, r1
     c78:	d301      	bcc.n	c7e <prvCopyDataFromQueue+0x1a>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
     c7a:	6803      	ldr	r3, [r0, #0]
     c7c:	60c3      	str	r3, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
     c7e:	68c1      	ldr	r1, [r0, #12]
     c80:	0020      	movs	r0, r4
     c82:	4b01      	ldr	r3, [pc, #4]	; (c88 <prvCopyDataFromQueue+0x24>)
     c84:	4798      	blx	r3
}
     c86:	bd10      	pop	{r4, pc}
     c88:	00003a85 	.word	0x00003a85

00000c8c <prvUnlockQueue>:
{
     c8c:	b570      	push	{r4, r5, r6, lr}
     c8e:	0005      	movs	r5, r0
	taskENTER_CRITICAL();
     c90:	4b21      	ldr	r3, [pc, #132]	; (d18 <prvUnlockQueue+0x8c>)
     c92:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
     c94:	2345      	movs	r3, #69	; 0x45
     c96:	5cec      	ldrb	r4, [r5, r3]
     c98:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     c9a:	e00a      	b.n	cb2 <prvUnlockQueue+0x26>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c9c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
     c9e:	2b00      	cmp	r3, #0
     ca0:	d018      	beq.n	cd4 <prvUnlockQueue+0x48>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ca2:	0028      	movs	r0, r5
     ca4:	3024      	adds	r0, #36	; 0x24
     ca6:	4b1d      	ldr	r3, [pc, #116]	; (d1c <prvUnlockQueue+0x90>)
     ca8:	4798      	blx	r3
     caa:	2800      	cmp	r0, #0
     cac:	d10f      	bne.n	cce <prvUnlockQueue+0x42>
			--cTxLock;
     cae:	3c01      	subs	r4, #1
     cb0:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
     cb2:	2c00      	cmp	r4, #0
     cb4:	dd0e      	ble.n	cd4 <prvUnlockQueue+0x48>
				if( pxQueue->pxQueueSetContainer != NULL )
     cb6:	6cab      	ldr	r3, [r5, #72]	; 0x48
     cb8:	2b00      	cmp	r3, #0
     cba:	d0ef      	beq.n	c9c <prvUnlockQueue+0x10>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
     cbc:	2100      	movs	r1, #0
     cbe:	0028      	movs	r0, r5
     cc0:	4b17      	ldr	r3, [pc, #92]	; (d20 <prvUnlockQueue+0x94>)
     cc2:	4798      	blx	r3
     cc4:	2800      	cmp	r0, #0
     cc6:	d0f2      	beq.n	cae <prvUnlockQueue+0x22>
						vTaskMissedYield();
     cc8:	4b16      	ldr	r3, [pc, #88]	; (d24 <prvUnlockQueue+0x98>)
     cca:	4798      	blx	r3
     ccc:	e7ef      	b.n	cae <prvUnlockQueue+0x22>
							vTaskMissedYield();
     cce:	4b15      	ldr	r3, [pc, #84]	; (d24 <prvUnlockQueue+0x98>)
     cd0:	4798      	blx	r3
     cd2:	e7ec      	b.n	cae <prvUnlockQueue+0x22>
		pxQueue->cTxLock = queueUNLOCKED;
     cd4:	22ff      	movs	r2, #255	; 0xff
     cd6:	2345      	movs	r3, #69	; 0x45
     cd8:	54ea      	strb	r2, [r5, r3]
	taskEXIT_CRITICAL();
     cda:	4b13      	ldr	r3, [pc, #76]	; (d28 <prvUnlockQueue+0x9c>)
     cdc:	4798      	blx	r3
	taskENTER_CRITICAL();
     cde:	4b0e      	ldr	r3, [pc, #56]	; (d18 <prvUnlockQueue+0x8c>)
     ce0:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
     ce2:	2344      	movs	r3, #68	; 0x44
     ce4:	5cec      	ldrb	r4, [r5, r3]
     ce6:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     ce8:	e001      	b.n	cee <prvUnlockQueue+0x62>
				--cRxLock;
     cea:	3c01      	subs	r4, #1
     cec:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
     cee:	2c00      	cmp	r4, #0
     cf0:	dd0b      	ble.n	d0a <prvUnlockQueue+0x7e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cf2:	692b      	ldr	r3, [r5, #16]
     cf4:	2b00      	cmp	r3, #0
     cf6:	d008      	beq.n	d0a <prvUnlockQueue+0x7e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     cf8:	0028      	movs	r0, r5
     cfa:	3010      	adds	r0, #16
     cfc:	4b07      	ldr	r3, [pc, #28]	; (d1c <prvUnlockQueue+0x90>)
     cfe:	4798      	blx	r3
     d00:	2800      	cmp	r0, #0
     d02:	d0f2      	beq.n	cea <prvUnlockQueue+0x5e>
					vTaskMissedYield();
     d04:	4b07      	ldr	r3, [pc, #28]	; (d24 <prvUnlockQueue+0x98>)
     d06:	4798      	blx	r3
     d08:	e7ef      	b.n	cea <prvUnlockQueue+0x5e>
		pxQueue->cRxLock = queueUNLOCKED;
     d0a:	22ff      	movs	r2, #255	; 0xff
     d0c:	2344      	movs	r3, #68	; 0x44
     d0e:	54ea      	strb	r2, [r5, r3]
	taskEXIT_CRITICAL();
     d10:	4b05      	ldr	r3, [pc, #20]	; (d28 <prvUnlockQueue+0x9c>)
     d12:	4798      	blx	r3
}
     d14:	bd70      	pop	{r4, r5, r6, pc}
     d16:	46c0      	nop			; (mov r8, r8)
     d18:	00000a61 	.word	0x00000a61
     d1c:	00001965 	.word	0x00001965
     d20:	00000bfd 	.word	0x00000bfd
     d24:	00001a69 	.word	0x00001a69
     d28:	00000a79 	.word	0x00000a79

00000d2c <xQueueGenericReset>:
{
     d2c:	b570      	push	{r4, r5, r6, lr}
     d2e:	0004      	movs	r4, r0
     d30:	000d      	movs	r5, r1
	configASSERT( pxQueue );
     d32:	2800      	cmp	r0, #0
     d34:	d023      	beq.n	d7e <xQueueGenericReset+0x52>
	taskENTER_CRITICAL();
     d36:	4b18      	ldr	r3, [pc, #96]	; (d98 <xQueueGenericReset+0x6c>)
     d38:	4798      	blx	r3
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
     d3a:	6822      	ldr	r2, [r4, #0]
     d3c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     d3e:	6c20      	ldr	r0, [r4, #64]	; 0x40
     d40:	0001      	movs	r1, r0
     d42:	4359      	muls	r1, r3
     d44:	1851      	adds	r1, r2, r1
     d46:	60a1      	str	r1, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     d48:	2100      	movs	r1, #0
     d4a:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
     d4c:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
     d4e:	3b01      	subs	r3, #1
     d50:	4343      	muls	r3, r0
     d52:	18d3      	adds	r3, r2, r3
     d54:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
     d56:	23ff      	movs	r3, #255	; 0xff
     d58:	2244      	movs	r2, #68	; 0x44
     d5a:	54a3      	strb	r3, [r4, r2]
		pxQueue->cTxLock = queueUNLOCKED;
     d5c:	3201      	adds	r2, #1
     d5e:	54a3      	strb	r3, [r4, r2]
		if( xNewQueue == pdFALSE )
     d60:	2d00      	cmp	r5, #0
     d62:	d111      	bne.n	d88 <xQueueGenericReset+0x5c>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     d64:	6923      	ldr	r3, [r4, #16]
     d66:	2b00      	cmp	r3, #0
     d68:	d005      	beq.n	d76 <xQueueGenericReset+0x4a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     d6a:	0020      	movs	r0, r4
     d6c:	3010      	adds	r0, #16
     d6e:	4b0b      	ldr	r3, [pc, #44]	; (d9c <xQueueGenericReset+0x70>)
     d70:	4798      	blx	r3
     d72:	2800      	cmp	r0, #0
     d74:	d105      	bne.n	d82 <xQueueGenericReset+0x56>
	taskEXIT_CRITICAL();
     d76:	4b0a      	ldr	r3, [pc, #40]	; (da0 <xQueueGenericReset+0x74>)
     d78:	4798      	blx	r3
}
     d7a:	2001      	movs	r0, #1
     d7c:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
     d7e:	b672      	cpsid	i
     d80:	e7fe      	b.n	d80 <xQueueGenericReset+0x54>
					queueYIELD_IF_USING_PREEMPTION();
     d82:	4b08      	ldr	r3, [pc, #32]	; (da4 <xQueueGenericReset+0x78>)
     d84:	4798      	blx	r3
     d86:	e7f6      	b.n	d76 <xQueueGenericReset+0x4a>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     d88:	0020      	movs	r0, r4
     d8a:	3010      	adds	r0, #16
     d8c:	4d06      	ldr	r5, [pc, #24]	; (da8 <xQueueGenericReset+0x7c>)
     d8e:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     d90:	0020      	movs	r0, r4
     d92:	3024      	adds	r0, #36	; 0x24
     d94:	47a8      	blx	r5
     d96:	e7ee      	b.n	d76 <xQueueGenericReset+0x4a>
     d98:	00000a61 	.word	0x00000a61
     d9c:	00001965 	.word	0x00001965
     da0:	00000a79 	.word	0x00000a79
     da4:	00000a49 	.word	0x00000a49
     da8:	000006f9 	.word	0x000006f9

00000dac <prvInitialiseNewQueue>:
{
     dac:	b570      	push	{r4, r5, r6, lr}
     dae:	001d      	movs	r5, r3
     db0:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
     db2:	2900      	cmp	r1, #0
     db4:	d00b      	beq.n	dce <prvInitialiseNewQueue+0x22>
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     db6:	6022      	str	r2, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
     db8:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
     dba:	6421      	str	r1, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     dbc:	2101      	movs	r1, #1
     dbe:	0020      	movs	r0, r4
     dc0:	4b04      	ldr	r3, [pc, #16]	; (dd4 <prvInitialiseNewQueue+0x28>)
     dc2:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
     dc4:	2350      	movs	r3, #80	; 0x50
     dc6:	54e5      	strb	r5, [r4, r3]
		pxNewQueue->pxQueueSetContainer = NULL;
     dc8:	2300      	movs	r3, #0
     dca:	64a3      	str	r3, [r4, #72]	; 0x48
}
     dcc:	bd70      	pop	{r4, r5, r6, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     dce:	6024      	str	r4, [r4, #0]
     dd0:	e7f2      	b.n	db8 <prvInitialiseNewQueue+0xc>
     dd2:	46c0      	nop			; (mov r8, r8)
     dd4:	00000d2d 	.word	0x00000d2d

00000dd8 <xQueueGenericCreate>:
	{
     dd8:	b5f0      	push	{r4, r5, r6, r7, lr}
     dda:	b083      	sub	sp, #12
     ddc:	0006      	movs	r6, r0
     dde:	000f      	movs	r7, r1
     de0:	0015      	movs	r5, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
     de2:	2800      	cmp	r0, #0
     de4:	d101      	bne.n	dea <xQueueGenericCreate+0x12>
     de6:	b672      	cpsid	i
     de8:	e7fe      	b.n	de8 <xQueueGenericCreate+0x10>
		if( uxItemSize == ( UBaseType_t ) 0 )
     dea:	2900      	cmp	r1, #0
     dec:	d002      	beq.n	df4 <xQueueGenericCreate+0x1c>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     dee:	0008      	movs	r0, r1
     df0:	4370      	muls	r0, r6
     df2:	e000      	b.n	df6 <xQueueGenericCreate+0x1e>
			xQueueSizeInBytes = ( size_t ) 0;
     df4:	2000      	movs	r0, #0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
     df6:	3054      	adds	r0, #84	; 0x54
     df8:	4b07      	ldr	r3, [pc, #28]	; (e18 <xQueueGenericCreate+0x40>)
     dfa:	4798      	blx	r3
     dfc:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
     dfe:	d007      	beq.n	e10 <xQueueGenericCreate+0x38>
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
     e00:	0002      	movs	r2, r0
     e02:	3254      	adds	r2, #84	; 0x54
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
     e04:	9000      	str	r0, [sp, #0]
     e06:	002b      	movs	r3, r5
     e08:	0039      	movs	r1, r7
     e0a:	0030      	movs	r0, r6
     e0c:	4d03      	ldr	r5, [pc, #12]	; (e1c <xQueueGenericCreate+0x44>)
     e0e:	47a8      	blx	r5
	}
     e10:	0020      	movs	r0, r4
     e12:	b003      	add	sp, #12
     e14:	bdf0      	pop	{r4, r5, r6, r7, pc}
     e16:	46c0      	nop			; (mov r8, r8)
     e18:	00000825 	.word	0x00000825
     e1c:	00000dad 	.word	0x00000dad

00000e20 <xQueueGenericSend>:
{
     e20:	b5f0      	push	{r4, r5, r6, r7, lr}
     e22:	b085      	sub	sp, #20
     e24:	0004      	movs	r4, r0
     e26:	000f      	movs	r7, r1
     e28:	9201      	str	r2, [sp, #4]
     e2a:	001e      	movs	r6, r3
	configASSERT( pxQueue );
     e2c:	2800      	cmp	r0, #0
     e2e:	d006      	beq.n	e3e <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     e30:	2900      	cmp	r1, #0
     e32:	d006      	beq.n	e42 <xQueueGenericSend+0x22>
     e34:	2501      	movs	r5, #1
     e36:	2d00      	cmp	r5, #0
     e38:	d10a      	bne.n	e50 <xQueueGenericSend+0x30>
     e3a:	b672      	cpsid	i
     e3c:	e7fe      	b.n	e3c <xQueueGenericSend+0x1c>
	configASSERT( pxQueue );
     e3e:	b672      	cpsid	i
     e40:	e7fe      	b.n	e40 <xQueueGenericSend+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     e42:	6c03      	ldr	r3, [r0, #64]	; 0x40
     e44:	2b00      	cmp	r3, #0
     e46:	d101      	bne.n	e4c <xQueueGenericSend+0x2c>
     e48:	2501      	movs	r5, #1
     e4a:	e7f4      	b.n	e36 <xQueueGenericSend+0x16>
     e4c:	2500      	movs	r5, #0
     e4e:	e7f2      	b.n	e36 <xQueueGenericSend+0x16>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     e50:	2e02      	cmp	r6, #2
     e52:	d003      	beq.n	e5c <xQueueGenericSend+0x3c>
     e54:	2d00      	cmp	r5, #0
     e56:	d106      	bne.n	e66 <xQueueGenericSend+0x46>
     e58:	b672      	cpsid	i
     e5a:	e7fe      	b.n	e5a <xQueueGenericSend+0x3a>
     e5c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
     e5e:	2b01      	cmp	r3, #1
     e60:	d0f8      	beq.n	e54 <xQueueGenericSend+0x34>
     e62:	2500      	movs	r5, #0
     e64:	e7f6      	b.n	e54 <xQueueGenericSend+0x34>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
     e66:	4b47      	ldr	r3, [pc, #284]	; (f84 <xQueueGenericSend+0x164>)
     e68:	4798      	blx	r3
     e6a:	2800      	cmp	r0, #0
     e6c:	d103      	bne.n	e76 <xQueueGenericSend+0x56>
     e6e:	9b01      	ldr	r3, [sp, #4]
     e70:	2b00      	cmp	r3, #0
     e72:	d000      	beq.n	e76 <xQueueGenericSend+0x56>
     e74:	2500      	movs	r5, #0
     e76:	2d00      	cmp	r5, #0
     e78:	d101      	bne.n	e7e <xQueueGenericSend+0x5e>
     e7a:	b672      	cpsid	i
     e7c:	e7fe      	b.n	e7c <xQueueGenericSend+0x5c>
     e7e:	2500      	movs	r5, #0
     e80:	e047      	b.n	f12 <xQueueGenericSend+0xf2>
				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
     e82:	6ba5      	ldr	r5, [r4, #56]	; 0x38
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     e84:	0032      	movs	r2, r6
     e86:	0039      	movs	r1, r7
     e88:	0020      	movs	r0, r4
     e8a:	4b3f      	ldr	r3, [pc, #252]	; (f88 <xQueueGenericSend+0x168>)
     e8c:	4798      	blx	r3
					if( pxQueue->pxQueueSetContainer != NULL )
     e8e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
     e90:	2b00      	cmp	r3, #0
     e92:	d010      	beq.n	eb6 <xQueueGenericSend+0x96>
						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
     e94:	2e02      	cmp	r6, #2
     e96:	d101      	bne.n	e9c <xQueueGenericSend+0x7c>
     e98:	2d00      	cmp	r5, #0
     e9a:	d107      	bne.n	eac <xQueueGenericSend+0x8c>
						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
     e9c:	0031      	movs	r1, r6
     e9e:	0020      	movs	r0, r4
     ea0:	4b3a      	ldr	r3, [pc, #232]	; (f8c <xQueueGenericSend+0x16c>)
     ea2:	4798      	blx	r3
     ea4:	2800      	cmp	r0, #0
     ea6:	d001      	beq.n	eac <xQueueGenericSend+0x8c>
							queueYIELD_IF_USING_PREEMPTION();
     ea8:	4b39      	ldr	r3, [pc, #228]	; (f90 <xQueueGenericSend+0x170>)
     eaa:	4798      	blx	r3
				taskEXIT_CRITICAL();
     eac:	4b39      	ldr	r3, [pc, #228]	; (f94 <xQueueGenericSend+0x174>)
     eae:	4798      	blx	r3
				return pdPASS;
     eb0:	2001      	movs	r0, #1
}
     eb2:	b005      	add	sp, #20
     eb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     eb6:	6a63      	ldr	r3, [r4, #36]	; 0x24
     eb8:	2b00      	cmp	r3, #0
     eba:	d008      	beq.n	ece <xQueueGenericSend+0xae>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ebc:	0020      	movs	r0, r4
     ebe:	3024      	adds	r0, #36	; 0x24
     ec0:	4b35      	ldr	r3, [pc, #212]	; (f98 <xQueueGenericSend+0x178>)
     ec2:	4798      	blx	r3
     ec4:	2800      	cmp	r0, #0
     ec6:	d0f1      	beq.n	eac <xQueueGenericSend+0x8c>
								queueYIELD_IF_USING_PREEMPTION();
     ec8:	4b31      	ldr	r3, [pc, #196]	; (f90 <xQueueGenericSend+0x170>)
     eca:	4798      	blx	r3
     ecc:	e7ee      	b.n	eac <xQueueGenericSend+0x8c>
						else if( xYieldRequired != pdFALSE )
     ece:	2800      	cmp	r0, #0
     ed0:	d0ec      	beq.n	eac <xQueueGenericSend+0x8c>
							queueYIELD_IF_USING_PREEMPTION();
     ed2:	4b2f      	ldr	r3, [pc, #188]	; (f90 <xQueueGenericSend+0x170>)
     ed4:	4798      	blx	r3
     ed6:	e7e9      	b.n	eac <xQueueGenericSend+0x8c>
					taskEXIT_CRITICAL();
     ed8:	4b2e      	ldr	r3, [pc, #184]	; (f94 <xQueueGenericSend+0x174>)
     eda:	4798      	blx	r3
					return errQUEUE_FULL;
     edc:	2000      	movs	r0, #0
     ede:	e7e8      	b.n	eb2 <xQueueGenericSend+0x92>
		prvLockQueue( pxQueue );
     ee0:	4b2c      	ldr	r3, [pc, #176]	; (f94 <xQueueGenericSend+0x174>)
     ee2:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ee4:	a901      	add	r1, sp, #4
     ee6:	a802      	add	r0, sp, #8
     ee8:	4b2c      	ldr	r3, [pc, #176]	; (f9c <xQueueGenericSend+0x17c>)
     eea:	4798      	blx	r3
     eec:	2800      	cmp	r0, #0
     eee:	d141      	bne.n	f74 <xQueueGenericSend+0x154>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     ef0:	0020      	movs	r0, r4
     ef2:	4b2b      	ldr	r3, [pc, #172]	; (fa0 <xQueueGenericSend+0x180>)
     ef4:	4798      	blx	r3
     ef6:	2800      	cmp	r0, #0
     ef8:	d036      	beq.n	f68 <xQueueGenericSend+0x148>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     efa:	0020      	movs	r0, r4
     efc:	3010      	adds	r0, #16
     efe:	9901      	ldr	r1, [sp, #4]
     f00:	4b28      	ldr	r3, [pc, #160]	; (fa4 <xQueueGenericSend+0x184>)
     f02:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
     f04:	0020      	movs	r0, r4
     f06:	4b28      	ldr	r3, [pc, #160]	; (fa8 <xQueueGenericSend+0x188>)
     f08:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
     f0a:	4b28      	ldr	r3, [pc, #160]	; (fac <xQueueGenericSend+0x18c>)
     f0c:	4798      	blx	r3
     f0e:	2800      	cmp	r0, #0
     f10:	d027      	beq.n	f62 <xQueueGenericSend+0x142>
		taskENTER_CRITICAL();
     f12:	4b27      	ldr	r3, [pc, #156]	; (fb0 <xQueueGenericSend+0x190>)
     f14:	4798      	blx	r3
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     f16:	6ba3      	ldr	r3, [r4, #56]	; 0x38
     f18:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     f1a:	4293      	cmp	r3, r2
     f1c:	d3b1      	bcc.n	e82 <xQueueGenericSend+0x62>
     f1e:	2e02      	cmp	r6, #2
     f20:	d0af      	beq.n	e82 <xQueueGenericSend+0x62>
				if( xTicksToWait == ( TickType_t ) 0 )
     f22:	9b01      	ldr	r3, [sp, #4]
     f24:	2b00      	cmp	r3, #0
     f26:	d0d7      	beq.n	ed8 <xQueueGenericSend+0xb8>
				else if( xEntryTimeSet == pdFALSE )
     f28:	2d00      	cmp	r5, #0
     f2a:	d103      	bne.n	f34 <xQueueGenericSend+0x114>
					vTaskInternalSetTimeOutState( &xTimeOut );
     f2c:	a802      	add	r0, sp, #8
     f2e:	4b21      	ldr	r3, [pc, #132]	; (fb4 <xQueueGenericSend+0x194>)
     f30:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
     f32:	3501      	adds	r5, #1
		taskEXIT_CRITICAL();
     f34:	4b17      	ldr	r3, [pc, #92]	; (f94 <xQueueGenericSend+0x174>)
     f36:	4798      	blx	r3
		vTaskSuspendAll();
     f38:	4b1f      	ldr	r3, [pc, #124]	; (fb8 <xQueueGenericSend+0x198>)
     f3a:	4798      	blx	r3
		prvLockQueue( pxQueue );
     f3c:	4b1c      	ldr	r3, [pc, #112]	; (fb0 <xQueueGenericSend+0x190>)
     f3e:	4798      	blx	r3
     f40:	2344      	movs	r3, #68	; 0x44
     f42:	5ce3      	ldrb	r3, [r4, r3]
     f44:	b25b      	sxtb	r3, r3
     f46:	3301      	adds	r3, #1
     f48:	d102      	bne.n	f50 <xQueueGenericSend+0x130>
     f4a:	2200      	movs	r2, #0
     f4c:	2344      	movs	r3, #68	; 0x44
     f4e:	54e2      	strb	r2, [r4, r3]
     f50:	2345      	movs	r3, #69	; 0x45
     f52:	5ce3      	ldrb	r3, [r4, r3]
     f54:	b25b      	sxtb	r3, r3
     f56:	3301      	adds	r3, #1
     f58:	d1c2      	bne.n	ee0 <xQueueGenericSend+0xc0>
     f5a:	2200      	movs	r2, #0
     f5c:	2345      	movs	r3, #69	; 0x45
     f5e:	54e2      	strb	r2, [r4, r3]
     f60:	e7be      	b.n	ee0 <xQueueGenericSend+0xc0>
					portYIELD_WITHIN_API();
     f62:	4b0b      	ldr	r3, [pc, #44]	; (f90 <xQueueGenericSend+0x170>)
     f64:	4798      	blx	r3
     f66:	e7d4      	b.n	f12 <xQueueGenericSend+0xf2>
				prvUnlockQueue( pxQueue );
     f68:	0020      	movs	r0, r4
     f6a:	4b0f      	ldr	r3, [pc, #60]	; (fa8 <xQueueGenericSend+0x188>)
     f6c:	4798      	blx	r3
				( void ) xTaskResumeAll();
     f6e:	4b0f      	ldr	r3, [pc, #60]	; (fac <xQueueGenericSend+0x18c>)
     f70:	4798      	blx	r3
     f72:	e7ce      	b.n	f12 <xQueueGenericSend+0xf2>
			prvUnlockQueue( pxQueue );
     f74:	0020      	movs	r0, r4
     f76:	4b0c      	ldr	r3, [pc, #48]	; (fa8 <xQueueGenericSend+0x188>)
     f78:	4798      	blx	r3
			( void ) xTaskResumeAll();
     f7a:	4b0c      	ldr	r3, [pc, #48]	; (fac <xQueueGenericSend+0x18c>)
     f7c:	4798      	blx	r3
			return errQUEUE_FULL;
     f7e:	2000      	movs	r0, #0
     f80:	e797      	b.n	eb2 <xQueueGenericSend+0x92>
     f82:	46c0      	nop			; (mov r8, r8)
     f84:	00001a75 	.word	0x00001a75
     f88:	00000b71 	.word	0x00000b71
     f8c:	00000bfd 	.word	0x00000bfd
     f90:	00000a49 	.word	0x00000a49
     f94:	00000a79 	.word	0x00000a79
     f98:	00001965 	.word	0x00001965
     f9c:	000019f9 	.word	0x000019f9
     fa0:	00000b25 	.word	0x00000b25
     fa4:	00001901 	.word	0x00001901
     fa8:	00000c8d 	.word	0x00000c8d
     fac:	00001745 	.word	0x00001745
     fb0:	00000a61 	.word	0x00000a61
     fb4:	000019e9 	.word	0x000019e9
     fb8:	00001629 	.word	0x00001629

00000fbc <xQueueGenericSendFromISR>:
{
     fbc:	b5f0      	push	{r4, r5, r6, r7, lr}
     fbe:	b083      	sub	sp, #12
     fc0:	0004      	movs	r4, r0
     fc2:	9100      	str	r1, [sp, #0]
     fc4:	0017      	movs	r7, r2
     fc6:	001d      	movs	r5, r3
	configASSERT( pxQueue );
     fc8:	2800      	cmp	r0, #0
     fca:	d007      	beq.n	fdc <xQueueGenericSendFromISR+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     fcc:	9b00      	ldr	r3, [sp, #0]
     fce:	2b00      	cmp	r3, #0
     fd0:	d006      	beq.n	fe0 <xQueueGenericSendFromISR+0x24>
     fd2:	2301      	movs	r3, #1
     fd4:	2b00      	cmp	r3, #0
     fd6:	d10a      	bne.n	fee <xQueueGenericSendFromISR+0x32>
     fd8:	b672      	cpsid	i
     fda:	e7fe      	b.n	fda <xQueueGenericSendFromISR+0x1e>
	configASSERT( pxQueue );
     fdc:	b672      	cpsid	i
     fde:	e7fe      	b.n	fde <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
     fe0:	6c03      	ldr	r3, [r0, #64]	; 0x40
     fe2:	2b00      	cmp	r3, #0
     fe4:	d101      	bne.n	fea <xQueueGenericSendFromISR+0x2e>
     fe6:	3301      	adds	r3, #1
     fe8:	e7f4      	b.n	fd4 <xQueueGenericSendFromISR+0x18>
     fea:	2300      	movs	r3, #0
     fec:	e7f2      	b.n	fd4 <xQueueGenericSendFromISR+0x18>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
     fee:	2d02      	cmp	r5, #2
     ff0:	d003      	beq.n	ffa <xQueueGenericSendFromISR+0x3e>
     ff2:	2b00      	cmp	r3, #0
     ff4:	d106      	bne.n	1004 <xQueueGenericSendFromISR+0x48>
     ff6:	b672      	cpsid	i
     ff8:	e7fe      	b.n	ff8 <xQueueGenericSendFromISR+0x3c>
     ffa:	6be2      	ldr	r2, [r4, #60]	; 0x3c
     ffc:	2a01      	cmp	r2, #1
     ffe:	d0f8      	beq.n	ff2 <xQueueGenericSendFromISR+0x36>
    1000:	2300      	movs	r3, #0
    1002:	e7f6      	b.n	ff2 <xQueueGenericSendFromISR+0x36>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1004:	4b23      	ldr	r3, [pc, #140]	; (1094 <xQueueGenericSendFromISR+0xd8>)
    1006:	4798      	blx	r3
    1008:	9001      	str	r0, [sp, #4]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    100a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    100c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    100e:	4293      	cmp	r3, r2
    1010:	d301      	bcc.n	1016 <xQueueGenericSendFromISR+0x5a>
    1012:	2d02      	cmp	r5, #2
    1014:	d132      	bne.n	107c <xQueueGenericSendFromISR+0xc0>
			const int8_t cTxLock = pxQueue->cTxLock;
    1016:	2345      	movs	r3, #69	; 0x45
    1018:	5ce6      	ldrb	r6, [r4, r3]
    101a:	b276      	sxtb	r6, r6
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    101c:	002a      	movs	r2, r5
    101e:	9900      	ldr	r1, [sp, #0]
    1020:	0020      	movs	r0, r4
    1022:	4b1d      	ldr	r3, [pc, #116]	; (1098 <xQueueGenericSendFromISR+0xdc>)
    1024:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
    1026:	1c73      	adds	r3, r6, #1
    1028:	d122      	bne.n	1070 <xQueueGenericSendFromISR+0xb4>
					if( pxQueue->pxQueueSetContainer != NULL )
    102a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    102c:	2b00      	cmp	r3, #0
    102e:	d010      	beq.n	1052 <xQueueGenericSendFromISR+0x96>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
    1030:	0029      	movs	r1, r5
    1032:	0020      	movs	r0, r4
    1034:	4b19      	ldr	r3, [pc, #100]	; (109c <xQueueGenericSendFromISR+0xe0>)
    1036:	4798      	blx	r3
    1038:	2800      	cmp	r0, #0
    103a:	d021      	beq.n	1080 <xQueueGenericSendFromISR+0xc4>
							if( pxHigherPriorityTaskWoken != NULL )
    103c:	2f00      	cmp	r7, #0
    103e:	d021      	beq.n	1084 <xQueueGenericSendFromISR+0xc8>
								*pxHigherPriorityTaskWoken = pdTRUE;
    1040:	2301      	movs	r3, #1
    1042:	603b      	str	r3, [r7, #0]
			xReturn = pdPASS;
    1044:	2401      	movs	r4, #1
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    1046:	9801      	ldr	r0, [sp, #4]
    1048:	4b15      	ldr	r3, [pc, #84]	; (10a0 <xQueueGenericSendFromISR+0xe4>)
    104a:	4798      	blx	r3
}
    104c:	0020      	movs	r0, r4
    104e:	b003      	add	sp, #12
    1050:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1052:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1054:	2b00      	cmp	r3, #0
    1056:	d017      	beq.n	1088 <xQueueGenericSendFromISR+0xcc>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1058:	0020      	movs	r0, r4
    105a:	3024      	adds	r0, #36	; 0x24
    105c:	4b11      	ldr	r3, [pc, #68]	; (10a4 <xQueueGenericSendFromISR+0xe8>)
    105e:	4798      	blx	r3
    1060:	2800      	cmp	r0, #0
    1062:	d013      	beq.n	108c <xQueueGenericSendFromISR+0xd0>
								if( pxHigherPriorityTaskWoken != NULL )
    1064:	2f00      	cmp	r7, #0
    1066:	d013      	beq.n	1090 <xQueueGenericSendFromISR+0xd4>
									*pxHigherPriorityTaskWoken = pdTRUE;
    1068:	2301      	movs	r3, #1
    106a:	603b      	str	r3, [r7, #0]
			xReturn = pdPASS;
    106c:	2401      	movs	r4, #1
    106e:	e7ea      	b.n	1046 <xQueueGenericSendFromISR+0x8a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1070:	1c73      	adds	r3, r6, #1
    1072:	b25b      	sxtb	r3, r3
    1074:	2245      	movs	r2, #69	; 0x45
    1076:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
    1078:	2401      	movs	r4, #1
    107a:	e7e4      	b.n	1046 <xQueueGenericSendFromISR+0x8a>
			xReturn = errQUEUE_FULL;
    107c:	2400      	movs	r4, #0
    107e:	e7e2      	b.n	1046 <xQueueGenericSendFromISR+0x8a>
			xReturn = pdPASS;
    1080:	2401      	movs	r4, #1
    1082:	e7e0      	b.n	1046 <xQueueGenericSendFromISR+0x8a>
    1084:	2401      	movs	r4, #1
    1086:	e7de      	b.n	1046 <xQueueGenericSendFromISR+0x8a>
    1088:	2401      	movs	r4, #1
    108a:	e7dc      	b.n	1046 <xQueueGenericSendFromISR+0x8a>
    108c:	2401      	movs	r4, #1
    108e:	e7da      	b.n	1046 <xQueueGenericSendFromISR+0x8a>
    1090:	2401      	movs	r4, #1
    1092:	e7d8      	b.n	1046 <xQueueGenericSendFromISR+0x8a>
    1094:	00000a99 	.word	0x00000a99
    1098:	00000b71 	.word	0x00000b71
    109c:	00000bfd 	.word	0x00000bfd
    10a0:	00000aa1 	.word	0x00000aa1
    10a4:	00001965 	.word	0x00001965

000010a8 <xQueueReceive>:
{
    10a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    10aa:	b085      	sub	sp, #20
    10ac:	0004      	movs	r4, r0
    10ae:	000e      	movs	r6, r1
    10b0:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
    10b2:	2800      	cmp	r0, #0
    10b4:	d006      	beq.n	10c4 <xQueueReceive+0x1c>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    10b6:	2900      	cmp	r1, #0
    10b8:	d006      	beq.n	10c8 <xQueueReceive+0x20>
    10ba:	2501      	movs	r5, #1
    10bc:	2d00      	cmp	r5, #0
    10be:	d10a      	bne.n	10d6 <xQueueReceive+0x2e>
    10c0:	b672      	cpsid	i
    10c2:	e7fe      	b.n	10c2 <xQueueReceive+0x1a>
	configASSERT( ( pxQueue ) );
    10c4:	b672      	cpsid	i
    10c6:	e7fe      	b.n	10c6 <xQueueReceive+0x1e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
    10c8:	6c03      	ldr	r3, [r0, #64]	; 0x40
    10ca:	2b00      	cmp	r3, #0
    10cc:	d101      	bne.n	10d2 <xQueueReceive+0x2a>
    10ce:	2501      	movs	r5, #1
    10d0:	e7f4      	b.n	10bc <xQueueReceive+0x14>
    10d2:	2500      	movs	r5, #0
    10d4:	e7f2      	b.n	10bc <xQueueReceive+0x14>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    10d6:	4b3e      	ldr	r3, [pc, #248]	; (11d0 <xQueueReceive+0x128>)
    10d8:	4798      	blx	r3
    10da:	2800      	cmp	r0, #0
    10dc:	d103      	bne.n	10e6 <xQueueReceive+0x3e>
    10de:	9b01      	ldr	r3, [sp, #4]
    10e0:	2b00      	cmp	r3, #0
    10e2:	d000      	beq.n	10e6 <xQueueReceive+0x3e>
    10e4:	2500      	movs	r5, #0
    10e6:	2d00      	cmp	r5, #0
    10e8:	d101      	bne.n	10ee <xQueueReceive+0x46>
    10ea:	b672      	cpsid	i
    10ec:	e7fe      	b.n	10ec <xQueueReceive+0x44>
    10ee:	2700      	movs	r7, #0
    10f0:	e02b      	b.n	114a <xQueueReceive+0xa2>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    10f2:	0031      	movs	r1, r6
    10f4:	0020      	movs	r0, r4
    10f6:	4b37      	ldr	r3, [pc, #220]	; (11d4 <xQueueReceive+0x12c>)
    10f8:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    10fa:	3d01      	subs	r5, #1
    10fc:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10fe:	6923      	ldr	r3, [r4, #16]
    1100:	2b00      	cmp	r3, #0
    1102:	d007      	beq.n	1114 <xQueueReceive+0x6c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1104:	0020      	movs	r0, r4
    1106:	3010      	adds	r0, #16
    1108:	4b33      	ldr	r3, [pc, #204]	; (11d8 <xQueueReceive+0x130>)
    110a:	4798      	blx	r3
    110c:	2800      	cmp	r0, #0
    110e:	d001      	beq.n	1114 <xQueueReceive+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
    1110:	4b32      	ldr	r3, [pc, #200]	; (11dc <xQueueReceive+0x134>)
    1112:	4798      	blx	r3
				taskEXIT_CRITICAL();
    1114:	4b32      	ldr	r3, [pc, #200]	; (11e0 <xQueueReceive+0x138>)
    1116:	4798      	blx	r3
				return pdPASS;
    1118:	2001      	movs	r0, #1
}
    111a:	b005      	add	sp, #20
    111c:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
    111e:	4b30      	ldr	r3, [pc, #192]	; (11e0 <xQueueReceive+0x138>)
    1120:	4798      	blx	r3
					return errQUEUE_EMPTY;
    1122:	2000      	movs	r0, #0
    1124:	e7f9      	b.n	111a <xQueueReceive+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
    1126:	a802      	add	r0, sp, #8
    1128:	4b2e      	ldr	r3, [pc, #184]	; (11e4 <xQueueReceive+0x13c>)
    112a:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
    112c:	3701      	adds	r7, #1
    112e:	e016      	b.n	115e <xQueueReceive+0xb6>
		prvLockQueue( pxQueue );
    1130:	2200      	movs	r2, #0
    1132:	2344      	movs	r3, #68	; 0x44
    1134:	54e2      	strb	r2, [r4, r3]
    1136:	e01d      	b.n	1174 <xQueueReceive+0xcc>
    1138:	2200      	movs	r2, #0
    113a:	2345      	movs	r3, #69	; 0x45
    113c:	54e2      	strb	r2, [r4, r3]
    113e:	e01e      	b.n	117e <xQueueReceive+0xd6>
				prvUnlockQueue( pxQueue );
    1140:	0020      	movs	r0, r4
    1142:	4b29      	ldr	r3, [pc, #164]	; (11e8 <xQueueReceive+0x140>)
    1144:	4798      	blx	r3
				( void ) xTaskResumeAll();
    1146:	4b29      	ldr	r3, [pc, #164]	; (11ec <xQueueReceive+0x144>)
    1148:	4798      	blx	r3
		taskENTER_CRITICAL();
    114a:	4b29      	ldr	r3, [pc, #164]	; (11f0 <xQueueReceive+0x148>)
    114c:	4798      	blx	r3
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    114e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1150:	2d00      	cmp	r5, #0
    1152:	d1ce      	bne.n	10f2 <xQueueReceive+0x4a>
				if( xTicksToWait == ( TickType_t ) 0 )
    1154:	9b01      	ldr	r3, [sp, #4]
    1156:	2b00      	cmp	r3, #0
    1158:	d0e1      	beq.n	111e <xQueueReceive+0x76>
				else if( xEntryTimeSet == pdFALSE )
    115a:	2f00      	cmp	r7, #0
    115c:	d0e3      	beq.n	1126 <xQueueReceive+0x7e>
		taskEXIT_CRITICAL();
    115e:	4b20      	ldr	r3, [pc, #128]	; (11e0 <xQueueReceive+0x138>)
    1160:	4798      	blx	r3
		vTaskSuspendAll();
    1162:	4b24      	ldr	r3, [pc, #144]	; (11f4 <xQueueReceive+0x14c>)
    1164:	4798      	blx	r3
		prvLockQueue( pxQueue );
    1166:	4b22      	ldr	r3, [pc, #136]	; (11f0 <xQueueReceive+0x148>)
    1168:	4798      	blx	r3
    116a:	2344      	movs	r3, #68	; 0x44
    116c:	5ce3      	ldrb	r3, [r4, r3]
    116e:	b25b      	sxtb	r3, r3
    1170:	3301      	adds	r3, #1
    1172:	d0dd      	beq.n	1130 <xQueueReceive+0x88>
    1174:	2345      	movs	r3, #69	; 0x45
    1176:	5ce3      	ldrb	r3, [r4, r3]
    1178:	b25b      	sxtb	r3, r3
    117a:	3301      	adds	r3, #1
    117c:	d0dc      	beq.n	1138 <xQueueReceive+0x90>
    117e:	4b18      	ldr	r3, [pc, #96]	; (11e0 <xQueueReceive+0x138>)
    1180:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1182:	a901      	add	r1, sp, #4
    1184:	a802      	add	r0, sp, #8
    1186:	4b1c      	ldr	r3, [pc, #112]	; (11f8 <xQueueReceive+0x150>)
    1188:	4798      	blx	r3
    118a:	2800      	cmp	r0, #0
    118c:	d113      	bne.n	11b6 <xQueueReceive+0x10e>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    118e:	0020      	movs	r0, r4
    1190:	4b1a      	ldr	r3, [pc, #104]	; (11fc <xQueueReceive+0x154>)
    1192:	4798      	blx	r3
    1194:	2800      	cmp	r0, #0
    1196:	d0d3      	beq.n	1140 <xQueueReceive+0x98>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1198:	0020      	movs	r0, r4
    119a:	3024      	adds	r0, #36	; 0x24
    119c:	9901      	ldr	r1, [sp, #4]
    119e:	4b18      	ldr	r3, [pc, #96]	; (1200 <xQueueReceive+0x158>)
    11a0:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
    11a2:	0020      	movs	r0, r4
    11a4:	4b10      	ldr	r3, [pc, #64]	; (11e8 <xQueueReceive+0x140>)
    11a6:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    11a8:	4b10      	ldr	r3, [pc, #64]	; (11ec <xQueueReceive+0x144>)
    11aa:	4798      	blx	r3
    11ac:	2800      	cmp	r0, #0
    11ae:	d1cc      	bne.n	114a <xQueueReceive+0xa2>
					portYIELD_WITHIN_API();
    11b0:	4b0a      	ldr	r3, [pc, #40]	; (11dc <xQueueReceive+0x134>)
    11b2:	4798      	blx	r3
    11b4:	e7c9      	b.n	114a <xQueueReceive+0xa2>
			prvUnlockQueue( pxQueue );
    11b6:	0020      	movs	r0, r4
    11b8:	4b0b      	ldr	r3, [pc, #44]	; (11e8 <xQueueReceive+0x140>)
    11ba:	4798      	blx	r3
			( void ) xTaskResumeAll();
    11bc:	4b0b      	ldr	r3, [pc, #44]	; (11ec <xQueueReceive+0x144>)
    11be:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    11c0:	0020      	movs	r0, r4
    11c2:	4b0e      	ldr	r3, [pc, #56]	; (11fc <xQueueReceive+0x154>)
    11c4:	4798      	blx	r3
    11c6:	2800      	cmp	r0, #0
    11c8:	d0bf      	beq.n	114a <xQueueReceive+0xa2>
				return errQUEUE_EMPTY;
    11ca:	2000      	movs	r0, #0
    11cc:	e7a5      	b.n	111a <xQueueReceive+0x72>
    11ce:	46c0      	nop			; (mov r8, r8)
    11d0:	00001a75 	.word	0x00001a75
    11d4:	00000c65 	.word	0x00000c65
    11d8:	00001965 	.word	0x00001965
    11dc:	00000a49 	.word	0x00000a49
    11e0:	00000a79 	.word	0x00000a79
    11e4:	000019e9 	.word	0x000019e9
    11e8:	00000c8d 	.word	0x00000c8d
    11ec:	00001745 	.word	0x00001745
    11f0:	00000a61 	.word	0x00000a61
    11f4:	00001629 	.word	0x00001629
    11f8:	000019f9 	.word	0x000019f9
    11fc:	00000b4d 	.word	0x00000b4d
    1200:	00001901 	.word	0x00001901

00001204 <vQueueAddToRegistry>:
	{
    1204:	b510      	push	{r4, lr}
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1206:	2300      	movs	r3, #0
    1208:	2b07      	cmp	r3, #7
    120a:	d80a      	bhi.n	1222 <vQueueAddToRegistry+0x1e>
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    120c:	00da      	lsls	r2, r3, #3
    120e:	4c05      	ldr	r4, [pc, #20]	; (1224 <vQueueAddToRegistry+0x20>)
    1210:	5912      	ldr	r2, [r2, r4]
    1212:	2a00      	cmp	r2, #0
    1214:	d001      	beq.n	121a <vQueueAddToRegistry+0x16>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1216:	3301      	adds	r3, #1
    1218:	e7f6      	b.n	1208 <vQueueAddToRegistry+0x4>
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    121a:	00db      	lsls	r3, r3, #3
    121c:	5119      	str	r1, [r3, r4]
				xQueueRegistry[ ux ].xHandle = xQueue;
    121e:	18e3      	adds	r3, r4, r3
    1220:	6058      	str	r0, [r3, #4]
	}
    1222:	bd10      	pop	{r4, pc}
    1224:	200030b0 	.word	0x200030b0

00001228 <vQueueWaitForMessageRestricted>:
	{
    1228:	b570      	push	{r4, r5, r6, lr}
    122a:	0004      	movs	r4, r0
    122c:	000d      	movs	r5, r1
    122e:	0016      	movs	r6, r2
		prvLockQueue( pxQueue );
    1230:	4b11      	ldr	r3, [pc, #68]	; (1278 <vQueueWaitForMessageRestricted+0x50>)
    1232:	4798      	blx	r3
    1234:	2344      	movs	r3, #68	; 0x44
    1236:	5ce3      	ldrb	r3, [r4, r3]
    1238:	b25b      	sxtb	r3, r3
    123a:	3301      	adds	r3, #1
    123c:	d00d      	beq.n	125a <vQueueWaitForMessageRestricted+0x32>
    123e:	2345      	movs	r3, #69	; 0x45
    1240:	5ce3      	ldrb	r3, [r4, r3]
    1242:	b25b      	sxtb	r3, r3
    1244:	3301      	adds	r3, #1
    1246:	d00c      	beq.n	1262 <vQueueWaitForMessageRestricted+0x3a>
    1248:	4b0c      	ldr	r3, [pc, #48]	; (127c <vQueueWaitForMessageRestricted+0x54>)
    124a:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    124c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    124e:	2b00      	cmp	r3, #0
    1250:	d00b      	beq.n	126a <vQueueWaitForMessageRestricted+0x42>
		prvUnlockQueue( pxQueue );
    1252:	0020      	movs	r0, r4
    1254:	4b0a      	ldr	r3, [pc, #40]	; (1280 <vQueueWaitForMessageRestricted+0x58>)
    1256:	4798      	blx	r3
	}
    1258:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
    125a:	2200      	movs	r2, #0
    125c:	2344      	movs	r3, #68	; 0x44
    125e:	54e2      	strb	r2, [r4, r3]
    1260:	e7ed      	b.n	123e <vQueueWaitForMessageRestricted+0x16>
    1262:	2200      	movs	r2, #0
    1264:	2345      	movs	r3, #69	; 0x45
    1266:	54e2      	strb	r2, [r4, r3]
    1268:	e7ee      	b.n	1248 <vQueueWaitForMessageRestricted+0x20>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    126a:	0020      	movs	r0, r4
    126c:	3024      	adds	r0, #36	; 0x24
    126e:	0032      	movs	r2, r6
    1270:	0029      	movs	r1, r5
    1272:	4b04      	ldr	r3, [pc, #16]	; (1284 <vQueueWaitForMessageRestricted+0x5c>)
    1274:	4798      	blx	r3
    1276:	e7ec      	b.n	1252 <vQueueWaitForMessageRestricted+0x2a>
    1278:	00000a61 	.word	0x00000a61
    127c:	00000a79 	.word	0x00000a79
    1280:	00000c8d 	.word	0x00000c8d
    1284:	0000192d 	.word	0x0000192d

00001288 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1288:	4b08      	ldr	r3, [pc, #32]	; (12ac <prvResetNextTaskUnblockTime+0x24>)
    128a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    128c:	681b      	ldr	r3, [r3, #0]
    128e:	2b00      	cmp	r3, #0
    1290:	d006      	beq.n	12a0 <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1292:	4b06      	ldr	r3, [pc, #24]	; (12ac <prvResetNextTaskUnblockTime+0x24>)
    1294:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1296:	68d2      	ldr	r2, [r2, #12]
    1298:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    129a:	6852      	ldr	r2, [r2, #4]
    129c:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    129e:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    12a0:	2201      	movs	r2, #1
    12a2:	4252      	negs	r2, r2
    12a4:	4b01      	ldr	r3, [pc, #4]	; (12ac <prvResetNextTaskUnblockTime+0x24>)
    12a6:	62da      	str	r2, [r3, #44]	; 0x2c
    12a8:	e7f9      	b.n	129e <prvResetNextTaskUnblockTime+0x16>
    12aa:	46c0      	nop			; (mov r8, r8)
    12ac:	200029b4 	.word	0x200029b4

000012b0 <prvDeleteTCB>:
	{
    12b0:	b570      	push	{r4, r5, r6, lr}
    12b2:	0005      	movs	r5, r0
			vPortFree( pxTCB->pxStack );
    12b4:	6b00      	ldr	r0, [r0, #48]	; 0x30
    12b6:	4c02      	ldr	r4, [pc, #8]	; (12c0 <prvDeleteTCB+0x10>)
    12b8:	47a0      	blx	r4
			vPortFree( pxTCB );
    12ba:	0028      	movs	r0, r5
    12bc:	47a0      	blx	r4
	}
    12be:	bd70      	pop	{r4, r5, r6, pc}
    12c0:	000008fd 	.word	0x000008fd

000012c4 <prvInitialiseNewTask>:
{
    12c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    12c6:	46c6      	mov	lr, r8
    12c8:	b500      	push	{lr}
    12ca:	b082      	sub	sp, #8
    12cc:	9000      	str	r0, [sp, #0]
    12ce:	000d      	movs	r5, r1
    12d0:	0017      	movs	r7, r2
    12d2:	9301      	str	r3, [sp, #4]
    12d4:	9c08      	ldr	r4, [sp, #32]
    12d6:	9e0a      	ldr	r6, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    12d8:	0092      	lsls	r2, r2, #2
    12da:	21a5      	movs	r1, #165	; 0xa5
    12dc:	6b30      	ldr	r0, [r6, #48]	; 0x30
    12de:	4b22      	ldr	r3, [pc, #136]	; (1368 <prvInitialiseNewTask+0xa4>)
    12e0:	4798      	blx	r3
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    12e2:	4b22      	ldr	r3, [pc, #136]	; (136c <prvInitialiseNewTask+0xa8>)
    12e4:	18fb      	adds	r3, r7, r3
    12e6:	009b      	lsls	r3, r3, #2
    12e8:	6b32      	ldr	r2, [r6, #48]	; 0x30
    12ea:	4694      	mov	ip, r2
    12ec:	4463      	add	r3, ip
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
    12ee:	2207      	movs	r2, #7
    12f0:	4393      	bics	r3, r2
    12f2:	4698      	mov	r8, r3
	if( pcName != NULL )
    12f4:	2d00      	cmp	r5, #0
    12f6:	d032      	beq.n	135e <prvInitialiseNewTask+0x9a>
    12f8:	2300      	movs	r3, #0
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    12fa:	2b04      	cmp	r3, #4
    12fc:	d809      	bhi.n	1312 <prvInitialiseNewTask+0x4e>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    12fe:	18e9      	adds	r1, r5, r3
    1300:	7808      	ldrb	r0, [r1, #0]
    1302:	18f2      	adds	r2, r6, r3
    1304:	3234      	adds	r2, #52	; 0x34
    1306:	7010      	strb	r0, [r2, #0]
			if( pcName[ x ] == ( char ) 0x00 )
    1308:	780a      	ldrb	r2, [r1, #0]
    130a:	2a00      	cmp	r2, #0
    130c:	d001      	beq.n	1312 <prvInitialiseNewTask+0x4e>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    130e:	3301      	adds	r3, #1
    1310:	e7f3      	b.n	12fa <prvInitialiseNewTask+0x36>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    1312:	2200      	movs	r2, #0
    1314:	2338      	movs	r3, #56	; 0x38
    1316:	54f2      	strb	r2, [r6, r3]
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    1318:	2c04      	cmp	r4, #4
    131a:	d900      	bls.n	131e <prvInitialiseNewTask+0x5a>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    131c:	2404      	movs	r4, #4
	pxNewTCB->uxPriority = uxPriority;
    131e:	62f4      	str	r4, [r6, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    1320:	6474      	str	r4, [r6, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
    1322:	2500      	movs	r5, #0
    1324:	64b5      	str	r5, [r6, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    1326:	1d30      	adds	r0, r6, #4
    1328:	4f11      	ldr	r7, [pc, #68]	; (1370 <prvInitialiseNewTask+0xac>)
    132a:	47b8      	blx	r7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    132c:	0030      	movs	r0, r6
    132e:	3018      	adds	r0, #24
    1330:	47b8      	blx	r7
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    1332:	6136      	str	r6, [r6, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1334:	2305      	movs	r3, #5
    1336:	1b1c      	subs	r4, r3, r4
    1338:	61b4      	str	r4, [r6, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    133a:	6276      	str	r6, [r6, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    133c:	64f5      	str	r5, [r6, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    133e:	334b      	adds	r3, #75	; 0x4b
    1340:	54f5      	strb	r5, [r6, r3]
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1342:	9a01      	ldr	r2, [sp, #4]
    1344:	9900      	ldr	r1, [sp, #0]
    1346:	4640      	mov	r0, r8
    1348:	4b0a      	ldr	r3, [pc, #40]	; (1374 <prvInitialiseNewTask+0xb0>)
    134a:	4798      	blx	r3
    134c:	6030      	str	r0, [r6, #0]
	if( pxCreatedTask != NULL )
    134e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1350:	2b00      	cmp	r3, #0
    1352:	d000      	beq.n	1356 <prvInitialiseNewTask+0x92>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1354:	601e      	str	r6, [r3, #0]
}
    1356:	b002      	add	sp, #8
    1358:	bc04      	pop	{r2}
    135a:	4690      	mov	r8, r2
    135c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    135e:	2200      	movs	r2, #0
    1360:	2334      	movs	r3, #52	; 0x34
    1362:	54f2      	strb	r2, [r6, r3]
    1364:	e7d8      	b.n	1318 <prvInitialiseNewTask+0x54>
    1366:	46c0      	nop			; (mov r8, r8)
    1368:	00003a97 	.word	0x00003a97
    136c:	3fffffff 	.word	0x3fffffff
    1370:	0000070f 	.word	0x0000070f
    1374:	000009dd 	.word	0x000009dd

00001378 <prvInitialiseTaskLists>:
{
    1378:	b5f0      	push	{r4, r5, r6, r7, lr}
    137a:	46c6      	mov	lr, r8
    137c:	b500      	push	{lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    137e:	2400      	movs	r4, #0
    1380:	e008      	b.n	1394 <prvInitialiseTaskLists+0x1c>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    1382:	00a3      	lsls	r3, r4, #2
    1384:	191b      	adds	r3, r3, r4
    1386:	009a      	lsls	r2, r3, #2
    1388:	4810      	ldr	r0, [pc, #64]	; (13cc <prvInitialiseTaskLists+0x54>)
    138a:	3030      	adds	r0, #48	; 0x30
    138c:	1880      	adds	r0, r0, r2
    138e:	4b10      	ldr	r3, [pc, #64]	; (13d0 <prvInitialiseTaskLists+0x58>)
    1390:	4798      	blx	r3
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    1392:	3401      	adds	r4, #1
    1394:	2c04      	cmp	r4, #4
    1396:	d9f4      	bls.n	1382 <prvInitialiseTaskLists+0xa>
	vListInitialise( &xDelayedTaskList1 );
    1398:	4d0e      	ldr	r5, [pc, #56]	; (13d4 <prvInitialiseTaskLists+0x5c>)
    139a:	2314      	movs	r3, #20
    139c:	4698      	mov	r8, r3
    139e:	44a8      	add	r8, r5
    13a0:	4640      	mov	r0, r8
    13a2:	4c0b      	ldr	r4, [pc, #44]	; (13d0 <prvInitialiseTaskLists+0x58>)
    13a4:	47a0      	blx	r4
	vListInitialise( &xDelayedTaskList2 );
    13a6:	002f      	movs	r7, r5
    13a8:	3728      	adds	r7, #40	; 0x28
    13aa:	0038      	movs	r0, r7
    13ac:	47a0      	blx	r4
	vListInitialise( &xPendingReadyList );
    13ae:	4e07      	ldr	r6, [pc, #28]	; (13cc <prvInitialiseTaskLists+0x54>)
    13b0:	0030      	movs	r0, r6
    13b2:	3014      	adds	r0, #20
    13b4:	47a0      	blx	r4
		vListInitialise( &xTasksWaitingTermination );
    13b6:	0028      	movs	r0, r5
    13b8:	303c      	adds	r0, #60	; 0x3c
    13ba:	47a0      	blx	r4
		vListInitialise( &xSuspendedTaskList );
    13bc:	0030      	movs	r0, r6
    13be:	47a0      	blx	r4
	pxDelayedTaskList = &xDelayedTaskList1;
    13c0:	4643      	mov	r3, r8
    13c2:	62b3      	str	r3, [r6, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    13c4:	652f      	str	r7, [r5, #80]	; 0x50
}
    13c6:	bc04      	pop	{r2}
    13c8:	4690      	mov	r8, r2
    13ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    13cc:	200029b4 	.word	0x200029b4
    13d0:	000006f9 	.word	0x000006f9
    13d4:	20002a34 	.word	0x20002a34

000013d8 <prvAddNewTaskToReadyList>:
{
    13d8:	b510      	push	{r4, lr}
    13da:	0004      	movs	r4, r0
	taskENTER_CRITICAL();
    13dc:	4b1f      	ldr	r3, [pc, #124]	; (145c <prvAddNewTaskToReadyList+0x84>)
    13de:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    13e0:	4b1f      	ldr	r3, [pc, #124]	; (1460 <prvAddNewTaskToReadyList+0x88>)
    13e2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    13e4:	3201      	adds	r2, #1
    13e6:	655a      	str	r2, [r3, #84]	; 0x54
		if( pxCurrentTCB == NULL )
    13e8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    13ea:	2b00      	cmp	r3, #0
    13ec:	d02b      	beq.n	1446 <prvAddNewTaskToReadyList+0x6e>
			if( xSchedulerRunning == pdFALSE )
    13ee:	4b1c      	ldr	r3, [pc, #112]	; (1460 <prvAddNewTaskToReadyList+0x88>)
    13f0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    13f2:	2b00      	cmp	r3, #0
    13f4:	d107      	bne.n	1406 <prvAddNewTaskToReadyList+0x2e>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    13f6:	4b1a      	ldr	r3, [pc, #104]	; (1460 <prvAddNewTaskToReadyList+0x88>)
    13f8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    13fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    13fc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    13fe:	4293      	cmp	r3, r2
    1400:	d801      	bhi.n	1406 <prvAddNewTaskToReadyList+0x2e>
					pxCurrentTCB = pxNewTCB;
    1402:	4b17      	ldr	r3, [pc, #92]	; (1460 <prvAddNewTaskToReadyList+0x88>)
    1404:	659c      	str	r4, [r3, #88]	; 0x58
		uxTaskNumber++;
    1406:	4916      	ldr	r1, [pc, #88]	; (1460 <prvAddNewTaskToReadyList+0x88>)
    1408:	6e0b      	ldr	r3, [r1, #96]	; 0x60
    140a:	3301      	adds	r3, #1
    140c:	660b      	str	r3, [r1, #96]	; 0x60
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    140e:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList( pxNewTCB );
    1410:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1412:	6e4b      	ldr	r3, [r1, #100]	; 0x64
    1414:	429a      	cmp	r2, r3
    1416:	d900      	bls.n	141a <prvAddNewTaskToReadyList+0x42>
    1418:	664a      	str	r2, [r1, #100]	; 0x64
    141a:	1d21      	adds	r1, r4, #4
    141c:	0093      	lsls	r3, r2, #2
    141e:	189b      	adds	r3, r3, r2
    1420:	009a      	lsls	r2, r3, #2
    1422:	4810      	ldr	r0, [pc, #64]	; (1464 <prvAddNewTaskToReadyList+0x8c>)
    1424:	3030      	adds	r0, #48	; 0x30
    1426:	1880      	adds	r0, r0, r2
    1428:	4b0f      	ldr	r3, [pc, #60]	; (1468 <prvAddNewTaskToReadyList+0x90>)
    142a:	4798      	blx	r3
	taskEXIT_CRITICAL();
    142c:	4b0f      	ldr	r3, [pc, #60]	; (146c <prvAddNewTaskToReadyList+0x94>)
    142e:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
    1430:	4b0b      	ldr	r3, [pc, #44]	; (1460 <prvAddNewTaskToReadyList+0x88>)
    1432:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1434:	2b00      	cmp	r3, #0
    1436:	d005      	beq.n	1444 <prvAddNewTaskToReadyList+0x6c>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    1438:	4b09      	ldr	r3, [pc, #36]	; (1460 <prvAddNewTaskToReadyList+0x88>)
    143a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    143c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    143e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1440:	429a      	cmp	r2, r3
    1442:	d308      	bcc.n	1456 <prvAddNewTaskToReadyList+0x7e>
}
    1444:	bd10      	pop	{r4, pc}
			pxCurrentTCB = pxNewTCB;
    1446:	4b06      	ldr	r3, [pc, #24]	; (1460 <prvAddNewTaskToReadyList+0x88>)
    1448:	659c      	str	r4, [r3, #88]	; 0x58
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    144a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    144c:	2b01      	cmp	r3, #1
    144e:	d1da      	bne.n	1406 <prvAddNewTaskToReadyList+0x2e>
				prvInitialiseTaskLists();
    1450:	4b07      	ldr	r3, [pc, #28]	; (1470 <prvAddNewTaskToReadyList+0x98>)
    1452:	4798      	blx	r3
    1454:	e7d7      	b.n	1406 <prvAddNewTaskToReadyList+0x2e>
			taskYIELD_IF_USING_PREEMPTION();
    1456:	4b07      	ldr	r3, [pc, #28]	; (1474 <prvAddNewTaskToReadyList+0x9c>)
    1458:	4798      	blx	r3
}
    145a:	e7f3      	b.n	1444 <prvAddNewTaskToReadyList+0x6c>
    145c:	00000a61 	.word	0x00000a61
    1460:	20002a34 	.word	0x20002a34
    1464:	200029b4 	.word	0x200029b4
    1468:	00000715 	.word	0x00000715
    146c:	00000a79 	.word	0x00000a79
    1470:	00001379 	.word	0x00001379
    1474:	00000a49 	.word	0x00000a49

00001478 <prvCheckTasksWaitingTermination>:
{
    1478:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    147a:	e012      	b.n	14a2 <prvCheckTasksWaitingTermination+0x2a>
			taskENTER_CRITICAL();
    147c:	4b0b      	ldr	r3, [pc, #44]	; (14ac <prvCheckTasksWaitingTermination+0x34>)
    147e:	4798      	blx	r3
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1480:	4c0b      	ldr	r4, [pc, #44]	; (14b0 <prvCheckTasksWaitingTermination+0x38>)
    1482:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1484:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1486:	1d28      	adds	r0, r5, #4
    1488:	4b0a      	ldr	r3, [pc, #40]	; (14b4 <prvCheckTasksWaitingTermination+0x3c>)
    148a:	4798      	blx	r3
				--uxCurrentNumberOfTasks;
    148c:	6d63      	ldr	r3, [r4, #84]	; 0x54
    148e:	3b01      	subs	r3, #1
    1490:	6563      	str	r3, [r4, #84]	; 0x54
				--uxDeletedTasksWaitingCleanUp;
    1492:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    1494:	3b01      	subs	r3, #1
    1496:	66a3      	str	r3, [r4, #104]	; 0x68
			taskEXIT_CRITICAL();
    1498:	4b07      	ldr	r3, [pc, #28]	; (14b8 <prvCheckTasksWaitingTermination+0x40>)
    149a:	4798      	blx	r3
			prvDeleteTCB( pxTCB );
    149c:	0028      	movs	r0, r5
    149e:	4b07      	ldr	r3, [pc, #28]	; (14bc <prvCheckTasksWaitingTermination+0x44>)
    14a0:	4798      	blx	r3
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    14a2:	4b03      	ldr	r3, [pc, #12]	; (14b0 <prvCheckTasksWaitingTermination+0x38>)
    14a4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    14a6:	2b00      	cmp	r3, #0
    14a8:	d1e8      	bne.n	147c <prvCheckTasksWaitingTermination+0x4>
}
    14aa:	bd70      	pop	{r4, r5, r6, pc}
    14ac:	00000a61 	.word	0x00000a61
    14b0:	20002a34 	.word	0x20002a34
    14b4:	0000075d 	.word	0x0000075d
    14b8:	00000a79 	.word	0x00000a79
    14bc:	000012b1 	.word	0x000012b1

000014c0 <prvIdleTask>:
{
    14c0:	b510      	push	{r4, lr}
		prvCheckTasksWaitingTermination();
    14c2:	4b04      	ldr	r3, [pc, #16]	; (14d4 <prvIdleTask+0x14>)
    14c4:	4798      	blx	r3
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    14c6:	4b04      	ldr	r3, [pc, #16]	; (14d8 <prvIdleTask+0x18>)
    14c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    14ca:	2b01      	cmp	r3, #1
    14cc:	d9f9      	bls.n	14c2 <prvIdleTask+0x2>
				taskYIELD();
    14ce:	4b03      	ldr	r3, [pc, #12]	; (14dc <prvIdleTask+0x1c>)
    14d0:	4798      	blx	r3
    14d2:	e7f6      	b.n	14c2 <prvIdleTask+0x2>
    14d4:	00001479 	.word	0x00001479
    14d8:	200029b4 	.word	0x200029b4
    14dc:	00000a49 	.word	0x00000a49

000014e0 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    14e0:	b570      	push	{r4, r5, r6, lr}
    14e2:	0004      	movs	r4, r0
    14e4:	000d      	movs	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    14e6:	4b15      	ldr	r3, [pc, #84]	; (153c <prvAddCurrentTaskToDelayedList+0x5c>)
    14e8:	6ede      	ldr	r6, [r3, #108]	; 0x6c
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    14ea:	6d98      	ldr	r0, [r3, #88]	; 0x58
    14ec:	3004      	adds	r0, #4
    14ee:	4b14      	ldr	r3, [pc, #80]	; (1540 <prvAddCurrentTaskToDelayedList+0x60>)
    14f0:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    14f2:	1c63      	adds	r3, r4, #1
    14f4:	d012      	beq.n	151c <prvAddCurrentTaskToDelayedList+0x3c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    14f6:	1934      	adds	r4, r6, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    14f8:	4b10      	ldr	r3, [pc, #64]	; (153c <prvAddCurrentTaskToDelayedList+0x5c>)
    14fa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    14fc:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
    14fe:	42a6      	cmp	r6, r4
    1500:	d815      	bhi.n	152e <prvAddCurrentTaskToDelayedList+0x4e>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1502:	4d10      	ldr	r5, [pc, #64]	; (1544 <prvAddCurrentTaskToDelayedList+0x64>)
    1504:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    1506:	4b0d      	ldr	r3, [pc, #52]	; (153c <prvAddCurrentTaskToDelayedList+0x5c>)
    1508:	6d99      	ldr	r1, [r3, #88]	; 0x58
    150a:	3104      	adds	r1, #4
    150c:	4b0e      	ldr	r3, [pc, #56]	; (1548 <prvAddCurrentTaskToDelayedList+0x68>)
    150e:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    1510:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    1512:	429c      	cmp	r4, r3
    1514:	d211      	bcs.n	153a <prvAddCurrentTaskToDelayedList+0x5a>
				{
					xNextTaskUnblockTime = xTimeToWake;
    1516:	4b0b      	ldr	r3, [pc, #44]	; (1544 <prvAddCurrentTaskToDelayedList+0x64>)
    1518:	62dc      	str	r4, [r3, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    151a:	e00e      	b.n	153a <prvAddCurrentTaskToDelayedList+0x5a>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    151c:	2d00      	cmp	r5, #0
    151e:	d0ea      	beq.n	14f6 <prvAddCurrentTaskToDelayedList+0x16>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1520:	4b06      	ldr	r3, [pc, #24]	; (153c <prvAddCurrentTaskToDelayedList+0x5c>)
    1522:	6d99      	ldr	r1, [r3, #88]	; 0x58
    1524:	3104      	adds	r1, #4
    1526:	4807      	ldr	r0, [pc, #28]	; (1544 <prvAddCurrentTaskToDelayedList+0x64>)
    1528:	4b08      	ldr	r3, [pc, #32]	; (154c <prvAddCurrentTaskToDelayedList+0x6c>)
    152a:	4798      	blx	r3
    152c:	e005      	b.n	153a <prvAddCurrentTaskToDelayedList+0x5a>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    152e:	4b03      	ldr	r3, [pc, #12]	; (153c <prvAddCurrentTaskToDelayedList+0x5c>)
    1530:	6d18      	ldr	r0, [r3, #80]	; 0x50
    1532:	6d99      	ldr	r1, [r3, #88]	; 0x58
    1534:	3104      	adds	r1, #4
    1536:	4b04      	ldr	r3, [pc, #16]	; (1548 <prvAddCurrentTaskToDelayedList+0x68>)
    1538:	4798      	blx	r3
}
    153a:	bd70      	pop	{r4, r5, r6, pc}
    153c:	20002a34 	.word	0x20002a34
    1540:	0000075d 	.word	0x0000075d
    1544:	200029b4 	.word	0x200029b4
    1548:	0000072d 	.word	0x0000072d
    154c:	00000715 	.word	0x00000715

00001550 <xTaskCreate>:
	{
    1550:	b5f0      	push	{r4, r5, r6, r7, lr}
    1552:	b087      	sub	sp, #28
    1554:	9004      	str	r0, [sp, #16]
    1556:	9105      	str	r1, [sp, #20]
    1558:	0014      	movs	r4, r2
    155a:	001f      	movs	r7, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    155c:	0090      	lsls	r0, r2, #2
    155e:	4b14      	ldr	r3, [pc, #80]	; (15b0 <xTaskCreate+0x60>)
    1560:	4798      	blx	r3
    1562:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
    1564:	d01e      	beq.n	15a4 <xTaskCreate+0x54>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    1566:	2054      	movs	r0, #84	; 0x54
    1568:	4b11      	ldr	r3, [pc, #68]	; (15b0 <xTaskCreate+0x60>)
    156a:	4798      	blx	r3
    156c:	1e05      	subs	r5, r0, #0
				if( pxNewTCB != NULL )
    156e:	d015      	beq.n	159c <xTaskCreate+0x4c>
					pxNewTCB->pxStack = pxStack;
    1570:	6306      	str	r6, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
    1572:	2d00      	cmp	r5, #0
    1574:	d018      	beq.n	15a8 <xTaskCreate+0x58>
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    1576:	2300      	movs	r3, #0
    1578:	9303      	str	r3, [sp, #12]
    157a:	9502      	str	r5, [sp, #8]
    157c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    157e:	9301      	str	r3, [sp, #4]
    1580:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1582:	9300      	str	r3, [sp, #0]
    1584:	003b      	movs	r3, r7
    1586:	0022      	movs	r2, r4
    1588:	9905      	ldr	r1, [sp, #20]
    158a:	9804      	ldr	r0, [sp, #16]
    158c:	4c09      	ldr	r4, [pc, #36]	; (15b4 <xTaskCreate+0x64>)
    158e:	47a0      	blx	r4
			prvAddNewTaskToReadyList( pxNewTCB );
    1590:	0028      	movs	r0, r5
    1592:	4b09      	ldr	r3, [pc, #36]	; (15b8 <xTaskCreate+0x68>)
    1594:	4798      	blx	r3
			xReturn = pdPASS;
    1596:	2001      	movs	r0, #1
	}
    1598:	b007      	add	sp, #28
    159a:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
    159c:	0030      	movs	r0, r6
    159e:	4b07      	ldr	r3, [pc, #28]	; (15bc <xTaskCreate+0x6c>)
    15a0:	4798      	blx	r3
    15a2:	e7e6      	b.n	1572 <xTaskCreate+0x22>
				pxNewTCB = NULL;
    15a4:	2500      	movs	r5, #0
    15a6:	e7e4      	b.n	1572 <xTaskCreate+0x22>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    15a8:	2001      	movs	r0, #1
    15aa:	4240      	negs	r0, r0
		return xReturn;
    15ac:	e7f4      	b.n	1598 <xTaskCreate+0x48>
    15ae:	46c0      	nop			; (mov r8, r8)
    15b0:	00000825 	.word	0x00000825
    15b4:	000012c5 	.word	0x000012c5
    15b8:	000013d9 	.word	0x000013d9
    15bc:	000008fd 	.word	0x000008fd

000015c0 <vTaskStartScheduler>:
{
    15c0:	b510      	push	{r4, lr}
    15c2:	b082      	sub	sp, #8
		xReturn = xTaskCreate(	prvIdleTask,
    15c4:	4b11      	ldr	r3, [pc, #68]	; (160c <vTaskStartScheduler+0x4c>)
    15c6:	3374      	adds	r3, #116	; 0x74
    15c8:	9301      	str	r3, [sp, #4]
    15ca:	2300      	movs	r3, #0
    15cc:	9300      	str	r3, [sp, #0]
    15ce:	2246      	movs	r2, #70	; 0x46
    15d0:	490f      	ldr	r1, [pc, #60]	; (1610 <vTaskStartScheduler+0x50>)
    15d2:	4810      	ldr	r0, [pc, #64]	; (1614 <vTaskStartScheduler+0x54>)
    15d4:	4c10      	ldr	r4, [pc, #64]	; (1618 <vTaskStartScheduler+0x58>)
    15d6:	47a0      	blx	r4
		if( xReturn == pdPASS )
    15d8:	2801      	cmp	r0, #1
    15da:	d005      	beq.n	15e8 <vTaskStartScheduler+0x28>
	if( xReturn == pdPASS )
    15dc:	2801      	cmp	r0, #1
    15de:	d006      	beq.n	15ee <vTaskStartScheduler+0x2e>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    15e0:	1c43      	adds	r3, r0, #1
    15e2:	d011      	beq.n	1608 <vTaskStartScheduler+0x48>
}
    15e4:	b002      	add	sp, #8
    15e6:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    15e8:	4b0c      	ldr	r3, [pc, #48]	; (161c <vTaskStartScheduler+0x5c>)
    15ea:	4798      	blx	r3
    15ec:	e7f6      	b.n	15dc <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    15ee:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    15f0:	2201      	movs	r2, #1
    15f2:	4252      	negs	r2, r2
    15f4:	4b0a      	ldr	r3, [pc, #40]	; (1620 <vTaskStartScheduler+0x60>)
    15f6:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning = pdTRUE;
    15f8:	4b04      	ldr	r3, [pc, #16]	; (160c <vTaskStartScheduler+0x4c>)
    15fa:	3202      	adds	r2, #2
    15fc:	65da      	str	r2, [r3, #92]	; 0x5c
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    15fe:	2200      	movs	r2, #0
    1600:	66da      	str	r2, [r3, #108]	; 0x6c
		if( xPortStartScheduler() != pdFALSE )
    1602:	4b08      	ldr	r3, [pc, #32]	; (1624 <vTaskStartScheduler+0x64>)
    1604:	4798      	blx	r3
    1606:	e7ed      	b.n	15e4 <vTaskStartScheduler+0x24>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
    1608:	b672      	cpsid	i
    160a:	e7fe      	b.n	160a <vTaskStartScheduler+0x4a>
    160c:	20002a34 	.word	0x20002a34
    1610:	00003b00 	.word	0x00003b00
    1614:	000014c1 	.word	0x000014c1
    1618:	00001551 	.word	0x00001551
    161c:	00001bdd 	.word	0x00001bdd
    1620:	200029b4 	.word	0x200029b4
    1624:	000009fd 	.word	0x000009fd

00001628 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    1628:	4a02      	ldr	r2, [pc, #8]	; (1634 <vTaskSuspendAll+0xc>)
    162a:	6f13      	ldr	r3, [r2, #112]	; 0x70
    162c:	3301      	adds	r3, #1
    162e:	6713      	str	r3, [r2, #112]	; 0x70
}
    1630:	4770      	bx	lr
    1632:	46c0      	nop			; (mov r8, r8)
    1634:	20002a34 	.word	0x20002a34

00001638 <xTaskGetTickCount>:
		xTicks = xTickCount;
    1638:	4b01      	ldr	r3, [pc, #4]	; (1640 <xTaskGetTickCount+0x8>)
    163a:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
}
    163c:	4770      	bx	lr
    163e:	46c0      	nop			; (mov r8, r8)
    1640:	20002a34 	.word	0x20002a34

00001644 <xTaskIncrementTick>:
{
    1644:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1646:	4b39      	ldr	r3, [pc, #228]	; (172c <xTaskIncrementTick+0xe8>)
    1648:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    164a:	2b00      	cmp	r3, #0
    164c:	d162      	bne.n	1714 <xTaskIncrementTick+0xd0>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    164e:	4b37      	ldr	r3, [pc, #220]	; (172c <xTaskIncrementTick+0xe8>)
    1650:	6edd      	ldr	r5, [r3, #108]	; 0x6c
    1652:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
    1654:	66dd      	str	r5, [r3, #108]	; 0x6c
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    1656:	2d00      	cmp	r5, #0
    1658:	d111      	bne.n	167e <xTaskIncrementTick+0x3a>
			taskSWITCH_DELAYED_LISTS();
    165a:	4b35      	ldr	r3, [pc, #212]	; (1730 <xTaskIncrementTick+0xec>)
    165c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    165e:	681b      	ldr	r3, [r3, #0]
    1660:	2b00      	cmp	r3, #0
    1662:	d001      	beq.n	1668 <xTaskIncrementTick+0x24>
    1664:	b672      	cpsid	i
    1666:	e7fe      	b.n	1666 <xTaskIncrementTick+0x22>
    1668:	4a31      	ldr	r2, [pc, #196]	; (1730 <xTaskIncrementTick+0xec>)
    166a:	6a91      	ldr	r1, [r2, #40]	; 0x28
    166c:	4b2f      	ldr	r3, [pc, #188]	; (172c <xTaskIncrementTick+0xe8>)
    166e:	6d18      	ldr	r0, [r3, #80]	; 0x50
    1670:	6290      	str	r0, [r2, #40]	; 0x28
    1672:	6519      	str	r1, [r3, #80]	; 0x50
    1674:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    1676:	3201      	adds	r2, #1
    1678:	679a      	str	r2, [r3, #120]	; 0x78
    167a:	4b2e      	ldr	r3, [pc, #184]	; (1734 <xTaskIncrementTick+0xf0>)
    167c:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
    167e:	4b2c      	ldr	r3, [pc, #176]	; (1730 <xTaskIncrementTick+0xec>)
    1680:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1682:	429d      	cmp	r5, r3
    1684:	d23c      	bcs.n	1700 <xTaskIncrementTick+0xbc>
BaseType_t xSwitchRequired = pdFALSE;
    1686:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1688:	4b28      	ldr	r3, [pc, #160]	; (172c <xTaskIncrementTick+0xe8>)
    168a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    168c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    168e:	0093      	lsls	r3, r2, #2
    1690:	189b      	adds	r3, r3, r2
    1692:	009a      	lsls	r2, r3, #2
    1694:	4b26      	ldr	r3, [pc, #152]	; (1730 <xTaskIncrementTick+0xec>)
    1696:	189b      	adds	r3, r3, r2
    1698:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    169a:	2b01      	cmp	r3, #1
    169c:	d93f      	bls.n	171e <xTaskIncrementTick+0xda>
				xSwitchRequired = pdTRUE;
    169e:	2401      	movs	r4, #1
    16a0:	e03d      	b.n	171e <xTaskIncrementTick+0xda>
							xSwitchRequired = pdTRUE;
    16a2:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    16a4:	4b22      	ldr	r3, [pc, #136]	; (1730 <xTaskIncrementTick+0xec>)
    16a6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    16a8:	681b      	ldr	r3, [r3, #0]
    16aa:	2b00      	cmp	r3, #0
    16ac:	d02a      	beq.n	1704 <xTaskIncrementTick+0xc0>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    16ae:	4b20      	ldr	r3, [pc, #128]	; (1730 <xTaskIncrementTick+0xec>)
    16b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    16b2:	68db      	ldr	r3, [r3, #12]
    16b4:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    16b6:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
    16b8:	429d      	cmp	r5, r3
    16ba:	d328      	bcc.n	170e <xTaskIncrementTick+0xca>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    16bc:	1d37      	adds	r7, r6, #4
    16be:	0038      	movs	r0, r7
    16c0:	4b1d      	ldr	r3, [pc, #116]	; (1738 <xTaskIncrementTick+0xf4>)
    16c2:	4798      	blx	r3
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    16c4:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    16c6:	2b00      	cmp	r3, #0
    16c8:	d003      	beq.n	16d2 <xTaskIncrementTick+0x8e>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    16ca:	0030      	movs	r0, r6
    16cc:	3018      	adds	r0, #24
    16ce:	4b1a      	ldr	r3, [pc, #104]	; (1738 <xTaskIncrementTick+0xf4>)
    16d0:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
    16d2:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    16d4:	4b15      	ldr	r3, [pc, #84]	; (172c <xTaskIncrementTick+0xe8>)
    16d6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    16d8:	429a      	cmp	r2, r3
    16da:	d901      	bls.n	16e0 <xTaskIncrementTick+0x9c>
    16dc:	4b13      	ldr	r3, [pc, #76]	; (172c <xTaskIncrementTick+0xe8>)
    16de:	665a      	str	r2, [r3, #100]	; 0x64
    16e0:	0093      	lsls	r3, r2, #2
    16e2:	189b      	adds	r3, r3, r2
    16e4:	009a      	lsls	r2, r3, #2
    16e6:	4812      	ldr	r0, [pc, #72]	; (1730 <xTaskIncrementTick+0xec>)
    16e8:	3030      	adds	r0, #48	; 0x30
    16ea:	1880      	adds	r0, r0, r2
    16ec:	0039      	movs	r1, r7
    16ee:	4b13      	ldr	r3, [pc, #76]	; (173c <xTaskIncrementTick+0xf8>)
    16f0:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    16f2:	6af2      	ldr	r2, [r6, #44]	; 0x2c
    16f4:	4b0d      	ldr	r3, [pc, #52]	; (172c <xTaskIncrementTick+0xe8>)
    16f6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    16f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    16fa:	429a      	cmp	r2, r3
    16fc:	d2d1      	bcs.n	16a2 <xTaskIncrementTick+0x5e>
    16fe:	e7d1      	b.n	16a4 <xTaskIncrementTick+0x60>
    1700:	2400      	movs	r4, #0
    1702:	e7cf      	b.n	16a4 <xTaskIncrementTick+0x60>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1704:	2201      	movs	r2, #1
    1706:	4252      	negs	r2, r2
    1708:	4b09      	ldr	r3, [pc, #36]	; (1730 <xTaskIncrementTick+0xec>)
    170a:	62da      	str	r2, [r3, #44]	; 0x2c
					break;
    170c:	e7bc      	b.n	1688 <xTaskIncrementTick+0x44>
						xNextTaskUnblockTime = xItemValue;
    170e:	4a08      	ldr	r2, [pc, #32]	; (1730 <xTaskIncrementTick+0xec>)
    1710:	62d3      	str	r3, [r2, #44]	; 0x2c
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
    1712:	e7b9      	b.n	1688 <xTaskIncrementTick+0x44>
		++uxPendedTicks;
    1714:	4a05      	ldr	r2, [pc, #20]	; (172c <xTaskIncrementTick+0xe8>)
    1716:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    1718:	3301      	adds	r3, #1
    171a:	67d3      	str	r3, [r2, #124]	; 0x7c
BaseType_t xSwitchRequired = pdFALSE;
    171c:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
    171e:	4b08      	ldr	r3, [pc, #32]	; (1740 <xTaskIncrementTick+0xfc>)
    1720:	681b      	ldr	r3, [r3, #0]
    1722:	2b00      	cmp	r3, #0
    1724:	d000      	beq.n	1728 <xTaskIncrementTick+0xe4>
			xSwitchRequired = pdTRUE;
    1726:	2401      	movs	r4, #1
}
    1728:	0020      	movs	r0, r4
    172a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    172c:	20002a34 	.word	0x20002a34
    1730:	200029b4 	.word	0x200029b4
    1734:	00001289 	.word	0x00001289
    1738:	0000075d 	.word	0x0000075d
    173c:	00000715 	.word	0x00000715
    1740:	20002ab4 	.word	0x20002ab4

00001744 <xTaskResumeAll>:
{
    1744:	b570      	push	{r4, r5, r6, lr}
	configASSERT( uxSchedulerSuspended );
    1746:	4b32      	ldr	r3, [pc, #200]	; (1810 <xTaskResumeAll+0xcc>)
    1748:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    174a:	2b00      	cmp	r3, #0
    174c:	d101      	bne.n	1752 <xTaskResumeAll+0xe>
    174e:	b672      	cpsid	i
    1750:	e7fe      	b.n	1750 <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
    1752:	4b30      	ldr	r3, [pc, #192]	; (1814 <xTaskResumeAll+0xd0>)
    1754:	4798      	blx	r3
		--uxSchedulerSuspended;
    1756:	4b2e      	ldr	r3, [pc, #184]	; (1810 <xTaskResumeAll+0xcc>)
    1758:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    175a:	3a01      	subs	r2, #1
    175c:	671a      	str	r2, [r3, #112]	; 0x70
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    175e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1760:	2b00      	cmp	r3, #0
    1762:	d150      	bne.n	1806 <xTaskResumeAll+0xc2>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1764:	4b2a      	ldr	r3, [pc, #168]	; (1810 <xTaskResumeAll+0xcc>)
    1766:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    1768:	2b00      	cmp	r3, #0
    176a:	d104      	bne.n	1776 <xTaskResumeAll+0x32>
BaseType_t xAlreadyYielded = pdFALSE;
    176c:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
    176e:	4b2a      	ldr	r3, [pc, #168]	; (1818 <xTaskResumeAll+0xd4>)
    1770:	4798      	blx	r3
}
    1772:	0020      	movs	r0, r4
    1774:	bd70      	pop	{r4, r5, r6, pc}
    1776:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1778:	4b28      	ldr	r3, [pc, #160]	; (181c <xTaskResumeAll+0xd8>)
    177a:	695b      	ldr	r3, [r3, #20]
    177c:	2b00      	cmp	r3, #0
    177e:	d023      	beq.n	17c8 <xTaskResumeAll+0x84>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1780:	4b26      	ldr	r3, [pc, #152]	; (181c <xTaskResumeAll+0xd8>)
    1782:	6a1b      	ldr	r3, [r3, #32]
    1784:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1786:	0020      	movs	r0, r4
    1788:	3018      	adds	r0, #24
    178a:	4e25      	ldr	r6, [pc, #148]	; (1820 <xTaskResumeAll+0xdc>)
    178c:	47b0      	blx	r6
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    178e:	1d25      	adds	r5, r4, #4
    1790:	0028      	movs	r0, r5
    1792:	47b0      	blx	r6
					prvAddTaskToReadyList( pxTCB );
    1794:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1796:	4b1e      	ldr	r3, [pc, #120]	; (1810 <xTaskResumeAll+0xcc>)
    1798:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    179a:	429a      	cmp	r2, r3
    179c:	d901      	bls.n	17a2 <xTaskResumeAll+0x5e>
    179e:	4b1c      	ldr	r3, [pc, #112]	; (1810 <xTaskResumeAll+0xcc>)
    17a0:	665a      	str	r2, [r3, #100]	; 0x64
    17a2:	0093      	lsls	r3, r2, #2
    17a4:	189b      	adds	r3, r3, r2
    17a6:	009a      	lsls	r2, r3, #2
    17a8:	481c      	ldr	r0, [pc, #112]	; (181c <xTaskResumeAll+0xd8>)
    17aa:	3030      	adds	r0, #48	; 0x30
    17ac:	1880      	adds	r0, r0, r2
    17ae:	0029      	movs	r1, r5
    17b0:	4b1c      	ldr	r3, [pc, #112]	; (1824 <xTaskResumeAll+0xe0>)
    17b2:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    17b4:	4b16      	ldr	r3, [pc, #88]	; (1810 <xTaskResumeAll+0xcc>)
    17b6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    17b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    17ba:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    17bc:	429a      	cmp	r2, r3
    17be:	d3db      	bcc.n	1778 <xTaskResumeAll+0x34>
						xYieldPending = pdTRUE;
    17c0:	2201      	movs	r2, #1
    17c2:	4b19      	ldr	r3, [pc, #100]	; (1828 <xTaskResumeAll+0xe4>)
    17c4:	601a      	str	r2, [r3, #0]
    17c6:	e7d7      	b.n	1778 <xTaskResumeAll+0x34>
				if( pxTCB != NULL )
    17c8:	2c00      	cmp	r4, #0
    17ca:	d001      	beq.n	17d0 <xTaskResumeAll+0x8c>
					prvResetNextTaskUnblockTime();
    17cc:	4b17      	ldr	r3, [pc, #92]	; (182c <xTaskResumeAll+0xe8>)
    17ce:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    17d0:	4b0f      	ldr	r3, [pc, #60]	; (1810 <xTaskResumeAll+0xcc>)
    17d2:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
					if( uxPendedCounts > ( UBaseType_t ) 0U )
    17d4:	2c00      	cmp	r4, #0
    17d6:	d10a      	bne.n	17ee <xTaskResumeAll+0xaa>
				if( xYieldPending != pdFALSE )
    17d8:	4b13      	ldr	r3, [pc, #76]	; (1828 <xTaskResumeAll+0xe4>)
    17da:	681b      	ldr	r3, [r3, #0]
    17dc:	2b00      	cmp	r3, #0
    17de:	d014      	beq.n	180a <xTaskResumeAll+0xc6>
					taskYIELD_IF_USING_PREEMPTION();
    17e0:	4b13      	ldr	r3, [pc, #76]	; (1830 <xTaskResumeAll+0xec>)
    17e2:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    17e4:	2401      	movs	r4, #1
    17e6:	e7c2      	b.n	176e <xTaskResumeAll+0x2a>
							--uxPendedCounts;
    17e8:	3c01      	subs	r4, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    17ea:	2c00      	cmp	r4, #0
    17ec:	d007      	beq.n	17fe <xTaskResumeAll+0xba>
							if( xTaskIncrementTick() != pdFALSE )
    17ee:	4b11      	ldr	r3, [pc, #68]	; (1834 <xTaskResumeAll+0xf0>)
    17f0:	4798      	blx	r3
    17f2:	2800      	cmp	r0, #0
    17f4:	d0f8      	beq.n	17e8 <xTaskResumeAll+0xa4>
								xYieldPending = pdTRUE;
    17f6:	2201      	movs	r2, #1
    17f8:	4b0b      	ldr	r3, [pc, #44]	; (1828 <xTaskResumeAll+0xe4>)
    17fa:	601a      	str	r2, [r3, #0]
    17fc:	e7f4      	b.n	17e8 <xTaskResumeAll+0xa4>
						uxPendedTicks = 0;
    17fe:	2200      	movs	r2, #0
    1800:	4b03      	ldr	r3, [pc, #12]	; (1810 <xTaskResumeAll+0xcc>)
    1802:	67da      	str	r2, [r3, #124]	; 0x7c
    1804:	e7e8      	b.n	17d8 <xTaskResumeAll+0x94>
BaseType_t xAlreadyYielded = pdFALSE;
    1806:	2400      	movs	r4, #0
    1808:	e7b1      	b.n	176e <xTaskResumeAll+0x2a>
    180a:	2400      	movs	r4, #0
    180c:	e7af      	b.n	176e <xTaskResumeAll+0x2a>
    180e:	46c0      	nop			; (mov r8, r8)
    1810:	20002a34 	.word	0x20002a34
    1814:	00000a61 	.word	0x00000a61
    1818:	00000a79 	.word	0x00000a79
    181c:	200029b4 	.word	0x200029b4
    1820:	0000075d 	.word	0x0000075d
    1824:	00000715 	.word	0x00000715
    1828:	20002ab4 	.word	0x20002ab4
    182c:	00001289 	.word	0x00001289
    1830:	00000a49 	.word	0x00000a49
    1834:	00001645 	.word	0x00001645

00001838 <vTaskDelay>:
	{
    1838:	b510      	push	{r4, lr}
    183a:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
    183c:	d00e      	beq.n	185c <vTaskDelay+0x24>
			configASSERT( uxSchedulerSuspended == 0 );
    183e:	4b0a      	ldr	r3, [pc, #40]	; (1868 <vTaskDelay+0x30>)
    1840:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1842:	2b00      	cmp	r3, #0
    1844:	d001      	beq.n	184a <vTaskDelay+0x12>
    1846:	b672      	cpsid	i
    1848:	e7fe      	b.n	1848 <vTaskDelay+0x10>
			vTaskSuspendAll();
    184a:	4b08      	ldr	r3, [pc, #32]	; (186c <vTaskDelay+0x34>)
    184c:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    184e:	2100      	movs	r1, #0
    1850:	0020      	movs	r0, r4
    1852:	4b07      	ldr	r3, [pc, #28]	; (1870 <vTaskDelay+0x38>)
    1854:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
    1856:	4b07      	ldr	r3, [pc, #28]	; (1874 <vTaskDelay+0x3c>)
    1858:	4798      	blx	r3
    185a:	e000      	b.n	185e <vTaskDelay+0x26>
	BaseType_t xAlreadyYielded = pdFALSE;
    185c:	2000      	movs	r0, #0
		if( xAlreadyYielded == pdFALSE )
    185e:	2800      	cmp	r0, #0
    1860:	d101      	bne.n	1866 <vTaskDelay+0x2e>
			portYIELD_WITHIN_API();
    1862:	4b05      	ldr	r3, [pc, #20]	; (1878 <vTaskDelay+0x40>)
    1864:	4798      	blx	r3
	}
    1866:	bd10      	pop	{r4, pc}
    1868:	20002a34 	.word	0x20002a34
    186c:	00001629 	.word	0x00001629
    1870:	000014e1 	.word	0x000014e1
    1874:	00001745 	.word	0x00001745
    1878:	00000a49 	.word	0x00000a49

0000187c <vTaskSwitchContext>:
{
    187c:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    187e:	4b1d      	ldr	r3, [pc, #116]	; (18f4 <vTaskSwitchContext+0x78>)
    1880:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1882:	2b00      	cmp	r3, #0
    1884:	d110      	bne.n	18a8 <vTaskSwitchContext+0x2c>
		xYieldPending = pdFALSE;
    1886:	2200      	movs	r2, #0
    1888:	4b1b      	ldr	r3, [pc, #108]	; (18f8 <vTaskSwitchContext+0x7c>)
    188a:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    188c:	4b19      	ldr	r3, [pc, #100]	; (18f4 <vTaskSwitchContext+0x78>)
    188e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    1890:	009a      	lsls	r2, r3, #2
    1892:	18d2      	adds	r2, r2, r3
    1894:	0091      	lsls	r1, r2, #2
    1896:	4a19      	ldr	r2, [pc, #100]	; (18fc <vTaskSwitchContext+0x80>)
    1898:	1852      	adds	r2, r2, r1
    189a:	6b12      	ldr	r2, [r2, #48]	; 0x30
    189c:	2a00      	cmp	r2, #0
    189e:	d109      	bne.n	18b4 <vTaskSwitchContext+0x38>
    18a0:	2b00      	cmp	r3, #0
    18a2:	d005      	beq.n	18b0 <vTaskSwitchContext+0x34>
    18a4:	3b01      	subs	r3, #1
    18a6:	e7f3      	b.n	1890 <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
    18a8:	2201      	movs	r2, #1
    18aa:	4b13      	ldr	r3, [pc, #76]	; (18f8 <vTaskSwitchContext+0x7c>)
    18ac:	601a      	str	r2, [r3, #0]
}
    18ae:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    18b0:	b672      	cpsid	i
    18b2:	e7fe      	b.n	18b2 <vTaskSwitchContext+0x36>
    18b4:	4a11      	ldr	r2, [pc, #68]	; (18fc <vTaskSwitchContext+0x80>)
    18b6:	0099      	lsls	r1, r3, #2
    18b8:	18cc      	adds	r4, r1, r3
    18ba:	00a0      	lsls	r0, r4, #2
    18bc:	1810      	adds	r0, r2, r0
    18be:	6b44      	ldr	r4, [r0, #52]	; 0x34
    18c0:	6864      	ldr	r4, [r4, #4]
    18c2:	6344      	str	r4, [r0, #52]	; 0x34
    18c4:	3230      	adds	r2, #48	; 0x30
    18c6:	18c9      	adds	r1, r1, r3
    18c8:	0088      	lsls	r0, r1, #2
    18ca:	3008      	adds	r0, #8
    18cc:	1812      	adds	r2, r2, r0
    18ce:	4294      	cmp	r4, r2
    18d0:	d00a      	beq.n	18e8 <vTaskSwitchContext+0x6c>
    18d2:	009a      	lsls	r2, r3, #2
    18d4:	18d2      	adds	r2, r2, r3
    18d6:	0091      	lsls	r1, r2, #2
    18d8:	4a08      	ldr	r2, [pc, #32]	; (18fc <vTaskSwitchContext+0x80>)
    18da:	1852      	adds	r2, r2, r1
    18dc:	6b52      	ldr	r2, [r2, #52]	; 0x34
    18de:	68d1      	ldr	r1, [r2, #12]
    18e0:	4a04      	ldr	r2, [pc, #16]	; (18f4 <vTaskSwitchContext+0x78>)
    18e2:	6591      	str	r1, [r2, #88]	; 0x58
    18e4:	6653      	str	r3, [r2, #100]	; 0x64
}
    18e6:	e7e2      	b.n	18ae <vTaskSwitchContext+0x32>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    18e8:	6860      	ldr	r0, [r4, #4]
    18ea:	0089      	lsls	r1, r1, #2
    18ec:	4a03      	ldr	r2, [pc, #12]	; (18fc <vTaskSwitchContext+0x80>)
    18ee:	1852      	adds	r2, r2, r1
    18f0:	6350      	str	r0, [r2, #52]	; 0x34
    18f2:	e7ee      	b.n	18d2 <vTaskSwitchContext+0x56>
    18f4:	20002a34 	.word	0x20002a34
    18f8:	20002ab4 	.word	0x20002ab4
    18fc:	200029b4 	.word	0x200029b4

00001900 <vTaskPlaceOnEventList>:
{
    1900:	b510      	push	{r4, lr}
    1902:	000c      	movs	r4, r1
	configASSERT( pxEventList );
    1904:	2800      	cmp	r0, #0
    1906:	d101      	bne.n	190c <vTaskPlaceOnEventList+0xc>
    1908:	b672      	cpsid	i
    190a:	e7fe      	b.n	190a <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    190c:	4b04      	ldr	r3, [pc, #16]	; (1920 <vTaskPlaceOnEventList+0x20>)
    190e:	6d99      	ldr	r1, [r3, #88]	; 0x58
    1910:	3118      	adds	r1, #24
    1912:	4b04      	ldr	r3, [pc, #16]	; (1924 <vTaskPlaceOnEventList+0x24>)
    1914:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1916:	2101      	movs	r1, #1
    1918:	0020      	movs	r0, r4
    191a:	4b03      	ldr	r3, [pc, #12]	; (1928 <vTaskPlaceOnEventList+0x28>)
    191c:	4798      	blx	r3
}
    191e:	bd10      	pop	{r4, pc}
    1920:	20002a34 	.word	0x20002a34
    1924:	0000072d 	.word	0x0000072d
    1928:	000014e1 	.word	0x000014e1

0000192c <vTaskPlaceOnEventListRestricted>:
	{
    192c:	b570      	push	{r4, r5, r6, lr}
    192e:	000c      	movs	r4, r1
    1930:	0015      	movs	r5, r2
		configASSERT( pxEventList );
    1932:	2800      	cmp	r0, #0
    1934:	d00d      	beq.n	1952 <vTaskPlaceOnEventListRestricted+0x26>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1936:	4b08      	ldr	r3, [pc, #32]	; (1958 <vTaskPlaceOnEventListRestricted+0x2c>)
    1938:	6d99      	ldr	r1, [r3, #88]	; 0x58
    193a:	3118      	adds	r1, #24
    193c:	4b07      	ldr	r3, [pc, #28]	; (195c <vTaskPlaceOnEventListRestricted+0x30>)
    193e:	4798      	blx	r3
		if( xWaitIndefinitely != pdFALSE )
    1940:	2d00      	cmp	r5, #0
    1942:	d001      	beq.n	1948 <vTaskPlaceOnEventListRestricted+0x1c>
			xTicksToWait = portMAX_DELAY;
    1944:	2401      	movs	r4, #1
    1946:	4264      	negs	r4, r4
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    1948:	0029      	movs	r1, r5
    194a:	0020      	movs	r0, r4
    194c:	4b04      	ldr	r3, [pc, #16]	; (1960 <vTaskPlaceOnEventListRestricted+0x34>)
    194e:	4798      	blx	r3
	}
    1950:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( pxEventList );
    1952:	b672      	cpsid	i
    1954:	e7fe      	b.n	1954 <vTaskPlaceOnEventListRestricted+0x28>
    1956:	46c0      	nop			; (mov r8, r8)
    1958:	20002a34 	.word	0x20002a34
    195c:	00000715 	.word	0x00000715
    1960:	000014e1 	.word	0x000014e1

00001964 <xTaskRemoveFromEventList>:
{
    1964:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1966:	68c3      	ldr	r3, [r0, #12]
    1968:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
    196a:	2c00      	cmp	r4, #0
    196c:	d027      	beq.n	19be <xTaskRemoveFromEventList+0x5a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    196e:	0025      	movs	r5, r4
    1970:	3518      	adds	r5, #24
    1972:	0028      	movs	r0, r5
    1974:	4b17      	ldr	r3, [pc, #92]	; (19d4 <xTaskRemoveFromEventList+0x70>)
    1976:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1978:	4b17      	ldr	r3, [pc, #92]	; (19d8 <xTaskRemoveFromEventList+0x74>)
    197a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    197c:	2b00      	cmp	r3, #0
    197e:	d120      	bne.n	19c2 <xTaskRemoveFromEventList+0x5e>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1980:	1d25      	adds	r5, r4, #4
    1982:	0028      	movs	r0, r5
    1984:	4b13      	ldr	r3, [pc, #76]	; (19d4 <xTaskRemoveFromEventList+0x70>)
    1986:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
    1988:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    198a:	4b13      	ldr	r3, [pc, #76]	; (19d8 <xTaskRemoveFromEventList+0x74>)
    198c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    198e:	429a      	cmp	r2, r3
    1990:	d901      	bls.n	1996 <xTaskRemoveFromEventList+0x32>
    1992:	4b11      	ldr	r3, [pc, #68]	; (19d8 <xTaskRemoveFromEventList+0x74>)
    1994:	665a      	str	r2, [r3, #100]	; 0x64
    1996:	0093      	lsls	r3, r2, #2
    1998:	189b      	adds	r3, r3, r2
    199a:	009a      	lsls	r2, r3, #2
    199c:	480f      	ldr	r0, [pc, #60]	; (19dc <xTaskRemoveFromEventList+0x78>)
    199e:	3030      	adds	r0, #48	; 0x30
    19a0:	1880      	adds	r0, r0, r2
    19a2:	0029      	movs	r1, r5
    19a4:	4b0e      	ldr	r3, [pc, #56]	; (19e0 <xTaskRemoveFromEventList+0x7c>)
    19a6:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    19a8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    19aa:	4b0b      	ldr	r3, [pc, #44]	; (19d8 <xTaskRemoveFromEventList+0x74>)
    19ac:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    19ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    19b0:	429a      	cmp	r2, r3
    19b2:	d90c      	bls.n	19ce <xTaskRemoveFromEventList+0x6a>
		xYieldPending = pdTRUE;
    19b4:	2201      	movs	r2, #1
    19b6:	4b0b      	ldr	r3, [pc, #44]	; (19e4 <xTaskRemoveFromEventList+0x80>)
    19b8:	601a      	str	r2, [r3, #0]
		xReturn = pdTRUE;
    19ba:	2001      	movs	r0, #1
}
    19bc:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxUnblockedTCB );
    19be:	b672      	cpsid	i
    19c0:	e7fe      	b.n	19c0 <xTaskRemoveFromEventList+0x5c>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    19c2:	0029      	movs	r1, r5
    19c4:	4805      	ldr	r0, [pc, #20]	; (19dc <xTaskRemoveFromEventList+0x78>)
    19c6:	3014      	adds	r0, #20
    19c8:	4b05      	ldr	r3, [pc, #20]	; (19e0 <xTaskRemoveFromEventList+0x7c>)
    19ca:	4798      	blx	r3
    19cc:	e7ec      	b.n	19a8 <xTaskRemoveFromEventList+0x44>
		xReturn = pdFALSE;
    19ce:	2000      	movs	r0, #0
	return xReturn;
    19d0:	e7f4      	b.n	19bc <xTaskRemoveFromEventList+0x58>
    19d2:	46c0      	nop			; (mov r8, r8)
    19d4:	0000075d 	.word	0x0000075d
    19d8:	20002a34 	.word	0x20002a34
    19dc:	200029b4 	.word	0x200029b4
    19e0:	00000715 	.word	0x00000715
    19e4:	20002ab4 	.word	0x20002ab4

000019e8 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    19e8:	4b02      	ldr	r3, [pc, #8]	; (19f4 <vTaskInternalSetTimeOutState+0xc>)
    19ea:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    19ec:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    19ee:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    19f0:	6043      	str	r3, [r0, #4]
}
    19f2:	4770      	bx	lr
    19f4:	20002a34 	.word	0x20002a34

000019f8 <xTaskCheckForTimeOut>:
{
    19f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    19fa:	0005      	movs	r5, r0
    19fc:	000c      	movs	r4, r1
	configASSERT( pxTimeOut );
    19fe:	2800      	cmp	r0, #0
    1a00:	d01a      	beq.n	1a38 <xTaskCheckForTimeOut+0x40>
	configASSERT( pxTicksToWait );
    1a02:	2900      	cmp	r1, #0
    1a04:	d01a      	beq.n	1a3c <xTaskCheckForTimeOut+0x44>
	taskENTER_CRITICAL();
    1a06:	4b14      	ldr	r3, [pc, #80]	; (1a58 <xTaskCheckForTimeOut+0x60>)
    1a08:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    1a0a:	4b14      	ldr	r3, [pc, #80]	; (1a5c <xTaskCheckForTimeOut+0x64>)
    1a0c:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1a0e:	6869      	ldr	r1, [r5, #4]
    1a10:	1a42      	subs	r2, r0, r1
			if( *pxTicksToWait == portMAX_DELAY )
    1a12:	6823      	ldr	r3, [r4, #0]
    1a14:	1c5e      	adds	r6, r3, #1
    1a16:	d01a      	beq.n	1a4e <xTaskCheckForTimeOut+0x56>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1a18:	4e10      	ldr	r6, [pc, #64]	; (1a5c <xTaskCheckForTimeOut+0x64>)
    1a1a:	6fb6      	ldr	r6, [r6, #120]	; 0x78
    1a1c:	682f      	ldr	r7, [r5, #0]
    1a1e:	42b7      	cmp	r7, r6
    1a20:	d001      	beq.n	1a26 <xTaskCheckForTimeOut+0x2e>
    1a22:	4288      	cmp	r0, r1
    1a24:	d215      	bcs.n	1a52 <xTaskCheckForTimeOut+0x5a>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1a26:	429a      	cmp	r2, r3
    1a28:	d30a      	bcc.n	1a40 <xTaskCheckForTimeOut+0x48>
			*pxTicksToWait = 0;
    1a2a:	2300      	movs	r3, #0
    1a2c:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
    1a2e:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    1a30:	4b0b      	ldr	r3, [pc, #44]	; (1a60 <xTaskCheckForTimeOut+0x68>)
    1a32:	4798      	blx	r3
}
    1a34:	0020      	movs	r0, r4
    1a36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	configASSERT( pxTimeOut );
    1a38:	b672      	cpsid	i
    1a3a:	e7fe      	b.n	1a3a <xTaskCheckForTimeOut+0x42>
	configASSERT( pxTicksToWait );
    1a3c:	b672      	cpsid	i
    1a3e:	e7fe      	b.n	1a3e <xTaskCheckForTimeOut+0x46>
			*pxTicksToWait -= xElapsedTime;
    1a40:	1a9b      	subs	r3, r3, r2
    1a42:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
    1a44:	0028      	movs	r0, r5
    1a46:	4b07      	ldr	r3, [pc, #28]	; (1a64 <xTaskCheckForTimeOut+0x6c>)
    1a48:	4798      	blx	r3
			xReturn = pdFALSE;
    1a4a:	2400      	movs	r4, #0
    1a4c:	e7f0      	b.n	1a30 <xTaskCheckForTimeOut+0x38>
				xReturn = pdFALSE;
    1a4e:	2400      	movs	r4, #0
    1a50:	e7ee      	b.n	1a30 <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
    1a52:	2401      	movs	r4, #1
    1a54:	e7ec      	b.n	1a30 <xTaskCheckForTimeOut+0x38>
    1a56:	46c0      	nop			; (mov r8, r8)
    1a58:	00000a61 	.word	0x00000a61
    1a5c:	20002a34 	.word	0x20002a34
    1a60:	00000a79 	.word	0x00000a79
    1a64:	000019e9 	.word	0x000019e9

00001a68 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    1a68:	2201      	movs	r2, #1
    1a6a:	4b01      	ldr	r3, [pc, #4]	; (1a70 <vTaskMissedYield+0x8>)
    1a6c:	601a      	str	r2, [r3, #0]
}
    1a6e:	4770      	bx	lr
    1a70:	20002ab4 	.word	0x20002ab4

00001a74 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
    1a74:	4b06      	ldr	r3, [pc, #24]	; (1a90 <xTaskGetSchedulerState+0x1c>)
    1a76:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    1a78:	2b00      	cmp	r3, #0
    1a7a:	d005      	beq.n	1a88 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1a7c:	4b04      	ldr	r3, [pc, #16]	; (1a90 <xTaskGetSchedulerState+0x1c>)
    1a7e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1a80:	2b00      	cmp	r3, #0
    1a82:	d103      	bne.n	1a8c <xTaskGetSchedulerState+0x18>
				xReturn = taskSCHEDULER_RUNNING;
    1a84:	2002      	movs	r0, #2
	}
    1a86:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
    1a88:	2001      	movs	r0, #1
    1a8a:	e7fc      	b.n	1a86 <xTaskGetSchedulerState+0x12>
				xReturn = taskSCHEDULER_SUSPENDED;
    1a8c:	2000      	movs	r0, #0
		return xReturn;
    1a8e:	e7fa      	b.n	1a86 <xTaskGetSchedulerState+0x12>
    1a90:	20002a34 	.word	0x20002a34

00001a94 <xTaskPriorityDisinherit>:
	{
    1a94:	b570      	push	{r4, r5, r6, lr}
    1a96:	1e04      	subs	r4, r0, #0
		if( pxMutexHolder != NULL )
    1a98:	d02c      	beq.n	1af4 <xTaskPriorityDisinherit+0x60>
			configASSERT( pxTCB == pxCurrentTCB );
    1a9a:	4b19      	ldr	r3, [pc, #100]	; (1b00 <xTaskPriorityDisinherit+0x6c>)
    1a9c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1a9e:	4298      	cmp	r0, r3
    1aa0:	d001      	beq.n	1aa6 <xTaskPriorityDisinherit+0x12>
    1aa2:	b672      	cpsid	i
    1aa4:	e7fe      	b.n	1aa4 <xTaskPriorityDisinherit+0x10>
			configASSERT( pxTCB->uxMutexesHeld );
    1aa6:	6c83      	ldr	r3, [r0, #72]	; 0x48
    1aa8:	2b00      	cmp	r3, #0
    1aaa:	d101      	bne.n	1ab0 <xTaskPriorityDisinherit+0x1c>
    1aac:	b672      	cpsid	i
    1aae:	e7fe      	b.n	1aae <xTaskPriorityDisinherit+0x1a>
			( pxTCB->uxMutexesHeld )--;
    1ab0:	3b01      	subs	r3, #1
    1ab2:	6483      	str	r3, [r0, #72]	; 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1ab4:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    1ab6:	6c41      	ldr	r1, [r0, #68]	; 0x44
    1ab8:	428a      	cmp	r2, r1
    1aba:	d01d      	beq.n	1af8 <xTaskPriorityDisinherit+0x64>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1abc:	2b00      	cmp	r3, #0
    1abe:	d11d      	bne.n	1afc <xTaskPriorityDisinherit+0x68>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1ac0:	1d05      	adds	r5, r0, #4
    1ac2:	0028      	movs	r0, r5
    1ac4:	4b0f      	ldr	r3, [pc, #60]	; (1b04 <xTaskPriorityDisinherit+0x70>)
    1ac6:	4798      	blx	r3
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1ac8:	6c63      	ldr	r3, [r4, #68]	; 0x44
    1aca:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1acc:	2205      	movs	r2, #5
    1ace:	1ad2      	subs	r2, r2, r3
    1ad0:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
    1ad2:	4a0b      	ldr	r2, [pc, #44]	; (1b00 <xTaskPriorityDisinherit+0x6c>)
    1ad4:	6e52      	ldr	r2, [r2, #100]	; 0x64
    1ad6:	4293      	cmp	r3, r2
    1ad8:	d901      	bls.n	1ade <xTaskPriorityDisinherit+0x4a>
    1ada:	4a09      	ldr	r2, [pc, #36]	; (1b00 <xTaskPriorityDisinherit+0x6c>)
    1adc:	6653      	str	r3, [r2, #100]	; 0x64
    1ade:	009a      	lsls	r2, r3, #2
    1ae0:	18d3      	adds	r3, r2, r3
    1ae2:	009a      	lsls	r2, r3, #2
    1ae4:	4808      	ldr	r0, [pc, #32]	; (1b08 <xTaskPriorityDisinherit+0x74>)
    1ae6:	3030      	adds	r0, #48	; 0x30
    1ae8:	1880      	adds	r0, r0, r2
    1aea:	0029      	movs	r1, r5
    1aec:	4b07      	ldr	r3, [pc, #28]	; (1b0c <xTaskPriorityDisinherit+0x78>)
    1aee:	4798      	blx	r3
					xReturn = pdTRUE;
    1af0:	2001      	movs	r0, #1
	}
    1af2:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t xReturn = pdFALSE;
    1af4:	2000      	movs	r0, #0
    1af6:	e7fc      	b.n	1af2 <xTaskPriorityDisinherit+0x5e>
    1af8:	2000      	movs	r0, #0
    1afa:	e7fa      	b.n	1af2 <xTaskPriorityDisinherit+0x5e>
    1afc:	2000      	movs	r0, #0
		return xReturn;
    1afe:	e7f8      	b.n	1af2 <xTaskPriorityDisinherit+0x5e>
    1b00:	20002a34 	.word	0x20002a34
    1b04:	0000075d 	.word	0x0000075d
    1b08:	200029b4 	.word	0x200029b4
    1b0c:	00000715 	.word	0x00000715

00001b10 <prvGetNextExpireTime>:
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1b10:	4b07      	ldr	r3, [pc, #28]	; (1b30 <prvGetNextExpireTime+0x20>)
    1b12:	681a      	ldr	r2, [r3, #0]
    1b14:	6813      	ldr	r3, [r2, #0]
    1b16:	2b00      	cmp	r3, #0
    1b18:	d106      	bne.n	1b28 <prvGetNextExpireTime+0x18>
    1b1a:	3301      	adds	r3, #1
    1b1c:	6003      	str	r3, [r0, #0]
	if( *pxListWasEmpty == pdFALSE )
    1b1e:	2b00      	cmp	r3, #0
    1b20:	d104      	bne.n	1b2c <prvGetNextExpireTime+0x1c>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1b22:	68d3      	ldr	r3, [r2, #12]
    1b24:	6818      	ldr	r0, [r3, #0]
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
	}

	return xNextExpireTime;
}
    1b26:	4770      	bx	lr
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    1b28:	2300      	movs	r3, #0
    1b2a:	e7f7      	b.n	1b1c <prvGetNextExpireTime+0xc>
		xNextExpireTime = ( TickType_t ) 0U;
    1b2c:	2000      	movs	r0, #0
	return xNextExpireTime;
    1b2e:	e7fa      	b.n	1b26 <prvGetNextExpireTime+0x16>
    1b30:	20002ab8 	.word	0x20002ab8

00001b34 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    1b34:	b510      	push	{r4, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    1b36:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1b38:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
    1b3a:	4291      	cmp	r1, r2
    1b3c:	d80c      	bhi.n	1b58 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b3e:	1ad2      	subs	r2, r2, r3
    1b40:	6983      	ldr	r3, [r0, #24]
    1b42:	429a      	cmp	r2, r3
    1b44:	d301      	bcc.n	1b4a <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    1b46:	2001      	movs	r0, #1
    1b48:	e010      	b.n	1b6c <prvInsertTimerInActiveList+0x38>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    1b4a:	1d01      	adds	r1, r0, #4
    1b4c:	4b09      	ldr	r3, [pc, #36]	; (1b74 <prvInsertTimerInActiveList+0x40>)
    1b4e:	6858      	ldr	r0, [r3, #4]
    1b50:	4b09      	ldr	r3, [pc, #36]	; (1b78 <prvInsertTimerInActiveList+0x44>)
    1b52:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1b54:	2000      	movs	r0, #0
    1b56:	e009      	b.n	1b6c <prvInsertTimerInActiveList+0x38>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    1b58:	429a      	cmp	r2, r3
    1b5a:	d201      	bcs.n	1b60 <prvInsertTimerInActiveList+0x2c>
    1b5c:	4299      	cmp	r1, r3
    1b5e:	d206      	bcs.n	1b6e <prvInsertTimerInActiveList+0x3a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1b60:	1d01      	adds	r1, r0, #4
    1b62:	4b04      	ldr	r3, [pc, #16]	; (1b74 <prvInsertTimerInActiveList+0x40>)
    1b64:	6818      	ldr	r0, [r3, #0]
    1b66:	4b04      	ldr	r3, [pc, #16]	; (1b78 <prvInsertTimerInActiveList+0x44>)
    1b68:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
    1b6a:	2000      	movs	r0, #0
		}
	}

	return xProcessTimerNow;
}
    1b6c:	bd10      	pop	{r4, pc}
			xProcessTimerNow = pdTRUE;
    1b6e:	2001      	movs	r0, #1
	return xProcessTimerNow;
    1b70:	e7fc      	b.n	1b6c <prvInsertTimerInActiveList+0x38>
    1b72:	46c0      	nop			; (mov r8, r8)
    1b74:	20002ab8 	.word	0x20002ab8
    1b78:	0000072d 	.word	0x0000072d

00001b7c <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    1b7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    1b7e:	4b10      	ldr	r3, [pc, #64]	; (1bc0 <prvCheckForValidListAndQueue+0x44>)
    1b80:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
    1b82:	4b10      	ldr	r3, [pc, #64]	; (1bc4 <prvCheckForValidListAndQueue+0x48>)
    1b84:	689b      	ldr	r3, [r3, #8]
    1b86:	2b00      	cmp	r3, #0
    1b88:	d002      	beq.n	1b90 <prvCheckForValidListAndQueue+0x14>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1b8a:	4b0f      	ldr	r3, [pc, #60]	; (1bc8 <prvCheckForValidListAndQueue+0x4c>)
    1b8c:	4798      	blx	r3
}
    1b8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise( &xActiveTimerList1 );
    1b90:	4c0c      	ldr	r4, [pc, #48]	; (1bc4 <prvCheckForValidListAndQueue+0x48>)
    1b92:	0026      	movs	r6, r4
    1b94:	360c      	adds	r6, #12
    1b96:	0030      	movs	r0, r6
    1b98:	4f0c      	ldr	r7, [pc, #48]	; (1bcc <prvCheckForValidListAndQueue+0x50>)
    1b9a:	47b8      	blx	r7
			vListInitialise( &xActiveTimerList2 );
    1b9c:	0025      	movs	r5, r4
    1b9e:	3520      	adds	r5, #32
    1ba0:	0028      	movs	r0, r5
    1ba2:	47b8      	blx	r7
			pxCurrentTimerList = &xActiveTimerList1;
    1ba4:	6026      	str	r6, [r4, #0]
			pxOverflowTimerList = &xActiveTimerList2;
    1ba6:	6065      	str	r5, [r4, #4]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    1ba8:	2200      	movs	r2, #0
    1baa:	210c      	movs	r1, #12
    1bac:	2005      	movs	r0, #5
    1bae:	4b08      	ldr	r3, [pc, #32]	; (1bd0 <prvCheckForValidListAndQueue+0x54>)
    1bb0:	4798      	blx	r3
    1bb2:	60a0      	str	r0, [r4, #8]
				if( xTimerQueue != NULL )
    1bb4:	2800      	cmp	r0, #0
    1bb6:	d0e8      	beq.n	1b8a <prvCheckForValidListAndQueue+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
    1bb8:	4906      	ldr	r1, [pc, #24]	; (1bd4 <prvCheckForValidListAndQueue+0x58>)
    1bba:	4b07      	ldr	r3, [pc, #28]	; (1bd8 <prvCheckForValidListAndQueue+0x5c>)
    1bbc:	4798      	blx	r3
    1bbe:	e7e4      	b.n	1b8a <prvCheckForValidListAndQueue+0xe>
    1bc0:	00000a61 	.word	0x00000a61
    1bc4:	20002ab8 	.word	0x20002ab8
    1bc8:	00000a79 	.word	0x00000a79
    1bcc:	000006f9 	.word	0x000006f9
    1bd0:	00000dd9 	.word	0x00000dd9
    1bd4:	00003b40 	.word	0x00003b40
    1bd8:	00001205 	.word	0x00001205

00001bdc <xTimerCreateTimerTask>:
{
    1bdc:	b510      	push	{r4, lr}
    1bde:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    1be0:	4b0c      	ldr	r3, [pc, #48]	; (1c14 <xTimerCreateTimerTask+0x38>)
    1be2:	4798      	blx	r3
	if( xTimerQueue != NULL )
    1be4:	4b0c      	ldr	r3, [pc, #48]	; (1c18 <xTimerCreateTimerTask+0x3c>)
    1be6:	689b      	ldr	r3, [r3, #8]
    1be8:	2b00      	cmp	r3, #0
    1bea:	d00e      	beq.n	1c0a <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
    1bec:	4b0a      	ldr	r3, [pc, #40]	; (1c18 <xTimerCreateTimerTask+0x3c>)
    1bee:	3334      	adds	r3, #52	; 0x34
    1bf0:	9301      	str	r3, [sp, #4]
    1bf2:	2302      	movs	r3, #2
    1bf4:	9300      	str	r3, [sp, #0]
    1bf6:	2300      	movs	r3, #0
    1bf8:	2250      	movs	r2, #80	; 0x50
    1bfa:	4908      	ldr	r1, [pc, #32]	; (1c1c <xTimerCreateTimerTask+0x40>)
    1bfc:	4808      	ldr	r0, [pc, #32]	; (1c20 <xTimerCreateTimerTask+0x44>)
    1bfe:	4c09      	ldr	r4, [pc, #36]	; (1c24 <xTimerCreateTimerTask+0x48>)
    1c00:	47a0      	blx	r4
	configASSERT( xReturn );
    1c02:	2800      	cmp	r0, #0
    1c04:	d103      	bne.n	1c0e <xTimerCreateTimerTask+0x32>
    1c06:	b672      	cpsid	i
    1c08:	e7fe      	b.n	1c08 <xTimerCreateTimerTask+0x2c>
BaseType_t xReturn = pdFAIL;
    1c0a:	2000      	movs	r0, #0
    1c0c:	e7f9      	b.n	1c02 <xTimerCreateTimerTask+0x26>
}
    1c0e:	b002      	add	sp, #8
    1c10:	bd10      	pop	{r4, pc}
    1c12:	46c0      	nop			; (mov r8, r8)
    1c14:	00001b7d 	.word	0x00001b7d
    1c18:	20002ab8 	.word	0x20002ab8
    1c1c:	00003b48 	.word	0x00003b48
    1c20:	00001f21 	.word	0x00001f21
    1c24:	00001551 	.word	0x00001551

00001c28 <xTimerGenericCommand>:
{
    1c28:	b530      	push	{r4, r5, lr}
    1c2a:	b085      	sub	sp, #20
    1c2c:	0004      	movs	r4, r0
    1c2e:	001d      	movs	r5, r3
	configASSERT( xTimer );
    1c30:	2800      	cmp	r0, #0
    1c32:	d014      	beq.n	1c5e <xTimerGenericCommand+0x36>
	if( xTimerQueue != NULL )
    1c34:	4b13      	ldr	r3, [pc, #76]	; (1c84 <xTimerGenericCommand+0x5c>)
    1c36:	6898      	ldr	r0, [r3, #8]
    1c38:	2800      	cmp	r0, #0
    1c3a:	d021      	beq.n	1c80 <xTimerGenericCommand+0x58>
		xMessage.xMessageID = xCommandID;
    1c3c:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    1c3e:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    1c40:	9403      	str	r4, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    1c42:	2905      	cmp	r1, #5
    1c44:	dc15      	bgt.n	1c72 <xTimerGenericCommand+0x4a>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    1c46:	4b10      	ldr	r3, [pc, #64]	; (1c88 <xTimerGenericCommand+0x60>)
    1c48:	4798      	blx	r3
    1c4a:	2802      	cmp	r0, #2
    1c4c:	d009      	beq.n	1c62 <xTimerGenericCommand+0x3a>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    1c4e:	4b0d      	ldr	r3, [pc, #52]	; (1c84 <xTimerGenericCommand+0x5c>)
    1c50:	6898      	ldr	r0, [r3, #8]
    1c52:	2300      	movs	r3, #0
    1c54:	2200      	movs	r2, #0
    1c56:	a901      	add	r1, sp, #4
    1c58:	4c0c      	ldr	r4, [pc, #48]	; (1c8c <xTimerGenericCommand+0x64>)
    1c5a:	47a0      	blx	r4
    1c5c:	e00e      	b.n	1c7c <xTimerGenericCommand+0x54>
	configASSERT( xTimer );
    1c5e:	b672      	cpsid	i
    1c60:	e7fe      	b.n	1c60 <xTimerGenericCommand+0x38>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    1c62:	4b08      	ldr	r3, [pc, #32]	; (1c84 <xTimerGenericCommand+0x5c>)
    1c64:	6898      	ldr	r0, [r3, #8]
    1c66:	2300      	movs	r3, #0
    1c68:	9a08      	ldr	r2, [sp, #32]
    1c6a:	a901      	add	r1, sp, #4
    1c6c:	4c07      	ldr	r4, [pc, #28]	; (1c8c <xTimerGenericCommand+0x64>)
    1c6e:	47a0      	blx	r4
    1c70:	e004      	b.n	1c7c <xTimerGenericCommand+0x54>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    1c72:	2300      	movs	r3, #0
    1c74:	002a      	movs	r2, r5
    1c76:	a901      	add	r1, sp, #4
    1c78:	4c05      	ldr	r4, [pc, #20]	; (1c90 <xTimerGenericCommand+0x68>)
    1c7a:	47a0      	blx	r4
}
    1c7c:	b005      	add	sp, #20
    1c7e:	bd30      	pop	{r4, r5, pc}
BaseType_t xReturn = pdFAIL;
    1c80:	2000      	movs	r0, #0
	return xReturn;
    1c82:	e7fb      	b.n	1c7c <xTimerGenericCommand+0x54>
    1c84:	20002ab8 	.word	0x20002ab8
    1c88:	00001a75 	.word	0x00001a75
    1c8c:	00000e21 	.word	0x00000e21
    1c90:	00000fbd 	.word	0x00000fbd

00001c94 <prvSwitchTimerLists>:
{
    1c94:	b570      	push	{r4, r5, r6, lr}
    1c96:	b082      	sub	sp, #8
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    1c98:	4b17      	ldr	r3, [pc, #92]	; (1cf8 <prvSwitchTimerLists+0x64>)
    1c9a:	681b      	ldr	r3, [r3, #0]
    1c9c:	681a      	ldr	r2, [r3, #0]
    1c9e:	2a00      	cmp	r2, #0
    1ca0:	d024      	beq.n	1cec <prvSwitchTimerLists+0x58>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    1ca2:	68db      	ldr	r3, [r3, #12]
    1ca4:	681e      	ldr	r6, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1ca6:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1ca8:	1d25      	adds	r5, r4, #4
    1caa:	0028      	movs	r0, r5
    1cac:	4b13      	ldr	r3, [pc, #76]	; (1cfc <prvSwitchTimerLists+0x68>)
    1cae:	4798      	blx	r3
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1cb0:	0020      	movs	r0, r4
    1cb2:	6a23      	ldr	r3, [r4, #32]
    1cb4:	4798      	blx	r3
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1cb6:	2328      	movs	r3, #40	; 0x28
    1cb8:	5ce3      	ldrb	r3, [r4, r3]
    1cba:	075b      	lsls	r3, r3, #29
    1cbc:	d5ec      	bpl.n	1c98 <prvSwitchTimerLists+0x4>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    1cbe:	69a3      	ldr	r3, [r4, #24]
    1cc0:	18f3      	adds	r3, r6, r3
			if( xReloadTime > xNextExpireTime )
    1cc2:	429e      	cmp	r6, r3
    1cc4:	d207      	bcs.n	1cd6 <prvSwitchTimerLists+0x42>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    1cc6:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    1cc8:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    1cca:	4b0b      	ldr	r3, [pc, #44]	; (1cf8 <prvSwitchTimerLists+0x64>)
    1ccc:	6818      	ldr	r0, [r3, #0]
    1cce:	0029      	movs	r1, r5
    1cd0:	4b0b      	ldr	r3, [pc, #44]	; (1d00 <prvSwitchTimerLists+0x6c>)
    1cd2:	4798      	blx	r3
    1cd4:	e7e0      	b.n	1c98 <prvSwitchTimerLists+0x4>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1cd6:	2300      	movs	r3, #0
    1cd8:	9300      	str	r3, [sp, #0]
    1cda:	0032      	movs	r2, r6
    1cdc:	2100      	movs	r1, #0
    1cde:	0020      	movs	r0, r4
    1ce0:	4c08      	ldr	r4, [pc, #32]	; (1d04 <prvSwitchTimerLists+0x70>)
    1ce2:	47a0      	blx	r4
				configASSERT( xResult );
    1ce4:	2800      	cmp	r0, #0
    1ce6:	d1d7      	bne.n	1c98 <prvSwitchTimerLists+0x4>
    1ce8:	b672      	cpsid	i
    1cea:	e7fe      	b.n	1cea <prvSwitchTimerLists+0x56>
	pxCurrentTimerList = pxOverflowTimerList;
    1cec:	4a02      	ldr	r2, [pc, #8]	; (1cf8 <prvSwitchTimerLists+0x64>)
    1cee:	6851      	ldr	r1, [r2, #4]
    1cf0:	6011      	str	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
    1cf2:	6053      	str	r3, [r2, #4]
}
    1cf4:	b002      	add	sp, #8
    1cf6:	bd70      	pop	{r4, r5, r6, pc}
    1cf8:	20002ab8 	.word	0x20002ab8
    1cfc:	0000075d 	.word	0x0000075d
    1d00:	0000072d 	.word	0x0000072d
    1d04:	00001c29 	.word	0x00001c29

00001d08 <prvSampleTimeNow>:
{
    1d08:	b570      	push	{r4, r5, r6, lr}
    1d0a:	0005      	movs	r5, r0
	xTimeNow = xTaskGetTickCount();
    1d0c:	4b08      	ldr	r3, [pc, #32]	; (1d30 <prvSampleTimeNow+0x28>)
    1d0e:	4798      	blx	r3
    1d10:	0004      	movs	r4, r0
	if( xTimeNow < xLastTime )
    1d12:	4b08      	ldr	r3, [pc, #32]	; (1d34 <prvSampleTimeNow+0x2c>)
    1d14:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1d16:	4298      	cmp	r0, r3
    1d18:	d305      	bcc.n	1d26 <prvSampleTimeNow+0x1e>
		*pxTimerListsWereSwitched = pdFALSE;
    1d1a:	2300      	movs	r3, #0
    1d1c:	602b      	str	r3, [r5, #0]
	xLastTime = xTimeNow;
    1d1e:	4b05      	ldr	r3, [pc, #20]	; (1d34 <prvSampleTimeNow+0x2c>)
    1d20:	639c      	str	r4, [r3, #56]	; 0x38
}
    1d22:	0020      	movs	r0, r4
    1d24:	bd70      	pop	{r4, r5, r6, pc}
		prvSwitchTimerLists();
    1d26:	4b04      	ldr	r3, [pc, #16]	; (1d38 <prvSampleTimeNow+0x30>)
    1d28:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
    1d2a:	2301      	movs	r3, #1
    1d2c:	602b      	str	r3, [r5, #0]
    1d2e:	e7f6      	b.n	1d1e <prvSampleTimeNow+0x16>
    1d30:	00001639 	.word	0x00001639
    1d34:	20002ab8 	.word	0x20002ab8
    1d38:	00001c95 	.word	0x00001c95

00001d3c <prvProcessExpiredTimer>:
{
    1d3c:	b570      	push	{r4, r5, r6, lr}
    1d3e:	b082      	sub	sp, #8
    1d40:	0005      	movs	r5, r0
    1d42:	000e      	movs	r6, r1
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    1d44:	4b13      	ldr	r3, [pc, #76]	; (1d94 <prvProcessExpiredTimer+0x58>)
    1d46:	681b      	ldr	r3, [r3, #0]
    1d48:	68db      	ldr	r3, [r3, #12]
    1d4a:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1d4c:	1d20      	adds	r0, r4, #4
    1d4e:	4b12      	ldr	r3, [pc, #72]	; (1d98 <prvProcessExpiredTimer+0x5c>)
    1d50:	4798      	blx	r3
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1d52:	2328      	movs	r3, #40	; 0x28
    1d54:	5ce3      	ldrb	r3, [r4, r3]
    1d56:	075a      	lsls	r2, r3, #29
    1d58:	d408      	bmi.n	1d6c <prvProcessExpiredTimer+0x30>
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1d5a:	2201      	movs	r2, #1
    1d5c:	4393      	bics	r3, r2
    1d5e:	3227      	adds	r2, #39	; 0x27
    1d60:	54a3      	strb	r3, [r4, r2]
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1d62:	6a23      	ldr	r3, [r4, #32]
    1d64:	0020      	movs	r0, r4
    1d66:	4798      	blx	r3
}
    1d68:	b002      	add	sp, #8
    1d6a:	bd70      	pop	{r4, r5, r6, pc}
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    1d6c:	69a3      	ldr	r3, [r4, #24]
    1d6e:	1959      	adds	r1, r3, r5
    1d70:	002b      	movs	r3, r5
    1d72:	0032      	movs	r2, r6
    1d74:	0020      	movs	r0, r4
    1d76:	4e09      	ldr	r6, [pc, #36]	; (1d9c <prvProcessExpiredTimer+0x60>)
    1d78:	47b0      	blx	r6
    1d7a:	2800      	cmp	r0, #0
    1d7c:	d0f1      	beq.n	1d62 <prvProcessExpiredTimer+0x26>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    1d7e:	2300      	movs	r3, #0
    1d80:	9300      	str	r3, [sp, #0]
    1d82:	002a      	movs	r2, r5
    1d84:	2100      	movs	r1, #0
    1d86:	0020      	movs	r0, r4
    1d88:	4d05      	ldr	r5, [pc, #20]	; (1da0 <prvProcessExpiredTimer+0x64>)
    1d8a:	47a8      	blx	r5
			configASSERT( xResult );
    1d8c:	2800      	cmp	r0, #0
    1d8e:	d1e8      	bne.n	1d62 <prvProcessExpiredTimer+0x26>
    1d90:	b672      	cpsid	i
    1d92:	e7fe      	b.n	1d92 <prvProcessExpiredTimer+0x56>
    1d94:	20002ab8 	.word	0x20002ab8
    1d98:	0000075d 	.word	0x0000075d
    1d9c:	00001b35 	.word	0x00001b35
    1da0:	00001c29 	.word	0x00001c29

00001da4 <prvProcessTimerOrBlockTask>:
{
    1da4:	b570      	push	{r4, r5, r6, lr}
    1da6:	b082      	sub	sp, #8
    1da8:	0004      	movs	r4, r0
    1daa:	000d      	movs	r5, r1
	vTaskSuspendAll();
    1dac:	4b17      	ldr	r3, [pc, #92]	; (1e0c <prvProcessTimerOrBlockTask+0x68>)
    1dae:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1db0:	a801      	add	r0, sp, #4
    1db2:	4b17      	ldr	r3, [pc, #92]	; (1e10 <prvProcessTimerOrBlockTask+0x6c>)
    1db4:	4798      	blx	r3
    1db6:	0006      	movs	r6, r0
		if( xTimerListsWereSwitched == pdFALSE )
    1db8:	9b01      	ldr	r3, [sp, #4]
    1dba:	2b00      	cmp	r3, #0
    1dbc:	d123      	bne.n	1e06 <prvProcessTimerOrBlockTask+0x62>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    1dbe:	2d00      	cmp	r5, #0
    1dc0:	d101      	bne.n	1dc6 <prvProcessTimerOrBlockTask+0x22>
    1dc2:	42a0      	cmp	r0, r4
    1dc4:	d213      	bcs.n	1dee <prvProcessTimerOrBlockTask+0x4a>
				if( xListWasEmpty != pdFALSE )
    1dc6:	2d00      	cmp	r5, #0
    1dc8:	d005      	beq.n	1dd6 <prvProcessTimerOrBlockTask+0x32>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1dca:	4b12      	ldr	r3, [pc, #72]	; (1e14 <prvProcessTimerOrBlockTask+0x70>)
    1dcc:	685b      	ldr	r3, [r3, #4]
    1dce:	681b      	ldr	r3, [r3, #0]
    1dd0:	2b00      	cmp	r3, #0
    1dd2:	d113      	bne.n	1dfc <prvProcessTimerOrBlockTask+0x58>
    1dd4:	2501      	movs	r5, #1
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    1dd6:	1ba1      	subs	r1, r4, r6
    1dd8:	4b0e      	ldr	r3, [pc, #56]	; (1e14 <prvProcessTimerOrBlockTask+0x70>)
    1dda:	6898      	ldr	r0, [r3, #8]
    1ddc:	002a      	movs	r2, r5
    1dde:	4b0e      	ldr	r3, [pc, #56]	; (1e18 <prvProcessTimerOrBlockTask+0x74>)
    1de0:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
    1de2:	4b0e      	ldr	r3, [pc, #56]	; (1e1c <prvProcessTimerOrBlockTask+0x78>)
    1de4:	4798      	blx	r3
    1de6:	2800      	cmp	r0, #0
    1de8:	d00a      	beq.n	1e00 <prvProcessTimerOrBlockTask+0x5c>
}
    1dea:	b002      	add	sp, #8
    1dec:	bd70      	pop	{r4, r5, r6, pc}
				( void ) xTaskResumeAll();
    1dee:	4b0b      	ldr	r3, [pc, #44]	; (1e1c <prvProcessTimerOrBlockTask+0x78>)
    1df0:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    1df2:	0031      	movs	r1, r6
    1df4:	0020      	movs	r0, r4
    1df6:	4b0a      	ldr	r3, [pc, #40]	; (1e20 <prvProcessTimerOrBlockTask+0x7c>)
    1df8:	4798      	blx	r3
    1dfa:	e7f6      	b.n	1dea <prvProcessTimerOrBlockTask+0x46>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    1dfc:	2500      	movs	r5, #0
    1dfe:	e7ea      	b.n	1dd6 <prvProcessTimerOrBlockTask+0x32>
					portYIELD_WITHIN_API();
    1e00:	4b08      	ldr	r3, [pc, #32]	; (1e24 <prvProcessTimerOrBlockTask+0x80>)
    1e02:	4798      	blx	r3
    1e04:	e7f1      	b.n	1dea <prvProcessTimerOrBlockTask+0x46>
			( void ) xTaskResumeAll();
    1e06:	4b05      	ldr	r3, [pc, #20]	; (1e1c <prvProcessTimerOrBlockTask+0x78>)
    1e08:	4798      	blx	r3
}
    1e0a:	e7ee      	b.n	1dea <prvProcessTimerOrBlockTask+0x46>
    1e0c:	00001629 	.word	0x00001629
    1e10:	00001d09 	.word	0x00001d09
    1e14:	20002ab8 	.word	0x20002ab8
    1e18:	00001229 	.word	0x00001229
    1e1c:	00001745 	.word	0x00001745
    1e20:	00001d3d 	.word	0x00001d3d
    1e24:	00000a49 	.word	0x00000a49

00001e28 <prvProcessReceivedCommands>:
{
    1e28:	b530      	push	{r4, r5, lr}
    1e2a:	b087      	sub	sp, #28
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    1e2c:	4b34      	ldr	r3, [pc, #208]	; (1f00 <prvProcessReceivedCommands+0xd8>)
    1e2e:	6898      	ldr	r0, [r3, #8]
    1e30:	2200      	movs	r2, #0
    1e32:	a903      	add	r1, sp, #12
    1e34:	4b33      	ldr	r3, [pc, #204]	; (1f04 <prvProcessReceivedCommands+0xdc>)
    1e36:	4798      	blx	r3
    1e38:	2800      	cmp	r0, #0
    1e3a:	d05f      	beq.n	1efc <prvProcessReceivedCommands+0xd4>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    1e3c:	9b03      	ldr	r3, [sp, #12]
    1e3e:	2b00      	cmp	r3, #0
    1e40:	dbf4      	blt.n	1e2c <prvProcessReceivedCommands+0x4>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    1e42:	9c05      	ldr	r4, [sp, #20]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    1e44:	6963      	ldr	r3, [r4, #20]
    1e46:	2b00      	cmp	r3, #0
    1e48:	d002      	beq.n	1e50 <prvProcessReceivedCommands+0x28>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    1e4a:	1d20      	adds	r0, r4, #4
    1e4c:	4b2e      	ldr	r3, [pc, #184]	; (1f08 <prvProcessReceivedCommands+0xe0>)
    1e4e:	4798      	blx	r3
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    1e50:	a802      	add	r0, sp, #8
    1e52:	4b2e      	ldr	r3, [pc, #184]	; (1f0c <prvProcessReceivedCommands+0xe4>)
    1e54:	4798      	blx	r3
			switch( xMessage.xMessageID )
    1e56:	9b03      	ldr	r3, [sp, #12]
    1e58:	2b09      	cmp	r3, #9
    1e5a:	d8e7      	bhi.n	1e2c <prvProcessReceivedCommands+0x4>
    1e5c:	009b      	lsls	r3, r3, #2
    1e5e:	4a2c      	ldr	r2, [pc, #176]	; (1f10 <prvProcessReceivedCommands+0xe8>)
    1e60:	58d3      	ldr	r3, [r2, r3]
    1e62:	469f      	mov	pc, r3
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    1e64:	2228      	movs	r2, #40	; 0x28
    1e66:	5ca3      	ldrb	r3, [r4, r2]
    1e68:	2101      	movs	r1, #1
    1e6a:	430b      	orrs	r3, r1
    1e6c:	54a3      	strb	r3, [r4, r2]
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    1e6e:	9b04      	ldr	r3, [sp, #16]
    1e70:	69a2      	ldr	r2, [r4, #24]
    1e72:	4694      	mov	ip, r2
    1e74:	4463      	add	r3, ip
    1e76:	0019      	movs	r1, r3
    1e78:	9b04      	ldr	r3, [sp, #16]
    1e7a:	0002      	movs	r2, r0
    1e7c:	0020      	movs	r0, r4
    1e7e:	4d25      	ldr	r5, [pc, #148]	; (1f14 <prvProcessReceivedCommands+0xec>)
    1e80:	47a8      	blx	r5
    1e82:	2800      	cmp	r0, #0
    1e84:	d0d2      	beq.n	1e2c <prvProcessReceivedCommands+0x4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    1e86:	0020      	movs	r0, r4
    1e88:	6a23      	ldr	r3, [r4, #32]
    1e8a:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    1e8c:	2328      	movs	r3, #40	; 0x28
    1e8e:	5ce3      	ldrb	r3, [r4, r3]
    1e90:	075b      	lsls	r3, r3, #29
    1e92:	d5cb      	bpl.n	1e2c <prvProcessReceivedCommands+0x4>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    1e94:	9b04      	ldr	r3, [sp, #16]
    1e96:	69a1      	ldr	r1, [r4, #24]
    1e98:	468c      	mov	ip, r1
    1e9a:	4463      	add	r3, ip
    1e9c:	001a      	movs	r2, r3
    1e9e:	2300      	movs	r3, #0
    1ea0:	9300      	str	r3, [sp, #0]
    1ea2:	2100      	movs	r1, #0
    1ea4:	0020      	movs	r0, r4
    1ea6:	4c1c      	ldr	r4, [pc, #112]	; (1f18 <prvProcessReceivedCommands+0xf0>)
    1ea8:	47a0      	blx	r4
							configASSERT( xResult );
    1eaa:	2800      	cmp	r0, #0
    1eac:	d1be      	bne.n	1e2c <prvProcessReceivedCommands+0x4>
    1eae:	b672      	cpsid	i
    1eb0:	e7fe      	b.n	1eb0 <prvProcessReceivedCommands+0x88>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1eb2:	2228      	movs	r2, #40	; 0x28
    1eb4:	5ca3      	ldrb	r3, [r4, r2]
    1eb6:	2101      	movs	r1, #1
    1eb8:	438b      	bics	r3, r1
    1eba:	54a3      	strb	r3, [r4, r2]
					break;
    1ebc:	e7b6      	b.n	1e2c <prvProcessReceivedCommands+0x4>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    1ebe:	2228      	movs	r2, #40	; 0x28
    1ec0:	5ca3      	ldrb	r3, [r4, r2]
    1ec2:	2101      	movs	r1, #1
    1ec4:	430b      	orrs	r3, r1
    1ec6:	54a3      	strb	r3, [r4, r2]
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    1ec8:	9904      	ldr	r1, [sp, #16]
    1eca:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1ecc:	2900      	cmp	r1, #0
    1ece:	d006      	beq.n	1ede <prvProcessReceivedCommands+0xb6>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    1ed0:	1841      	adds	r1, r0, r1
    1ed2:	0003      	movs	r3, r0
    1ed4:	0002      	movs	r2, r0
    1ed6:	0020      	movs	r0, r4
    1ed8:	4c0e      	ldr	r4, [pc, #56]	; (1f14 <prvProcessReceivedCommands+0xec>)
    1eda:	47a0      	blx	r4
					break;
    1edc:	e7a6      	b.n	1e2c <prvProcessReceivedCommands+0x4>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    1ede:	b672      	cpsid	i
    1ee0:	e7fe      	b.n	1ee0 <prvProcessReceivedCommands+0xb8>
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    1ee2:	2328      	movs	r3, #40	; 0x28
    1ee4:	5ce3      	ldrb	r3, [r4, r3]
    1ee6:	079a      	lsls	r2, r3, #30
    1ee8:	d504      	bpl.n	1ef4 <prvProcessReceivedCommands+0xcc>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    1eea:	2201      	movs	r2, #1
    1eec:	4393      	bics	r3, r2
    1eee:	3227      	adds	r2, #39	; 0x27
    1ef0:	54a3      	strb	r3, [r4, r2]
    1ef2:	e79b      	b.n	1e2c <prvProcessReceivedCommands+0x4>
							vPortFree( pxTimer );
    1ef4:	0020      	movs	r0, r4
    1ef6:	4b09      	ldr	r3, [pc, #36]	; (1f1c <prvProcessReceivedCommands+0xf4>)
    1ef8:	4798      	blx	r3
    1efa:	e797      	b.n	1e2c <prvProcessReceivedCommands+0x4>
}
    1efc:	b007      	add	sp, #28
    1efe:	bd30      	pop	{r4, r5, pc}
    1f00:	20002ab8 	.word	0x20002ab8
    1f04:	000010a9 	.word	0x000010a9
    1f08:	0000075d 	.word	0x0000075d
    1f0c:	00001d09 	.word	0x00001d09
    1f10:	00003b18 	.word	0x00003b18
    1f14:	00001b35 	.word	0x00001b35
    1f18:	00001c29 	.word	0x00001c29
    1f1c:	000008fd 	.word	0x000008fd

00001f20 <prvTimerTask>:
{
    1f20:	b500      	push	{lr}
    1f22:	b083      	sub	sp, #12
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    1f24:	a801      	add	r0, sp, #4
    1f26:	4b04      	ldr	r3, [pc, #16]	; (1f38 <prvTimerTask+0x18>)
    1f28:	4798      	blx	r3
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    1f2a:	9901      	ldr	r1, [sp, #4]
    1f2c:	4b03      	ldr	r3, [pc, #12]	; (1f3c <prvTimerTask+0x1c>)
    1f2e:	4798      	blx	r3
		prvProcessReceivedCommands();
    1f30:	4b03      	ldr	r3, [pc, #12]	; (1f40 <prvTimerTask+0x20>)
    1f32:	4798      	blx	r3
    1f34:	e7f6      	b.n	1f24 <prvTimerTask+0x4>
    1f36:	46c0      	nop			; (mov r8, r8)
    1f38:	00001b11 	.word	0x00001b11
    1f3c:	00001da5 	.word	0x00001da5
    1f40:	00001e29 	.word	0x00001e29

00001f44 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    1f44:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
    1f48:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
    1f4a:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    1f4c:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
    1f50:	4770      	bx	lr

00001f52 <atomic_leave_critical>:
    1f52:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
    1f56:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    1f58:	f383 8810 	msr	PRIMASK, r3
}
    1f5c:	4770      	bx	lr

00001f5e <can_tx_done>:

/**
 * \internal Callback of CAN Message Write finished
 */
static void can_tx_done(struct _can_async_device *dev)
{
    1f5e:	b510      	push	{r4, lr}
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);

	if (descr->cb.tx_done) {
    1f60:	69c3      	ldr	r3, [r0, #28]
    1f62:	2b00      	cmp	r3, #0
    1f64:	d000      	beq.n	1f68 <can_tx_done+0xa>
		descr->cb.tx_done(descr);
    1f66:	4798      	blx	r3
	}
}
    1f68:	bd10      	pop	{r4, pc}

00001f6a <can_rx_done>:

/**
 * \internal Callback of CAN Message Read finished
 */
static void can_rx_done(struct _can_async_device *dev)
{
    1f6a:	b510      	push	{r4, lr}
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);

	if (descr->cb.rx_done) {
    1f6c:	6a03      	ldr	r3, [r0, #32]
    1f6e:	2b00      	cmp	r3, #0
    1f70:	d000      	beq.n	1f74 <can_rx_done+0xa>
		descr->cb.rx_done(descr);
    1f72:	4798      	blx	r3
	}
}
    1f74:	bd10      	pop	{r4, pc}

00001f76 <can_irq_handler>:

/**
 * \internal Callback of CAN Interrupt
 */
static void can_irq_handler(struct _can_async_device *dev, enum can_async_interrupt_type type)
{
    1f76:	b510      	push	{r4, lr}
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);

	if (descr->cb.irq_handler) {
    1f78:	6a43      	ldr	r3, [r0, #36]	; 0x24
    1f7a:	2b00      	cmp	r3, #0
    1f7c:	d000      	beq.n	1f80 <can_irq_handler+0xa>
		descr->cb.irq_handler(descr, type);
    1f7e:	4798      	blx	r3
	}
}
    1f80:	bd10      	pop	{r4, pc}
	...

00001f84 <can_async_init>:
{
    1f84:	b570      	push	{r4, r5, r6, lr}
    1f86:	0004      	movs	r4, r0
    1f88:	000d      	movs	r5, r1
	ASSERT(descr && hw);
    1f8a:	2800      	cmp	r0, #0
    1f8c:	d015      	beq.n	1fba <can_async_init+0x36>
    1f8e:	2900      	cmp	r1, #0
    1f90:	d011      	beq.n	1fb6 <can_async_init+0x32>
    1f92:	2001      	movs	r0, #1
    1f94:	2241      	movs	r2, #65	; 0x41
    1f96:	490a      	ldr	r1, [pc, #40]	; (1fc0 <can_async_init+0x3c>)
    1f98:	4b0a      	ldr	r3, [pc, #40]	; (1fc4 <can_async_init+0x40>)
    1f9a:	4798      	blx	r3
	rc = _can_async_init(&descr->dev, hw);
    1f9c:	0029      	movs	r1, r5
    1f9e:	0020      	movs	r0, r4
    1fa0:	4b09      	ldr	r3, [pc, #36]	; (1fc8 <can_async_init+0x44>)
    1fa2:	4798      	blx	r3
	if (rc) {
    1fa4:	2800      	cmp	r0, #0
    1fa6:	d105      	bne.n	1fb4 <can_async_init+0x30>
	descr->dev.cb.tx_done     = can_tx_done;
    1fa8:	4b08      	ldr	r3, [pc, #32]	; (1fcc <can_async_init+0x48>)
    1faa:	6063      	str	r3, [r4, #4]
	descr->dev.cb.rx_done     = can_rx_done;
    1fac:	4b08      	ldr	r3, [pc, #32]	; (1fd0 <can_async_init+0x4c>)
    1fae:	60a3      	str	r3, [r4, #8]
	descr->dev.cb.irq_handler = can_irq_handler;
    1fb0:	4b08      	ldr	r3, [pc, #32]	; (1fd4 <can_async_init+0x50>)
    1fb2:	60e3      	str	r3, [r4, #12]
}
    1fb4:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
    1fb6:	2000      	movs	r0, #0
    1fb8:	e7ec      	b.n	1f94 <can_async_init+0x10>
    1fba:	2000      	movs	r0, #0
    1fbc:	e7ea      	b.n	1f94 <can_async_init+0x10>
    1fbe:	46c0      	nop			; (mov r8, r8)
    1fc0:	00003b50 	.word	0x00003b50
    1fc4:	0000245d 	.word	0x0000245d
    1fc8:	000024c5 	.word	0x000024c5
    1fcc:	00001f5f 	.word	0x00001f5f
    1fd0:	00001f6b 	.word	0x00001f6b
    1fd4:	00001f77 	.word	0x00001f77

00001fd8 <can_async_enable>:
{
    1fd8:	b510      	push	{r4, lr}
    1fda:	0004      	movs	r4, r0
	ASSERT(descr);
    1fdc:	1e43      	subs	r3, r0, #1
    1fde:	4198      	sbcs	r0, r3
    1fe0:	b2c0      	uxtb	r0, r0
    1fe2:	225c      	movs	r2, #92	; 0x5c
    1fe4:	4903      	ldr	r1, [pc, #12]	; (1ff4 <can_async_enable+0x1c>)
    1fe6:	4b04      	ldr	r3, [pc, #16]	; (1ff8 <can_async_enable+0x20>)
    1fe8:	4798      	blx	r3
	return _can_async_enable(&descr->dev);
    1fea:	0020      	movs	r0, r4
    1fec:	4b03      	ldr	r3, [pc, #12]	; (1ffc <can_async_enable+0x24>)
    1fee:	4798      	blx	r3
}
    1ff0:	bd10      	pop	{r4, pc}
    1ff2:	46c0      	nop			; (mov r8, r8)
    1ff4:	00003b50 	.word	0x00003b50
    1ff8:	0000245d 	.word	0x0000245d
    1ffc:	000026ad 	.word	0x000026ad

00002000 <can_async_read>:
{
    2000:	b570      	push	{r4, r5, r6, lr}
    2002:	0004      	movs	r4, r0
    2004:	000d      	movs	r5, r1
	ASSERT(descr && msg);
    2006:	2800      	cmp	r0, #0
    2008:	d00d      	beq.n	2026 <STACK_SIZE+0x26>
    200a:	2900      	cmp	r1, #0
    200c:	d009      	beq.n	2022 <STACK_SIZE+0x22>
    200e:	2001      	movs	r0, #1
    2010:	226e      	movs	r2, #110	; 0x6e
    2012:	4906      	ldr	r1, [pc, #24]	; (202c <STACK_SIZE+0x2c>)
    2014:	4b06      	ldr	r3, [pc, #24]	; (2030 <STACK_SIZE+0x30>)
    2016:	4798      	blx	r3
	return _can_async_read(&descr->dev, msg);
    2018:	0029      	movs	r1, r5
    201a:	0020      	movs	r0, r4
    201c:	4b05      	ldr	r3, [pc, #20]	; (2034 <STACK_SIZE+0x34>)
    201e:	4798      	blx	r3
}
    2020:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && msg);
    2022:	2000      	movs	r0, #0
    2024:	e7f4      	b.n	2010 <can_async_read+0x10>
    2026:	2000      	movs	r0, #0
    2028:	e7f2      	b.n	2010 <can_async_read+0x10>
    202a:	46c0      	nop			; (mov r8, r8)
    202c:	00003b50 	.word	0x00003b50
    2030:	0000245d 	.word	0x0000245d
    2034:	000026bd 	.word	0x000026bd

00002038 <can_async_write>:
{
    2038:	b570      	push	{r4, r5, r6, lr}
    203a:	0004      	movs	r4, r0
    203c:	000d      	movs	r5, r1
	ASSERT(descr && msg);
    203e:	2800      	cmp	r0, #0
    2040:	d00d      	beq.n	205e <can_async_write+0x26>
    2042:	2900      	cmp	r1, #0
    2044:	d009      	beq.n	205a <can_async_write+0x22>
    2046:	2001      	movs	r0, #1
    2048:	2277      	movs	r2, #119	; 0x77
    204a:	4906      	ldr	r1, [pc, #24]	; (2064 <can_async_write+0x2c>)
    204c:	4b06      	ldr	r3, [pc, #24]	; (2068 <can_async_write+0x30>)
    204e:	4798      	blx	r3
	return _can_async_write(&descr->dev, msg);
    2050:	0029      	movs	r1, r5
    2052:	0020      	movs	r0, r4
    2054:	4b05      	ldr	r3, [pc, #20]	; (206c <can_async_write+0x34>)
    2056:	4798      	blx	r3
}
    2058:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && msg);
    205a:	2000      	movs	r0, #0
    205c:	e7f4      	b.n	2048 <can_async_write+0x10>
    205e:	2000      	movs	r0, #0
    2060:	e7f2      	b.n	2048 <can_async_write+0x10>
    2062:	46c0      	nop			; (mov r8, r8)
    2064:	00003b50 	.word	0x00003b50
    2068:	0000245d 	.word	0x0000245d
    206c:	00002799 	.word	0x00002799

00002070 <can_async_register_callback>:
{
    2070:	b570      	push	{r4, r5, r6, lr}
    2072:	0006      	movs	r6, r0
    2074:	000d      	movs	r5, r1
    2076:	0014      	movs	r4, r2
	ASSERT(descr);
    2078:	1e43      	subs	r3, r0, #1
    207a:	4198      	sbcs	r0, r3
    207c:	b2c0      	uxtb	r0, r0
    207e:	2281      	movs	r2, #129	; 0x81
    2080:	490c      	ldr	r1, [pc, #48]	; (20b4 <can_async_register_callback+0x44>)
    2082:	4b0d      	ldr	r3, [pc, #52]	; (20b8 <can_async_register_callback+0x48>)
    2084:	4798      	blx	r3
	switch (type) {
    2086:	2d01      	cmp	r5, #1
    2088:	d010      	beq.n	20ac <can_async_register_callback+0x3c>
    208a:	2d00      	cmp	r5, #0
    208c:	d004      	beq.n	2098 <can_async_register_callback+0x28>
    208e:	2d02      	cmp	r5, #2
    2090:	d00e      	beq.n	20b0 <can_async_register_callback+0x40>
		return ERR_INVALID_ARG;
    2092:	200d      	movs	r0, #13
    2094:	4240      	negs	r0, r0
    2096:	e008      	b.n	20aa <can_async_register_callback+0x3a>
		descr->cb.rx_done = (cb != NULL) ? (can_cb_t)cb : NULL;
    2098:	6234      	str	r4, [r6, #32]
	_can_async_set_irq_state(&descr->dev, type, NULL != cb);
    209a:	1e62      	subs	r2, r4, #1
    209c:	4194      	sbcs	r4, r2
    209e:	b2e2      	uxtb	r2, r4
    20a0:	0029      	movs	r1, r5
    20a2:	0030      	movs	r0, r6
    20a4:	4b05      	ldr	r3, [pc, #20]	; (20bc <can_async_register_callback+0x4c>)
    20a6:	4798      	blx	r3
	return ERR_NONE;
    20a8:	2000      	movs	r0, #0
}
    20aa:	bd70      	pop	{r4, r5, r6, pc}
		descr->cb.tx_done = (cb != NULL) ? (can_cb_t)cb : NULL;
    20ac:	61f4      	str	r4, [r6, #28]
		break;
    20ae:	e7f4      	b.n	209a <can_async_register_callback+0x2a>
		    = (cb != NULL) ? (void (*)(struct can_async_descriptor *const, enum can_async_interrupt_type))cb : NULL;
    20b0:	6274      	str	r4, [r6, #36]	; 0x24
		break;
    20b2:	e7f2      	b.n	209a <can_async_register_callback+0x2a>
    20b4:	00003b50 	.word	0x00003b50
    20b8:	0000245d 	.word	0x0000245d
    20bc:	0000290d 	.word	0x0000290d

000020c0 <can_async_set_filter>:
{
    20c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    20c2:	0004      	movs	r4, r0
    20c4:	000d      	movs	r5, r1
    20c6:	0016      	movs	r6, r2
    20c8:	001f      	movs	r7, r3
	ASSERT(descr);
    20ca:	1e43      	subs	r3, r0, #1
    20cc:	4198      	sbcs	r0, r3
    20ce:	b2c0      	uxtb	r0, r0
    20d0:	22b8      	movs	r2, #184	; 0xb8
    20d2:	4905      	ldr	r1, [pc, #20]	; (20e8 <can_async_set_filter+0x28>)
    20d4:	4b05      	ldr	r3, [pc, #20]	; (20ec <can_async_set_filter+0x2c>)
    20d6:	4798      	blx	r3
	return _can_async_set_filter(&descr->dev, index, fmt, filter);
    20d8:	003b      	movs	r3, r7
    20da:	0032      	movs	r2, r6
    20dc:	0029      	movs	r1, r5
    20de:	0020      	movs	r0, r4
    20e0:	4c03      	ldr	r4, [pc, #12]	; (20f0 <can_async_set_filter+0x30>)
    20e2:	47a0      	blx	r4
}
    20e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    20e6:	46c0      	nop			; (mov r8, r8)
    20e8:	00003b50 	.word	0x00003b50
    20ec:	0000245d 	.word	0x0000245d
    20f0:	00002961 	.word	0x00002961

000020f4 <flash_ready>:
 * \internal Ready for a new flash command
 *
 * \param[in] device The pointer to flash device structure
 */
static void flash_ready(struct _flash_device *device)
{
    20f4:	b510      	push	{r4, lr}
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_ready) {
    20f6:	6943      	ldr	r3, [r0, #20]
    20f8:	2b00      	cmp	r3, #0
    20fa:	d000      	beq.n	20fe <flash_ready+0xa>
		descr->callbacks.cb_ready(descr);
    20fc:	4798      	blx	r3
	}
}
    20fe:	bd10      	pop	{r4, pc}

00002100 <flash_error>:
 * \internal Error occurs in flash command
 *
 * \param[in] device The pointer to flash device structure
 */
static void flash_error(struct _flash_device *device)
{
    2100:	b510      	push	{r4, lr}
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_error) {
    2102:	6983      	ldr	r3, [r0, #24]
    2104:	2b00      	cmp	r3, #0
    2106:	d000      	beq.n	210a <flash_error+0xa>
		descr->callbacks.cb_error(descr);
    2108:	4798      	blx	r3
	}
}
    210a:	bd10      	pop	{r4, pc}

0000210c <flash_init>:
{
    210c:	b570      	push	{r4, r5, r6, lr}
    210e:	0004      	movs	r4, r0
    2110:	000d      	movs	r5, r1
	ASSERT(flash && hw);
    2112:	2800      	cmp	r0, #0
    2114:	d013      	beq.n	213e <flash_init+0x32>
    2116:	2900      	cmp	r1, #0
    2118:	d00f      	beq.n	213a <flash_init+0x2e>
    211a:	2001      	movs	r0, #1
    211c:	2238      	movs	r2, #56	; 0x38
    211e:	4909      	ldr	r1, [pc, #36]	; (2144 <flash_init+0x38>)
    2120:	4b09      	ldr	r3, [pc, #36]	; (2148 <flash_init+0x3c>)
    2122:	4798      	blx	r3
	rc = _flash_init(&flash->dev, hw);
    2124:	0029      	movs	r1, r5
    2126:	0020      	movs	r0, r4
    2128:	4b08      	ldr	r3, [pc, #32]	; (214c <flash_init+0x40>)
    212a:	4798      	blx	r3
	if (rc) {
    212c:	2800      	cmp	r0, #0
    212e:	d103      	bne.n	2138 <flash_init+0x2c>
	flash->dev.flash_cb.ready_cb = flash_ready;
    2130:	4b07      	ldr	r3, [pc, #28]	; (2150 <flash_init+0x44>)
    2132:	6023      	str	r3, [r4, #0]
	flash->dev.flash_cb.error_cb = flash_error;
    2134:	4b07      	ldr	r3, [pc, #28]	; (2154 <flash_init+0x48>)
    2136:	6063      	str	r3, [r4, #4]
}
    2138:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(flash && hw);
    213a:	2000      	movs	r0, #0
    213c:	e7ee      	b.n	211c <flash_init+0x10>
    213e:	2000      	movs	r0, #0
    2140:	e7ec      	b.n	211c <flash_init+0x10>
    2142:	46c0      	nop			; (mov r8, r8)
    2144:	00003b6c 	.word	0x00003b6c
    2148:	0000245d 	.word	0x0000245d
    214c:	00002c11 	.word	0x00002c11
    2150:	000020f5 	.word	0x000020f5
    2154:	00002101 	.word	0x00002101

00002158 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
    2158:	b570      	push	{r4, r5, r6, lr}
    215a:	0004      	movs	r4, r0
    215c:	000d      	movs	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
    215e:	2800      	cmp	r0, #0
    2160:	d017      	beq.n	2192 <spi_m_sync_init+0x3a>
    2162:	2900      	cmp	r1, #0
    2164:	d013      	beq.n	218e <spi_m_sync_init+0x36>
    2166:	2001      	movs	r0, #1
    2168:	2240      	movs	r2, #64	; 0x40
    216a:	490b      	ldr	r1, [pc, #44]	; (2198 <spi_m_sync_init+0x40>)
    216c:	4b0b      	ldr	r3, [pc, #44]	; (219c <spi_m_sync_init+0x44>)
    216e:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    2170:	6065      	str	r5, [r4, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
    2172:	1d20      	adds	r0, r4, #4
    2174:	0029      	movs	r1, r5
    2176:	4b0a      	ldr	r3, [pc, #40]	; (21a0 <spi_m_sync_init+0x48>)
    2178:	4798      	blx	r3

	if (rc < 0) {
    217a:	2800      	cmp	r0, #0
    217c:	db06      	blt.n	218c <spi_m_sync_init+0x34>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
    217e:	4b09      	ldr	r3, [pc, #36]	; (21a4 <spi_m_sync_init+0x4c>)
    2180:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
    2182:	4b09      	ldr	r3, [pc, #36]	; (21a8 <spi_m_sync_init+0x50>)
    2184:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
    2186:	4b09      	ldr	r3, [pc, #36]	; (21ac <spi_m_sync_init+0x54>)
    2188:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
    218a:	2000      	movs	r0, #0
}
    218c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && hw);
    218e:	2000      	movs	r0, #0
    2190:	e7ea      	b.n	2168 <spi_m_sync_init+0x10>
    2192:	2000      	movs	r0, #0
    2194:	e7e8      	b.n	2168 <spi_m_sync_init+0x10>
    2196:	46c0      	nop			; (mov r8, r8)
    2198:	00003b84 	.word	0x00003b84
    219c:	0000245d 	.word	0x0000245d
    21a0:	00002d0d 	.word	0x00002d0d
    21a4:	ffff8000 	.word	0xffff8000
    21a8:	00002235 	.word	0x00002235
    21ac:	000021f9 	.word	0x000021f9

000021b0 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
    21b0:	b530      	push	{r4, r5, lr}
    21b2:	b087      	sub	sp, #28
    21b4:	0004      	movs	r4, r0
    21b6:	000d      	movs	r5, r1
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
    21b8:	2800      	cmp	r0, #0
    21ba:	d015      	beq.n	21e8 <spi_m_sync_transfer+0x38>
    21bc:	2900      	cmp	r1, #0
    21be:	d011      	beq.n	21e4 <spi_m_sync_transfer+0x34>
    21c0:	2001      	movs	r0, #1
    21c2:	22b3      	movs	r2, #179	; 0xb3
    21c4:	4909      	ldr	r1, [pc, #36]	; (21ec <spi_m_sync_transfer+0x3c>)
    21c6:	4b0a      	ldr	r3, [pc, #40]	; (21f0 <spi_m_sync_transfer+0x40>)
    21c8:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
    21ca:	682b      	ldr	r3, [r5, #0]
    21cc:	9303      	str	r3, [sp, #12]
	msg.rxbuf = p_xfer->rxbuf;
    21ce:	686b      	ldr	r3, [r5, #4]
    21d0:	9304      	str	r3, [sp, #16]
	msg.size  = p_xfer->size;
    21d2:	68ab      	ldr	r3, [r5, #8]
    21d4:	9301      	str	r3, [sp, #4]
    21d6:	9305      	str	r3, [sp, #20]
	return _spi_m_sync_trans(&spi->dev, &msg);
    21d8:	1d20      	adds	r0, r4, #4
    21da:	a903      	add	r1, sp, #12
    21dc:	4b05      	ldr	r3, [pc, #20]	; (21f4 <spi_m_sync_transfer+0x44>)
    21de:	4798      	blx	r3
}
    21e0:	b007      	add	sp, #28
    21e2:	bd30      	pop	{r4, r5, pc}
	ASSERT(spi && p_xfer);
    21e4:	2000      	movs	r0, #0
    21e6:	e7ec      	b.n	21c2 <spi_m_sync_transfer+0x12>
    21e8:	2000      	movs	r0, #0
    21ea:	e7ea      	b.n	21c2 <spi_m_sync_transfer+0x12>
    21ec:	00003b84 	.word	0x00003b84
    21f0:	0000245d 	.word	0x0000245d
    21f4:	00002f09 	.word	0x00002f09

000021f8 <_spi_m_sync_io_write>:
{
    21f8:	b570      	push	{r4, r5, r6, lr}
    21fa:	b084      	sub	sp, #16
    21fc:	0004      	movs	r4, r0
    21fe:	000e      	movs	r6, r1
    2200:	0015      	movs	r5, r2
	ASSERT(io);
    2202:	1e43      	subs	r3, r0, #1
    2204:	4198      	sbcs	r0, r3
    2206:	b2c0      	uxtb	r0, r0
    2208:	22a3      	movs	r2, #163	; 0xa3
    220a:	4907      	ldr	r1, [pc, #28]	; (2228 <_spi_m_sync_io_write+0x30>)
    220c:	4b07      	ldr	r3, [pc, #28]	; (222c <_spi_m_sync_io_write+0x34>)
    220e:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    2210:	0020      	movs	r0, r4
    2212:	380c      	subs	r0, #12
	xfer.rxbuf = 0;
    2214:	2300      	movs	r3, #0
    2216:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
    2218:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
    221a:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    221c:	a901      	add	r1, sp, #4
    221e:	4b04      	ldr	r3, [pc, #16]	; (2230 <_spi_m_sync_io_write+0x38>)
    2220:	4798      	blx	r3
}
    2222:	b004      	add	sp, #16
    2224:	bd70      	pop	{r4, r5, r6, pc}
    2226:	46c0      	nop			; (mov r8, r8)
    2228:	00003b84 	.word	0x00003b84
    222c:	0000245d 	.word	0x0000245d
    2230:	000021b1 	.word	0x000021b1

00002234 <_spi_m_sync_io_read>:
{
    2234:	b570      	push	{r4, r5, r6, lr}
    2236:	b084      	sub	sp, #16
    2238:	0004      	movs	r4, r0
    223a:	000e      	movs	r6, r1
    223c:	0015      	movs	r5, r2
	ASSERT(io);
    223e:	1e43      	subs	r3, r0, #1
    2240:	4198      	sbcs	r0, r3
    2242:	b2c0      	uxtb	r0, r0
    2244:	2287      	movs	r2, #135	; 0x87
    2246:	4907      	ldr	r1, [pc, #28]	; (2264 <_spi_m_sync_io_read+0x30>)
    2248:	4b07      	ldr	r3, [pc, #28]	; (2268 <_spi_m_sync_io_read+0x34>)
    224a:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
    224c:	0020      	movs	r0, r4
    224e:	380c      	subs	r0, #12
	xfer.rxbuf = buf;
    2250:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
    2252:	2300      	movs	r3, #0
    2254:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
    2256:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
    2258:	a901      	add	r1, sp, #4
    225a:	4b04      	ldr	r3, [pc, #16]	; (226c <_spi_m_sync_io_read+0x38>)
    225c:	4798      	blx	r3
}
    225e:	b004      	add	sp, #16
    2260:	bd70      	pop	{r4, r5, r6, pc}
    2262:	46c0      	nop			; (mov r8, r8)
    2264:	00003b84 	.word	0x00003b84
    2268:	0000245d 	.word	0x0000245d
    226c:	000021b1 	.word	0x000021b1

00002270 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    2270:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
    2272:	6806      	ldr	r6, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
    2274:	2e00      	cmp	r6, #0
    2276:	d002      	beq.n	227e <timer_add_timer_task+0xe>
    2278:	0033      	movs	r3, r6
    227a:	2500      	movs	r5, #0
    227c:	e00c      	b.n	2298 <timer_add_timer_task+0x28>
		list_insert_as_head(list, new_task);
    227e:	4b10      	ldr	r3, [pc, #64]	; (22c0 <timer_add_timer_task+0x50>)
    2280:	4798      	blx	r3
		return;
    2282:	e018      	b.n	22b6 <timer_add_timer_task+0x46>
		uint32_t time_left;

		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    2284:	689f      	ldr	r7, [r3, #8]
    2286:	46bc      	mov	ip, r7
    2288:	4464      	add	r4, ip
    228a:	1aa4      	subs	r4, r4, r2
    228c:	3401      	adds	r4, #1
		}
		if (time_left >= new_task->interval)
    228e:	688f      	ldr	r7, [r1, #8]
    2290:	42bc      	cmp	r4, r7
    2292:	d20b      	bcs.n	22ac <timer_add_timer_task+0x3c>
			break;
		prev = it;
    2294:	001d      	movs	r5, r3
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    2296:	681b      	ldr	r3, [r3, #0]
    2298:	2b00      	cmp	r3, #0
    229a:	d007      	beq.n	22ac <timer_add_timer_task+0x3c>
		if (it->time_label <= time) {
    229c:	685c      	ldr	r4, [r3, #4]
    229e:	4294      	cmp	r4, r2
    22a0:	d8f0      	bhi.n	2284 <timer_add_timer_task+0x14>
			time_left = it->interval - (time - it->time_label);
    22a2:	1aa4      	subs	r4, r4, r2
    22a4:	689f      	ldr	r7, [r3, #8]
    22a6:	46bc      	mov	ip, r7
    22a8:	4464      	add	r4, ip
    22aa:	e7f0      	b.n	228e <timer_add_timer_task+0x1e>
	}

	if (it == head) {
    22ac:	42b3      	cmp	r3, r6
    22ae:	d003      	beq.n	22b8 <timer_add_timer_task+0x48>
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
    22b0:	0028      	movs	r0, r5
    22b2:	4b04      	ldr	r3, [pc, #16]	; (22c4 <timer_add_timer_task+0x54>)
    22b4:	4798      	blx	r3
	}
}
    22b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
    22b8:	4b01      	ldr	r3, [pc, #4]	; (22c0 <timer_add_timer_task+0x50>)
    22ba:	4798      	blx	r3
    22bc:	e7fb      	b.n	22b6 <timer_add_timer_task+0x46>
    22be:	46c0      	nop			; (mov r8, r8)
    22c0:	0000247d 	.word	0x0000247d
    22c4:	000024a9 	.word	0x000024a9

000022c8 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    22c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    22ca:	0005      	movs	r5, r0
    22cc:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    22ce:	6903      	ldr	r3, [r0, #16]
    22d0:	1c5e      	adds	r6, r3, #1
    22d2:	6106      	str	r6, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    22d4:	7e03      	ldrb	r3, [r0, #24]
    22d6:	07db      	lsls	r3, r3, #31
    22d8:	d402      	bmi.n	22e0 <timer_process_counted+0x18>
    22da:	7e03      	ldrb	r3, [r0, #24]
    22dc:	079b      	lsls	r3, r3, #30
    22de:	d50a      	bpl.n	22f6 <timer_process_counted+0x2e>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    22e0:	7e2b      	ldrb	r3, [r5, #24]
    22e2:	2202      	movs	r2, #2
    22e4:	4313      	orrs	r3, r2
    22e6:	b2db      	uxtb	r3, r3
    22e8:	762b      	strb	r3, [r5, #24]
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
	}
}
    22ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    22ec:	696f      	ldr	r7, [r5, #20]
		tmp->cb(tmp);
    22ee:	68e3      	ldr	r3, [r4, #12]
    22f0:	0020      	movs	r0, r4
    22f2:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
    22f4:	003c      	movs	r4, r7
	while (it && ((time - it->time_label) >= it->interval)) {
    22f6:	2c00      	cmp	r4, #0
    22f8:	d0f7      	beq.n	22ea <timer_process_counted+0x22>
    22fa:	6863      	ldr	r3, [r4, #4]
    22fc:	1af3      	subs	r3, r6, r3
    22fe:	68a2      	ldr	r2, [r4, #8]
    2300:	4293      	cmp	r3, r2
    2302:	d3f2      	bcc.n	22ea <timer_process_counted+0x22>
		list_remove_head(&timer->tasks);
    2304:	002f      	movs	r7, r5
    2306:	3714      	adds	r7, #20
    2308:	0038      	movs	r0, r7
    230a:	4b06      	ldr	r3, [pc, #24]	; (2324 <timer_process_counted+0x5c>)
    230c:	4798      	blx	r3
		if (TIMER_TASK_REPEAT == tmp->mode) {
    230e:	7c23      	ldrb	r3, [r4, #16]
    2310:	2b01      	cmp	r3, #1
    2312:	d1eb      	bne.n	22ec <timer_process_counted+0x24>
			tmp->time_label = time;
    2314:	6066      	str	r6, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    2316:	0032      	movs	r2, r6
    2318:	0021      	movs	r1, r4
    231a:	0038      	movs	r0, r7
    231c:	4b02      	ldr	r3, [pc, #8]	; (2328 <timer_process_counted+0x60>)
    231e:	4798      	blx	r3
    2320:	e7e4      	b.n	22ec <timer_process_counted+0x24>
    2322:	46c0      	nop			; (mov r8, r8)
    2324:	000024b1 	.word	0x000024b1
    2328:	00002271 	.word	0x00002271

0000232c <timer_init>:
{
    232c:	b570      	push	{r4, r5, r6, lr}
    232e:	0004      	movs	r4, r0
    2330:	000d      	movs	r5, r1
	ASSERT(descr && hw);
    2332:	2800      	cmp	r0, #0
    2334:	d012      	beq.n	235c <timer_init+0x30>
    2336:	2900      	cmp	r1, #0
    2338:	d00e      	beq.n	2358 <timer_init+0x2c>
    233a:	2001      	movs	r0, #1
    233c:	223b      	movs	r2, #59	; 0x3b
    233e:	4908      	ldr	r1, [pc, #32]	; (2360 <timer_init+0x34>)
    2340:	4b08      	ldr	r3, [pc, #32]	; (2364 <timer_init+0x38>)
    2342:	4798      	blx	r3
	_timer_init(&descr->device, hw);
    2344:	0029      	movs	r1, r5
    2346:	0020      	movs	r0, r4
    2348:	4b07      	ldr	r3, [pc, #28]	; (2368 <timer_init+0x3c>)
    234a:	4798      	blx	r3
	descr->time                           = 0;
    234c:	2300      	movs	r3, #0
    234e:	6123      	str	r3, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
    2350:	4b06      	ldr	r3, [pc, #24]	; (236c <timer_init+0x40>)
    2352:	6023      	str	r3, [r4, #0]
}
    2354:	2000      	movs	r0, #0
    2356:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
    2358:	2000      	movs	r0, #0
    235a:	e7ef      	b.n	233c <timer_init+0x10>
    235c:	2000      	movs	r0, #0
    235e:	e7ed      	b.n	233c <timer_init+0x10>
    2360:	00003ba0 	.word	0x00003ba0
    2364:	0000245d 	.word	0x0000245d
    2368:	000030b9 	.word	0x000030b9
    236c:	000022c9 	.word	0x000022c9

00002370 <timer_start>:
{
    2370:	b510      	push	{r4, lr}
    2372:	0004      	movs	r4, r0
	ASSERT(descr);
    2374:	1e43      	subs	r3, r0, #1
    2376:	4198      	sbcs	r0, r3
    2378:	b2c0      	uxtb	r0, r0
    237a:	2253      	movs	r2, #83	; 0x53
    237c:	4907      	ldr	r1, [pc, #28]	; (239c <timer_start+0x2c>)
    237e:	4b08      	ldr	r3, [pc, #32]	; (23a0 <timer_start+0x30>)
    2380:	4798      	blx	r3
	if (_timer_is_started(&descr->device)) {
    2382:	0020      	movs	r0, r4
    2384:	4b07      	ldr	r3, [pc, #28]	; (23a4 <timer_start+0x34>)
    2386:	4798      	blx	r3
    2388:	2800      	cmp	r0, #0
    238a:	d104      	bne.n	2396 <timer_start+0x26>
	_timer_start(&descr->device);
    238c:	0020      	movs	r0, r4
    238e:	4b06      	ldr	r3, [pc, #24]	; (23a8 <timer_start+0x38>)
    2390:	4798      	blx	r3
	return ERR_NONE;
    2392:	2000      	movs	r0, #0
}
    2394:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    2396:	2011      	movs	r0, #17
    2398:	4240      	negs	r0, r0
    239a:	e7fb      	b.n	2394 <timer_start+0x24>
    239c:	00003ba0 	.word	0x00003ba0
    23a0:	0000245d 	.word	0x0000245d
    23a4:	00003283 	.word	0x00003283
    23a8:	00003271 	.word	0x00003271

000023ac <timer_add_task>:
{
    23ac:	b570      	push	{r4, r5, r6, lr}
    23ae:	b082      	sub	sp, #8
    23b0:	0004      	movs	r4, r0
    23b2:	000d      	movs	r5, r1
	ASSERT(descr && task);
    23b4:	2800      	cmp	r0, #0
    23b6:	d026      	beq.n	2406 <timer_add_task+0x5a>
    23b8:	2900      	cmp	r1, #0
    23ba:	d022      	beq.n	2402 <timer_add_task+0x56>
    23bc:	2001      	movs	r0, #1
    23be:	227a      	movs	r2, #122	; 0x7a
    23c0:	491f      	ldr	r1, [pc, #124]	; (2440 <timer_add_task+0x94>)
    23c2:	4b20      	ldr	r3, [pc, #128]	; (2444 <timer_add_task+0x98>)
    23c4:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    23c6:	7e23      	ldrb	r3, [r4, #24]
    23c8:	2201      	movs	r2, #1
    23ca:	4313      	orrs	r3, r2
    23cc:	b2db      	uxtb	r3, r3
    23ce:	7623      	strb	r3, [r4, #24]
	if (is_list_element(&descr->tasks, task)) {
    23d0:	0026      	movs	r6, r4
    23d2:	3614      	adds	r6, #20
    23d4:	0029      	movs	r1, r5
    23d6:	0030      	movs	r0, r6
    23d8:	4b1b      	ldr	r3, [pc, #108]	; (2448 <timer_add_task+0x9c>)
    23da:	4798      	blx	r3
    23dc:	2800      	cmp	r0, #0
    23de:	d114      	bne.n	240a <timer_add_task+0x5e>
	task->time_label = descr->time;
    23e0:	6923      	ldr	r3, [r4, #16]
    23e2:	606b      	str	r3, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    23e4:	6922      	ldr	r2, [r4, #16]
    23e6:	0029      	movs	r1, r5
    23e8:	0030      	movs	r0, r6
    23ea:	4b18      	ldr	r3, [pc, #96]	; (244c <timer_add_task+0xa0>)
    23ec:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    23ee:	7e23      	ldrb	r3, [r4, #24]
    23f0:	2201      	movs	r2, #1
    23f2:	4393      	bics	r3, r2
    23f4:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    23f6:	7e23      	ldrb	r3, [r4, #24]
    23f8:	079b      	lsls	r3, r3, #30
    23fa:	d412      	bmi.n	2422 <timer_add_task+0x76>
	return ERR_NONE;
    23fc:	2000      	movs	r0, #0
}
    23fe:	b002      	add	sp, #8
    2400:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && task);
    2402:	2000      	movs	r0, #0
    2404:	e7db      	b.n	23be <timer_add_task+0x12>
    2406:	2000      	movs	r0, #0
    2408:	e7d9      	b.n	23be <timer_add_task+0x12>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    240a:	7e23      	ldrb	r3, [r4, #24]
    240c:	2201      	movs	r2, #1
    240e:	4393      	bics	r3, r2
    2410:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
    2412:	327e      	adds	r2, #126	; 0x7e
    2414:	490a      	ldr	r1, [pc, #40]	; (2440 <timer_add_task+0x94>)
    2416:	2000      	movs	r0, #0
    2418:	4b0a      	ldr	r3, [pc, #40]	; (2444 <timer_add_task+0x98>)
    241a:	4798      	blx	r3
		return ERR_ALREADY_INITIALIZED;
    241c:	2012      	movs	r0, #18
    241e:	4240      	negs	r0, r0
    2420:	e7ed      	b.n	23fe <timer_add_task+0x52>
		CRITICAL_SECTION_ENTER()
    2422:	a801      	add	r0, sp, #4
    2424:	4b0a      	ldr	r3, [pc, #40]	; (2450 <timer_add_task+0xa4>)
    2426:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    2428:	7e23      	ldrb	r3, [r4, #24]
    242a:	2202      	movs	r2, #2
    242c:	4393      	bics	r3, r2
    242e:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
    2430:	0020      	movs	r0, r4
    2432:	4b08      	ldr	r3, [pc, #32]	; (2454 <timer_add_task+0xa8>)
    2434:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    2436:	a801      	add	r0, sp, #4
    2438:	4b07      	ldr	r3, [pc, #28]	; (2458 <timer_add_task+0xac>)
    243a:	4798      	blx	r3
	return ERR_NONE;
    243c:	2000      	movs	r0, #0
    243e:	e7de      	b.n	23fe <timer_add_task+0x52>
    2440:	00003ba0 	.word	0x00003ba0
    2444:	0000245d 	.word	0x0000245d
    2448:	00002465 	.word	0x00002465
    244c:	00002271 	.word	0x00002271
    2450:	00001f45 	.word	0x00001f45
    2454:	00003299 	.word	0x00003299
    2458:	00001f53 	.word	0x00001f53

0000245c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    245c:	2800      	cmp	r0, #0
    245e:	d100      	bne.n	2462 <assert+0x6>
		__asm("BKPT #0");
    2460:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    2462:	4770      	bx	lr

00002464 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    2464:	6803      	ldr	r3, [r0, #0]
    2466:	2b00      	cmp	r3, #0
    2468:	d003      	beq.n	2472 <is_list_element+0xe>
		if (it == element) {
    246a:	428b      	cmp	r3, r1
    246c:	d003      	beq.n	2476 <is_list_element+0x12>
	for (it = list->head; it; it = it->next) {
    246e:	681b      	ldr	r3, [r3, #0]
    2470:	e7f9      	b.n	2466 <is_list_element+0x2>
			return true;
		}
	}

	return false;
    2472:	2000      	movs	r0, #0
}
    2474:	4770      	bx	lr
			return true;
    2476:	2001      	movs	r0, #1
    2478:	e7fc      	b.n	2474 <is_list_element+0x10>
	...

0000247c <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
    247c:	b570      	push	{r4, r5, r6, lr}
    247e:	0004      	movs	r4, r0
    2480:	000d      	movs	r5, r1
	ASSERT(!is_list_element(list, element));
    2482:	4b06      	ldr	r3, [pc, #24]	; (249c <list_insert_as_head+0x20>)
    2484:	4798      	blx	r3
    2486:	2301      	movs	r3, #1
    2488:	4058      	eors	r0, r3
    248a:	b2c0      	uxtb	r0, r0
    248c:	2239      	movs	r2, #57	; 0x39
    248e:	4904      	ldr	r1, [pc, #16]	; (24a0 <list_insert_as_head+0x24>)
    2490:	4b04      	ldr	r3, [pc, #16]	; (24a4 <list_insert_as_head+0x28>)
    2492:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
    2494:	6823      	ldr	r3, [r4, #0]
    2496:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
    2498:	6025      	str	r5, [r4, #0]
}
    249a:	bd70      	pop	{r4, r5, r6, pc}
    249c:	00002465 	.word	0x00002465
    24a0:	00003bb8 	.word	0x00003bb8
    24a4:	0000245d 	.word	0x0000245d

000024a8 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
    24a8:	6803      	ldr	r3, [r0, #0]
    24aa:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
    24ac:	6001      	str	r1, [r0, #0]
}
    24ae:	4770      	bx	lr

000024b0 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
    24b0:	6803      	ldr	r3, [r0, #0]
    24b2:	2b00      	cmp	r3, #0
    24b4:	d003      	beq.n	24be <list_remove_head+0xe>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
    24b6:	681a      	ldr	r2, [r3, #0]
    24b8:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
    24ba:	0018      	movs	r0, r3
	}

	return NULL;
}
    24bc:	4770      	bx	lr
	return NULL;
    24be:	2000      	movs	r0, #0
    24c0:	e7fc      	b.n	24bc <list_remove_head+0xc>
	...

000024c4 <_can_async_init>:

/**
 * \brief Initialize CAN.
 */
int32_t _can_async_init(struct _can_async_device *const dev, void *const hw)
{
    24c4:	b5f0      	push	{r4, r5, r6, r7, lr}
	dev->hw = hw;
    24c6:	6001      	str	r1, [r0, #0]
}

static inline void hri_can_set_CCCR_INIT_bit(const void *const hw)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= CAN_CCCR_INIT;
    24c8:	698b      	ldr	r3, [r1, #24]
    24ca:	2201      	movs	r2, #1
    24cc:	4313      	orrs	r3, r2
    24ce:	618b      	str	r3, [r1, #24]
	hri_can_set_CCCR_INIT_bit(dev->hw);
	while (hri_can_get_CCCR_INIT_bit(dev->hw) == 0)
    24d0:	6803      	ldr	r3, [r0, #0]
}

static inline bool hri_can_get_CCCR_INIT_bit(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Can *)hw)->CCCR.reg;
    24d2:	699a      	ldr	r2, [r3, #24]
    24d4:	07d2      	lsls	r2, r2, #31
    24d6:	d5fb      	bpl.n	24d0 <_can_async_init+0xc>
}

static inline void hri_can_set_CCCR_CCE_bit(const void *const hw)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= CAN_CCCR_CCE;
    24d8:	699a      	ldr	r2, [r3, #24]
    24da:	2402      	movs	r4, #2
    24dc:	4322      	orrs	r2, r4
    24de:	619a      	str	r2, [r3, #24]
		;
	hri_can_set_CCCR_CCE_bit(dev->hw);

#ifdef CONF_CAN0_ENABLED
	if (hw == CAN0) {
    24e0:	4b64      	ldr	r3, [pc, #400]	; (2674 <_can_async_init+0x1b0>)
    24e2:	4299      	cmp	r1, r3
    24e4:	d012      	beq.n	250c <_can_async_init+0x48>
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
	}
#endif

#ifdef CONF_CAN1_ENABLED
	if (hw == CAN1) {
    24e6:	4b64      	ldr	r3, [pc, #400]	; (2678 <_can_async_init+0x1b4>)
    24e8:	4299      	cmp	r1, r3
    24ea:	d069      	beq.n	25c0 <_can_async_init+0xfc>
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
	}
#endif

	/* Disable CCE to prevent Configuration Change */
	hri_can_clear_CCCR_CCE_bit(dev->hw);
    24ec:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_can_clear_CCCR_CCE_bit(const void *const hw)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_CCE;
    24ee:	6993      	ldr	r3, [r2, #24]
    24f0:	2102      	movs	r1, #2
    24f2:	438b      	bics	r3, r1
    24f4:	6193      	str	r3, [r2, #24]
	hri_can_clear_CCCR_INIT_bit(dev->hw);
    24f6:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_INIT;
    24f8:	6993      	ldr	r3, [r2, #24]
    24fa:	3901      	subs	r1, #1
    24fc:	438b      	bics	r3, r1
    24fe:	6193      	str	r3, [r2, #24]
	while (hri_can_get_CCCR_INIT_bit(dev->hw)) {
    2500:	6803      	ldr	r3, [r0, #0]
	tmp = ((Can *)hw)->CCCR.reg;
    2502:	699b      	ldr	r3, [r3, #24]
    2504:	07db      	lsls	r3, r3, #31
    2506:	d4fb      	bmi.n	2500 <_can_async_init+0x3c>
	};

	return ERR_NONE;
}
    2508:	2000      	movs	r0, #0
    250a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		_can0_dev    = dev;
    250c:	4b5b      	ldr	r3, [pc, #364]	; (267c <_can_async_init+0x1b8>)
    250e:	001a      	movs	r2, r3
    2510:	c201      	stmia	r2!, {r0}
		dev->context = (void *)&_can0_context;
    2512:	4c5b      	ldr	r4, [pc, #364]	; (2680 <_can_async_init+0x1bc>)
    2514:	6184      	str	r4, [r0, #24]
		hri_can_set_CCCR_reg(dev->hw, CONF_CAN0_CCCR_REG);
    2516:	6804      	ldr	r4, [r0, #0]
}

static inline void hri_can_set_CCCR_reg(const void *const hw, hri_can_cccr_reg_t mask)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= mask;
    2518:	69a5      	ldr	r5, [r4, #24]
    251a:	61a5      	str	r5, [r4, #24]
		hri_can_write_MRCFG_reg(dev->hw, CONF_CAN0_MRCFG_REG);
    251c:	6804      	ldr	r4, [r0, #0]
	((Can *)hw)->MRCFG.reg = data;
    251e:	2600      	movs	r6, #0
    2520:	60a6      	str	r6, [r4, #8]
		hri_can_write_NBTP_reg(dev->hw, CONF_CAN0_BTP_REG);
    2522:	6804      	ldr	r4, [r0, #0]
}

static inline void hri_can_write_NBTP_reg(const void *const hw, hri_can_nbtp_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->NBTP.reg = data;
    2524:	4d57      	ldr	r5, [pc, #348]	; (2684 <_can_async_init+0x1c0>)
    2526:	61e5      	str	r5, [r4, #28]
		hri_can_write_DBTP_reg(dev->hw, CONF_CAN0_DBTP_REG);
    2528:	6804      	ldr	r4, [r0, #0]
	((Can *)hw)->DBTP.reg = data;
    252a:	4d57      	ldr	r5, [pc, #348]	; (2688 <_can_async_init+0x1c4>)
    252c:	60e5      	str	r5, [r4, #12]
		hri_can_write_RXF0C_reg(dev->hw, CONF_CAN0_RXF0C_REG | CAN_RXF0C_F0SA((uint32_t)can0_rx_fifo));
    252e:	4c57      	ldr	r4, [pc, #348]	; (268c <_can_async_init+0x1c8>)
    2530:	0424      	lsls	r4, r4, #16
    2532:	0c24      	lsrs	r4, r4, #16
    2534:	4d56      	ldr	r5, [pc, #344]	; (2690 <_can_async_init+0x1cc>)
    2536:	432c      	orrs	r4, r5
}

static inline void hri_can_write_RXF0C_reg(const void *const hw, hri_can_rxf0c_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->RXF0C.reg = data;
    2538:	25a0      	movs	r5, #160	; 0xa0
    253a:	6807      	ldr	r7, [r0, #0]
    253c:	517c      	str	r4, [r7, r5]
}

static inline void hri_can_write_RXESC_reg(const void *const hw, hri_can_rxesc_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->RXESC.reg = data;
    253e:	3d99      	subs	r5, #153	; 0x99
    2540:	24bc      	movs	r4, #188	; 0xbc
    2542:	6807      	ldr	r7, [r0, #0]
    2544:	513d      	str	r5, [r7, r4]
}

static inline void hri_can_write_TXESC_reg(const void *const hw, hri_can_txesc_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->TXESC.reg = data;
    2546:	340c      	adds	r4, #12
    2548:	6805      	ldr	r5, [r0, #0]
    254a:	512e      	str	r6, [r5, r4]
		hri_can_write_TXBC_reg(dev->hw, CONF_CAN0_TXBC_REG | CAN_TXBC_TBSA((uint32_t)can0_tx_fifo));
    254c:	4c51      	ldr	r4, [pc, #324]	; (2694 <_can_async_init+0x1d0>)
    254e:	0424      	lsls	r4, r4, #16
    2550:	0c24      	lsrs	r4, r4, #16
    2552:	2580      	movs	r5, #128	; 0x80
    2554:	04ad      	lsls	r5, r5, #18
    2556:	432c      	orrs	r4, r5
	((Can *)hw)->TXBC.reg = data;
    2558:	25c0      	movs	r5, #192	; 0xc0
    255a:	6806      	ldr	r6, [r0, #0]
    255c:	5174      	str	r4, [r6, r5]
		hri_can_write_TXEFC_reg(dev->hw, CONF_CAN0_TXEFC_REG | CAN_TXEFC_EFSA((uint32_t)can0_tx_event_fifo));
    255e:	0412      	lsls	r2, r2, #16
    2560:	0c12      	lsrs	r2, r2, #16
    2562:	2480      	movs	r4, #128	; 0x80
    2564:	02a4      	lsls	r4, r4, #10
    2566:	4322      	orrs	r2, r4
}

static inline void hri_can_write_TXEFC_reg(const void *const hw, hri_can_txefc_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->TXEFC.reg = data;
    2568:	3530      	adds	r5, #48	; 0x30
    256a:	6806      	ldr	r6, [r0, #0]
    256c:	5172      	str	r2, [r6, r5]
	((Can *)hw)->GFC.reg = data;
    256e:	3d70      	subs	r5, #112	; 0x70
    2570:	2228      	movs	r2, #40	; 0x28
    2572:	6806      	ldr	r6, [r0, #0]
    2574:	5172      	str	r2, [r6, r5]
		hri_can_write_SIDFC_reg(dev->hw, CONF_CAN0_SIDFC_REG | CAN_SIDFC_FLSSA((uint32_t)can0_rx_std_filter));
    2576:	001a      	movs	r2, r3
    2578:	3214      	adds	r2, #20
    257a:	0412      	lsls	r2, r2, #16
    257c:	0c12      	lsrs	r2, r2, #16
    257e:	4322      	orrs	r2, r4
	((Can *)hw)->SIDFC.reg = data;
    2580:	2484      	movs	r4, #132	; 0x84
    2582:	6806      	ldr	r6, [r0, #0]
    2584:	5132      	str	r2, [r6, r4]
		hri_can_write_XIDFC_reg(dev->hw, CONF_CAN0_XIDFC_REG | CAN_XIDFC_FLESA((uint32_t)can0_rx_ext_filter));
    2586:	331c      	adds	r3, #28
    2588:	041b      	lsls	r3, r3, #16
    258a:	0c1b      	lsrs	r3, r3, #16
    258c:	22a0      	movs	r2, #160	; 0xa0
    258e:	0312      	lsls	r2, r2, #12
    2590:	4313      	orrs	r3, r2
	((Can *)hw)->XIDFC.reg = data;
    2592:	2288      	movs	r2, #136	; 0x88
    2594:	6804      	ldr	r4, [r0, #0]
    2596:	50a3      	str	r3, [r4, r2]
	((Can *)hw)->XIDAM.reg = data;
    2598:	4a3f      	ldr	r2, [pc, #252]	; (2698 <_can_async_init+0x1d4>)
    259a:	2390      	movs	r3, #144	; 0x90
    259c:	6804      	ldr	r4, [r0, #0]
    259e:	50e2      	str	r2, [r4, r3]
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    25a0:	4b3e      	ldr	r3, [pc, #248]	; (269c <_can_async_init+0x1d8>)
    25a2:	2280      	movs	r2, #128	; 0x80
    25a4:	0212      	lsls	r2, r2, #8
    25a6:	515a      	str	r2, [r3, r5]
  __ASM volatile ("dsb 0xF":::"memory");
    25a8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    25ac:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    25b0:	24c0      	movs	r4, #192	; 0xc0
    25b2:	0064      	lsls	r4, r4, #1
    25b4:	511a      	str	r2, [r3, r4]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    25b6:	601a      	str	r2, [r3, #0]
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
    25b8:	6803      	ldr	r3, [r0, #0]
	((Can *)hw)->ILE.reg = data;
    25ba:	2201      	movs	r2, #1
    25bc:	65da      	str	r2, [r3, #92]	; 0x5c
    25be:	e792      	b.n	24e6 <_can_async_init+0x22>
		_can1_dev    = dev;
    25c0:	4b2e      	ldr	r3, [pc, #184]	; (267c <_can_async_init+0x1b8>)
    25c2:	66d8      	str	r0, [r3, #108]	; 0x6c
		dev->context = (void *)&_can1_context;
    25c4:	4a2e      	ldr	r2, [pc, #184]	; (2680 <_can_async_init+0x1bc>)
    25c6:	3214      	adds	r2, #20
    25c8:	6182      	str	r2, [r0, #24]
		hri_can_set_CCCR_reg(dev->hw, CONF_CAN1_CCCR_REG);
    25ca:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->CCCR.reg |= mask;
    25cc:	6991      	ldr	r1, [r2, #24]
    25ce:	6191      	str	r1, [r2, #24]
		hri_can_write_MRCFG_reg(dev->hw, CONF_CAN1_MRCFG_REG);
    25d0:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->MRCFG.reg = data;
    25d2:	2100      	movs	r1, #0
    25d4:	6091      	str	r1, [r2, #8]
		hri_can_write_NBTP_reg(dev->hw, CONF_CAN1_BTP_REG);
    25d6:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->NBTP.reg = data;
    25d8:	4c2a      	ldr	r4, [pc, #168]	; (2684 <_can_async_init+0x1c0>)
    25da:	61d4      	str	r4, [r2, #28]
		hri_can_write_DBTP_reg(dev->hw, CONF_CAN1_DBTP_REG);
    25dc:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->DBTP.reg = data;
    25de:	4c2a      	ldr	r4, [pc, #168]	; (2688 <_can_async_init+0x1c4>)
    25e0:	60d4      	str	r4, [r2, #12]
		hri_can_write_RXF0C_reg(dev->hw, CONF_CAN1_RXF0C_REG | CAN_RXF0C_F0SA((uint32_t)can1_rx_fifo));
    25e2:	4a2f      	ldr	r2, [pc, #188]	; (26a0 <_can_async_init+0x1dc>)
    25e4:	0412      	lsls	r2, r2, #16
    25e6:	0c12      	lsrs	r2, r2, #16
    25e8:	4c29      	ldr	r4, [pc, #164]	; (2690 <_can_async_init+0x1cc>)
    25ea:	4322      	orrs	r2, r4
	((Can *)hw)->RXF0C.reg = data;
    25ec:	24a0      	movs	r4, #160	; 0xa0
    25ee:	6805      	ldr	r5, [r0, #0]
    25f0:	512a      	str	r2, [r5, r4]
	((Can *)hw)->RXESC.reg = data;
    25f2:	22bc      	movs	r2, #188	; 0xbc
    25f4:	6804      	ldr	r4, [r0, #0]
    25f6:	50a1      	str	r1, [r4, r2]
	((Can *)hw)->TXESC.reg = data;
    25f8:	320c      	adds	r2, #12
    25fa:	6804      	ldr	r4, [r0, #0]
    25fc:	50a1      	str	r1, [r4, r2]
		hri_can_write_TXBC_reg(dev->hw, CONF_CAN1_TXBC_REG | CAN_TXBC_TBSA((uint32_t)can1_tx_fifo));
    25fe:	4a29      	ldr	r2, [pc, #164]	; (26a4 <_can_async_init+0x1e0>)
    2600:	0412      	lsls	r2, r2, #16
    2602:	0c12      	lsrs	r2, r2, #16
    2604:	2180      	movs	r1, #128	; 0x80
    2606:	0489      	lsls	r1, r1, #18
    2608:	430a      	orrs	r2, r1
	((Can *)hw)->TXBC.reg = data;
    260a:	21c0      	movs	r1, #192	; 0xc0
    260c:	6804      	ldr	r4, [r0, #0]
    260e:	5062      	str	r2, [r4, r1]
		hri_can_write_TXEFC_reg(dev->hw, CONF_CAN1_TXEFC_REG | CAN_TXEFC_EFSA((uint32_t)can1_tx_event_fifo));
    2610:	3370      	adds	r3, #112	; 0x70
    2612:	041b      	lsls	r3, r3, #16
    2614:	0c1b      	lsrs	r3, r3, #16
    2616:	2280      	movs	r2, #128	; 0x80
    2618:	0292      	lsls	r2, r2, #10
    261a:	4313      	orrs	r3, r2
	((Can *)hw)->TXEFC.reg = data;
    261c:	3130      	adds	r1, #48	; 0x30
    261e:	6804      	ldr	r4, [r0, #0]
    2620:	5063      	str	r3, [r4, r1]
	((Can *)hw)->GFC.reg = data;
    2622:	2480      	movs	r4, #128	; 0x80
    2624:	2328      	movs	r3, #40	; 0x28
    2626:	6801      	ldr	r1, [r0, #0]
    2628:	510b      	str	r3, [r1, r4]
		hri_can_write_SIDFC_reg(dev->hw, CONF_CAN1_SIDFC_REG | CAN_SIDFC_FLSSA((uint32_t)can1_rx_std_filter));
    262a:	4b1f      	ldr	r3, [pc, #124]	; (26a8 <_can_async_init+0x1e4>)
    262c:	0419      	lsls	r1, r3, #16
    262e:	0c09      	lsrs	r1, r1, #16
    2630:	430a      	orrs	r2, r1
	((Can *)hw)->SIDFC.reg = data;
    2632:	2184      	movs	r1, #132	; 0x84
    2634:	6805      	ldr	r5, [r0, #0]
    2636:	506a      	str	r2, [r5, r1]
		hri_can_write_XIDFC_reg(dev->hw, CONF_CAN1_XIDFC_REG | CAN_XIDFC_FLESA((uint32_t)can1_rx_ext_filter));
    2638:	3308      	adds	r3, #8
    263a:	041b      	lsls	r3, r3, #16
    263c:	0c1b      	lsrs	r3, r3, #16
    263e:	22a0      	movs	r2, #160	; 0xa0
    2640:	0312      	lsls	r2, r2, #12
    2642:	4313      	orrs	r3, r2
	((Can *)hw)->XIDFC.reg = data;
    2644:	2288      	movs	r2, #136	; 0x88
    2646:	6801      	ldr	r1, [r0, #0]
    2648:	508b      	str	r3, [r1, r2]
	((Can *)hw)->XIDAM.reg = data;
    264a:	4a13      	ldr	r2, [pc, #76]	; (2698 <_can_async_init+0x1d4>)
    264c:	2390      	movs	r3, #144	; 0x90
    264e:	6801      	ldr	r1, [r0, #0]
    2650:	50ca      	str	r2, [r1, r3]
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2652:	4b12      	ldr	r3, [pc, #72]	; (269c <_can_async_init+0x1d8>)
    2654:	2280      	movs	r2, #128	; 0x80
    2656:	0252      	lsls	r2, r2, #9
    2658:	511a      	str	r2, [r3, r4]
  __ASM volatile ("dsb 0xF":::"memory");
    265a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    265e:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2662:	21c0      	movs	r1, #192	; 0xc0
    2664:	0049      	lsls	r1, r1, #1
    2666:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2668:	601a      	str	r2, [r3, #0]
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
    266a:	6803      	ldr	r3, [r0, #0]
	((Can *)hw)->ILE.reg = data;
    266c:	2201      	movs	r2, #1
    266e:	65da      	str	r2, [r3, #92]	; 0x5c
    2670:	e73c      	b.n	24ec <_can_async_init+0x28>
    2672:	46c0      	nop			; (mov r8, r8)
    2674:	42001c00 	.word	0x42001c00
    2678:	42002000 	.word	0x42002000
    267c:	20002af4 	.word	0x20002af4
    2680:	20000004 	.word	0x20000004
    2684:	02000203 	.word	0x02000203
    2688:	00000231 	.word	0x00000231
    268c:	200030f0 	.word	0x200030f0
    2690:	80100000 	.word	0x80100000
    2694:	20003690 	.word	0x20003690
    2698:	1fffffff 	.word	0x1fffffff
    269c:	e000e100 	.word	0xe000e100
    26a0:	20003590 	.word	0x20003590
    26a4:	20003570 	.word	0x20003570
    26a8:	20002b74 	.word	0x20002b74

000026ac <_can_async_enable>:
/**
 * \brief Enable CAN
 */
int32_t _can_async_enable(struct _can_async_device *const dev)
{
	hri_can_clear_CCCR_INIT_bit(dev->hw);
    26ac:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_INIT;
    26ae:	6993      	ldr	r3, [r2, #24]
    26b0:	2101      	movs	r1, #1
    26b2:	438b      	bics	r3, r1
    26b4:	6193      	str	r3, [r2, #24]
	return ERR_NONE;
}
    26b6:	2000      	movs	r0, #0
    26b8:	4770      	bx	lr
	...

000026bc <_can_async_read>:

/**
 * \brief Read a CAN message
 */
int32_t _can_async_read(struct _can_async_device *const dev, struct can_message *msg)
{
    26bc:	b5f0      	push	{r4, r5, r6, r7, lr}
    26be:	46ce      	mov	lr, r9
    26c0:	4647      	mov	r7, r8
    26c2:	b580      	push	{r7, lr}
    26c4:	b085      	sub	sp, #20
    26c6:	4680      	mov	r8, r0
	struct _can_rx_fifo_entry *f = NULL;
	hri_can_rxf0s_reg_t        get_index;

	if (!hri_can_read_RXF0S_F0FL_bf(dev->hw)) {
    26c8:	6802      	ldr	r2, [r0, #0]
	return (((Can *)hw)->RXF0S.reg & CAN_RXF0S_F0FL_Msk) >> CAN_RXF0S_F0FL_Pos;
    26ca:	23a4      	movs	r3, #164	; 0xa4
    26cc:	58d3      	ldr	r3, [r2, r3]
    26ce:	065b      	lsls	r3, r3, #25
    26d0:	d04f      	beq.n	2772 <_can_async_read+0xb6>
	return (((Can *)hw)->RXF0S.reg & CAN_RXF0S_F0GI_Msk) >> CAN_RXF0S_F0GI_Pos;
    26d2:	23a4      	movs	r3, #164	; 0xa4
    26d4:	58d4      	ldr	r4, [r2, r3]
    26d6:	0a24      	lsrs	r4, r4, #8
    26d8:	3b65      	subs	r3, #101	; 0x65
    26da:	401c      	ands	r4, r3
    26dc:	46a1      	mov	r9, r4
	}

	get_index = hri_can_read_RXF0S_F0GI_bf(dev->hw);

#ifdef CONF_CAN0_ENABLED
	if (dev->hw == CAN0) {
    26de:	4b28      	ldr	r3, [pc, #160]	; (2780 <_can_async_read+0xc4>)
    26e0:	429a      	cmp	r2, r3
    26e2:	d031      	beq.n	2748 <_can_async_read+0x8c>
	struct _can_rx_fifo_entry *f = NULL;
    26e4:	2300      	movs	r3, #0
		f = (struct _can_rx_fifo_entry *)(can0_rx_fifo + get_index * CONF_CAN0_F0DS);
	}
#endif
#ifdef CONF_CAN1_ENABLED
	if (dev->hw == CAN1) {
    26e6:	4827      	ldr	r0, [pc, #156]	; (2784 <_can_async_read+0xc8>)
    26e8:	4282      	cmp	r2, r0
    26ea:	d033      	beq.n	2754 <_can_async_read+0x98>
		f = (struct _can_rx_fifo_entry *)(can1_rx_fifo + get_index * CONF_CAN1_F0DS);
	}
#endif

	if (f == NULL) {
    26ec:	2b00      	cmp	r3, #0
    26ee:	d043      	beq.n	2778 <_can_async_read+0xbc>
		return ERR_NO_RESOURCE;
	}

	if (f->R0.bit.XTD == 1) {
    26f0:	681a      	ldr	r2, [r3, #0]
    26f2:	0052      	lsls	r2, r2, #1
    26f4:	d433      	bmi.n	275e <_can_async_read+0xa2>
		msg->fmt = CAN_FMT_EXTID;
		msg->id  = f->R0.bit.ID;
	} else {
		msg->fmt = CAN_FMT_STDID;
    26f6:	2200      	movs	r2, #0
    26f8:	734a      	strb	r2, [r1, #13]
		/* A standard identifier is stored into ID[28:18] */
		msg->id = f->R0.bit.ID >> 18;
    26fa:	681a      	ldr	r2, [r3, #0]
    26fc:	00d2      	lsls	r2, r2, #3
    26fe:	0d52      	lsrs	r2, r2, #21
    2700:	600a      	str	r2, [r1, #0]
	}

	if (f->R0.bit.RTR == 1) {
    2702:	681a      	ldr	r2, [r3, #0]
    2704:	0092      	lsls	r2, r2, #2
    2706:	d431      	bmi.n	276c <_can_async_read+0xb0>
		msg->type = CAN_TYPE_REMOTE;
	}

	const uint8_t dlc2len[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 32, 48, 64};
    2708:	466a      	mov	r2, sp
    270a:	481f      	ldr	r0, [pc, #124]	; (2788 <_can_async_read+0xcc>)
    270c:	466e      	mov	r6, sp
    270e:	c8b0      	ldmia	r0!, {r4, r5, r7}
    2710:	c6b0      	stmia	r6!, {r4, r5, r7}
    2712:	6800      	ldr	r0, [r0, #0]
    2714:	6030      	str	r0, [r6, #0]
	msg->len                = dlc2len[f->R1.bit.DLC];
    2716:	6858      	ldr	r0, [r3, #4]
    2718:	0300      	lsls	r0, r0, #12
    271a:	0f00      	lsrs	r0, r0, #28
    271c:	5c12      	ldrb	r2, [r2, r0]
    271e:	730a      	strb	r2, [r1, #12]

	memcpy(msg->data, f->data, msg->len);
    2720:	6888      	ldr	r0, [r1, #8]
    2722:	3308      	adds	r3, #8
    2724:	0019      	movs	r1, r3
    2726:	4b19      	ldr	r3, [pc, #100]	; (278c <_can_async_read+0xd0>)
    2728:	4798      	blx	r3

	hri_can_write_RXF0A_F0AI_bf(dev->hw, get_index);
    272a:	4643      	mov	r3, r8
    272c:	6819      	ldr	r1, [r3, #0]
	tmp = ((Can *)hw)->RXF0A.reg;
    272e:	22a8      	movs	r2, #168	; 0xa8
    2730:	588b      	ldr	r3, [r1, r2]
	tmp &= ~CAN_RXF0A_F0AI_Msk;
    2732:	203f      	movs	r0, #63	; 0x3f
    2734:	4383      	bics	r3, r0
	tmp |= CAN_RXF0A_F0AI(data);
    2736:	464c      	mov	r4, r9
    2738:	431c      	orrs	r4, r3
	((Can *)hw)->RXF0A.reg = tmp;
    273a:	508c      	str	r4, [r1, r2]

	return ERR_NONE;
    273c:	2000      	movs	r0, #0
}
    273e:	b005      	add	sp, #20
    2740:	bc0c      	pop	{r2, r3}
    2742:	4690      	mov	r8, r2
    2744:	4699      	mov	r9, r3
    2746:	bdf0      	pop	{r4, r5, r6, r7, pc}
		f = (struct _can_rx_fifo_entry *)(can0_rx_fifo + get_index * CONF_CAN0_F0DS);
    2748:	00e0      	lsls	r0, r4, #3
    274a:	4448      	add	r0, r9
    274c:	00c3      	lsls	r3, r0, #3
    274e:	4810      	ldr	r0, [pc, #64]	; (2790 <_can_async_read+0xd4>)
    2750:	181b      	adds	r3, r3, r0
    2752:	e7c8      	b.n	26e6 <_can_async_read+0x2a>
		f = (struct _can_rx_fifo_entry *)(can1_rx_fifo + get_index * CONF_CAN1_F0DS);
    2754:	464b      	mov	r3, r9
    2756:	011b      	lsls	r3, r3, #4
    2758:	4a0e      	ldr	r2, [pc, #56]	; (2794 <_can_async_read+0xd8>)
    275a:	189b      	adds	r3, r3, r2
    275c:	e7c6      	b.n	26ec <_can_async_read+0x30>
		msg->fmt = CAN_FMT_EXTID;
    275e:	2201      	movs	r2, #1
    2760:	734a      	strb	r2, [r1, #13]
		msg->id  = f->R0.bit.ID;
    2762:	681a      	ldr	r2, [r3, #0]
    2764:	00d2      	lsls	r2, r2, #3
    2766:	08d2      	lsrs	r2, r2, #3
    2768:	600a      	str	r2, [r1, #0]
    276a:	e7ca      	b.n	2702 <_can_async_read+0x46>
		msg->type = CAN_TYPE_REMOTE;
    276c:	2201      	movs	r2, #1
    276e:	710a      	strb	r2, [r1, #4]
    2770:	e7ca      	b.n	2708 <_can_async_read+0x4c>
		return ERR_NOT_FOUND;
    2772:	200a      	movs	r0, #10
    2774:	4240      	negs	r0, r0
    2776:	e7e2      	b.n	273e <_can_async_read+0x82>
		return ERR_NO_RESOURCE;
    2778:	201c      	movs	r0, #28
    277a:	4240      	negs	r0, r0
    277c:	e7df      	b.n	273e <_can_async_read+0x82>
    277e:	46c0      	nop			; (mov r8, r8)
    2780:	42001c00 	.word	0x42001c00
    2784:	42002000 	.word	0x42002000
    2788:	00003bd8 	.word	0x00003bd8
    278c:	00003a85 	.word	0x00003a85
    2790:	200030f0 	.word	0x200030f0
    2794:	20003590 	.word	0x20003590

00002798 <_can_async_write>:

/**
 * \brief Write a CAN message
 */
int32_t _can_async_write(struct _can_async_device *const dev, struct can_message *msg)
{
    2798:	b570      	push	{r4, r5, r6, lr}
    279a:	0005      	movs	r5, r0
	struct _can_tx_fifo_entry *f = NULL;
	hri_can_txfqs_reg_t        put_index;

	if (hri_can_get_TXFQS_TFQF_bit(dev->hw)) {
    279c:	6803      	ldr	r3, [r0, #0]
	return (((Can *)hw)->TXFQS.reg & CAN_TXFQS_TFQF) >> CAN_TXFQS_TFQF_Pos;
    279e:	22c4      	movs	r2, #196	; 0xc4
    27a0:	589a      	ldr	r2, [r3, r2]
    27a2:	0292      	lsls	r2, r2, #10
    27a4:	d500      	bpl.n	27a8 <_can_async_write+0x10>
    27a6:	e09a      	b.n	28de <_can_async_write+0x146>
	return (((Can *)hw)->TXFQS.reg & CAN_TXFQS_TFQPI_Msk) >> CAN_TXFQS_TFQPI_Pos;
    27a8:	22c4      	movs	r2, #196	; 0xc4
    27aa:	5898      	ldr	r0, [r3, r2]
    27ac:	0c00      	lsrs	r0, r0, #16
    27ae:	3aa5      	subs	r2, #165	; 0xa5
    27b0:	4002      	ands	r2, r0
	}

	put_index = hri_can_read_TXFQS_TFQPI_bf(dev->hw);

#ifdef CONF_CAN0_ENABLED
	if (dev->hw == CAN0) {
    27b2:	484e      	ldr	r0, [pc, #312]	; (28ec <_can_async_write+0x154>)
    27b4:	4283      	cmp	r3, r0
    27b6:	d03d      	beq.n	2834 <_can_async_write+0x9c>
	struct _can_tx_fifo_entry *f = NULL;
    27b8:	2000      	movs	r0, #0
		f = (struct _can_tx_fifo_entry *)(can0_tx_fifo + put_index * CONF_CAN0_TBDS);
	}
#endif
#ifdef CONF_CAN1_ENABLED
	if (dev->hw == CAN1) {
    27ba:	4c4d      	ldr	r4, [pc, #308]	; (28f0 <_can_async_write+0x158>)
    27bc:	42a3      	cmp	r3, r4
    27be:	d03d      	beq.n	283c <_can_async_write+0xa4>
		f = (struct _can_tx_fifo_entry *)(can1_tx_fifo + put_index * CONF_CAN1_TBDS);
	}
#endif
	if (f == NULL) {
    27c0:	2800      	cmp	r0, #0
    27c2:	d100      	bne.n	27c6 <_can_async_write+0x2e>
    27c4:	e08e      	b.n	28e4 <_can_async_write+0x14c>
		return ERR_NO_RESOURCE;
	}

	if (msg->fmt == CAN_FMT_EXTID) {
    27c6:	7b4b      	ldrb	r3, [r1, #13]
    27c8:	2b01      	cmp	r3, #1
    27ca:	d03b      	beq.n	2844 <_can_async_write+0xac>
		f->T0.val     = msg->id;
		f->T0.bit.XTD = 1;
	} else {
		/* A standard identifier is stored into ID[28:18] */
		f->T0.val = msg->id << 18;
    27cc:	680b      	ldr	r3, [r1, #0]
    27ce:	049b      	lsls	r3, r3, #18
    27d0:	6003      	str	r3, [r0, #0]
	}

	if (msg->len <= 8) {
    27d2:	7b0a      	ldrb	r2, [r1, #12]
    27d4:	2a08      	cmp	r2, #8
    27d6:	d83d      	bhi.n	2854 <_can_async_write+0xbc>
		f->T1.bit.DLC = msg->len;
    27d8:	6844      	ldr	r4, [r0, #4]
    27da:	230f      	movs	r3, #15
    27dc:	4013      	ands	r3, r2
    27de:	041b      	lsls	r3, r3, #16
    27e0:	4a44      	ldr	r2, [pc, #272]	; (28f4 <_can_async_write+0x15c>)
    27e2:	4014      	ands	r4, r2
    27e4:	4323      	orrs	r3, r4
    27e6:	6043      	str	r3, [r0, #4]
		f->T1.bit.DLC = 0xE;
	} else if (msg->len <= 64) {
		f->T1.bit.DLC = 0xF;
	}

	f->T1.bit.FDF = hri_can_get_CCCR_FDOE_bit(dev->hw);
    27e8:	682b      	ldr	r3, [r5, #0]
	tmp = ((Can *)hw)->CCCR.reg;
    27ea:	699b      	ldr	r3, [r3, #24]
	tmp = (tmp & CAN_CCCR_FDOE) >> CAN_CCCR_FDOE_Pos;
    27ec:	0a1b      	lsrs	r3, r3, #8
    27ee:	2401      	movs	r4, #1
    27f0:	6842      	ldr	r2, [r0, #4]
    27f2:	4023      	ands	r3, r4
    27f4:	055b      	lsls	r3, r3, #21
    27f6:	4e40      	ldr	r6, [pc, #256]	; (28f8 <_can_async_write+0x160>)
    27f8:	4032      	ands	r2, r6
    27fa:	4313      	orrs	r3, r2
    27fc:	6043      	str	r3, [r0, #4]
	f->T1.bit.BRS = hri_can_get_CCCR_BRSE_bit(dev->hw);
    27fe:	682b      	ldr	r3, [r5, #0]
	tmp = ((Can *)hw)->CCCR.reg;
    2800:	699b      	ldr	r3, [r3, #24]
	tmp = (tmp & CAN_CCCR_BRSE) >> CAN_CCCR_BRSE_Pos;
    2802:	0a5b      	lsrs	r3, r3, #9
    2804:	6842      	ldr	r2, [r0, #4]
    2806:	4023      	ands	r3, r4
    2808:	051b      	lsls	r3, r3, #20
    280a:	4e3c      	ldr	r6, [pc, #240]	; (28fc <_can_async_write+0x164>)
    280c:	4032      	ands	r2, r6
    280e:	4313      	orrs	r3, r2
    2810:	6043      	str	r3, [r0, #4]

	memcpy(f->data, msg->data, msg->len);
    2812:	3008      	adds	r0, #8
    2814:	688b      	ldr	r3, [r1, #8]
    2816:	7b0a      	ldrb	r2, [r1, #12]
    2818:	0019      	movs	r1, r3
    281a:	4b39      	ldr	r3, [pc, #228]	; (2900 <_can_async_write+0x168>)
    281c:	4798      	blx	r3

	hri_can_write_TXBAR_reg(dev->hw, 1 << hri_can_read_TXFQS_TFQPI_bf(dev->hw));
    281e:	6829      	ldr	r1, [r5, #0]
	return (((Can *)hw)->TXFQS.reg & CAN_TXFQS_TFQPI_Msk) >> CAN_TXFQS_TFQPI_Pos;
    2820:	23c4      	movs	r3, #196	; 0xc4
    2822:	58ca      	ldr	r2, [r1, r3]
    2824:	0c12      	lsrs	r2, r2, #16
    2826:	3ba5      	subs	r3, #165	; 0xa5
    2828:	4013      	ands	r3, r2
    282a:	409c      	lsls	r4, r3
	((Can *)hw)->TXBAR.reg = data;
    282c:	23d0      	movs	r3, #208	; 0xd0
    282e:	50cc      	str	r4, [r1, r3]
	return ERR_NONE;
    2830:	2000      	movs	r0, #0
}
    2832:	bd70      	pop	{r4, r5, r6, pc}
		f = (struct _can_tx_fifo_entry *)(can0_tx_fifo + put_index * CONF_CAN0_TBDS);
    2834:	0114      	lsls	r4, r2, #4
    2836:	4e33      	ldr	r6, [pc, #204]	; (2904 <_can_async_write+0x16c>)
    2838:	19a0      	adds	r0, r4, r6
    283a:	e7be      	b.n	27ba <_can_async_write+0x22>
		f = (struct _can_tx_fifo_entry *)(can1_tx_fifo + put_index * CONF_CAN1_TBDS);
    283c:	0112      	lsls	r2, r2, #4
    283e:	4832      	ldr	r0, [pc, #200]	; (2908 <_can_async_write+0x170>)
    2840:	1810      	adds	r0, r2, r0
    2842:	e7bd      	b.n	27c0 <_can_async_write+0x28>
		f->T0.val     = msg->id;
    2844:	680b      	ldr	r3, [r1, #0]
    2846:	6003      	str	r3, [r0, #0]
		f->T0.bit.XTD = 1;
    2848:	6802      	ldr	r2, [r0, #0]
    284a:	2380      	movs	r3, #128	; 0x80
    284c:	05db      	lsls	r3, r3, #23
    284e:	4313      	orrs	r3, r2
    2850:	6003      	str	r3, [r0, #0]
    2852:	e7be      	b.n	27d2 <_can_async_write+0x3a>
	} else if (msg->len <= 12) {
    2854:	2a0c      	cmp	r2, #12
    2856:	d807      	bhi.n	2868 <_can_async_write+0xd0>
		f->T1.bit.DLC = 0x9;
    2858:	6842      	ldr	r2, [r0, #4]
    285a:	4b26      	ldr	r3, [pc, #152]	; (28f4 <_can_async_write+0x15c>)
    285c:	401a      	ands	r2, r3
    285e:	2390      	movs	r3, #144	; 0x90
    2860:	031b      	lsls	r3, r3, #12
    2862:	4313      	orrs	r3, r2
    2864:	6043      	str	r3, [r0, #4]
    2866:	e7bf      	b.n	27e8 <_can_async_write+0x50>
	} else if (msg->len <= 16) {
    2868:	2a10      	cmp	r2, #16
    286a:	d807      	bhi.n	287c <_can_async_write+0xe4>
		f->T1.bit.DLC = 0xA;
    286c:	6842      	ldr	r2, [r0, #4]
    286e:	4b21      	ldr	r3, [pc, #132]	; (28f4 <_can_async_write+0x15c>)
    2870:	401a      	ands	r2, r3
    2872:	23a0      	movs	r3, #160	; 0xa0
    2874:	031b      	lsls	r3, r3, #12
    2876:	4313      	orrs	r3, r2
    2878:	6043      	str	r3, [r0, #4]
    287a:	e7b5      	b.n	27e8 <_can_async_write+0x50>
	} else if (msg->len <= 20) {
    287c:	2a14      	cmp	r2, #20
    287e:	d807      	bhi.n	2890 <_can_async_write+0xf8>
		f->T1.bit.DLC = 0xB;
    2880:	6842      	ldr	r2, [r0, #4]
    2882:	4b1c      	ldr	r3, [pc, #112]	; (28f4 <_can_async_write+0x15c>)
    2884:	401a      	ands	r2, r3
    2886:	23b0      	movs	r3, #176	; 0xb0
    2888:	031b      	lsls	r3, r3, #12
    288a:	4313      	orrs	r3, r2
    288c:	6043      	str	r3, [r0, #4]
    288e:	e7ab      	b.n	27e8 <_can_async_write+0x50>
	} else if (msg->len <= 24) {
    2890:	2a18      	cmp	r2, #24
    2892:	d807      	bhi.n	28a4 <_can_async_write+0x10c>
		f->T1.bit.DLC = 0xC;
    2894:	6842      	ldr	r2, [r0, #4]
    2896:	4b17      	ldr	r3, [pc, #92]	; (28f4 <_can_async_write+0x15c>)
    2898:	401a      	ands	r2, r3
    289a:	23c0      	movs	r3, #192	; 0xc0
    289c:	031b      	lsls	r3, r3, #12
    289e:	4313      	orrs	r3, r2
    28a0:	6043      	str	r3, [r0, #4]
    28a2:	e7a1      	b.n	27e8 <_can_async_write+0x50>
	} else if (msg->len <= 32) {
    28a4:	2a20      	cmp	r2, #32
    28a6:	d807      	bhi.n	28b8 <_can_async_write+0x120>
		f->T1.bit.DLC = 0xD;
    28a8:	6842      	ldr	r2, [r0, #4]
    28aa:	4b12      	ldr	r3, [pc, #72]	; (28f4 <_can_async_write+0x15c>)
    28ac:	401a      	ands	r2, r3
    28ae:	23d0      	movs	r3, #208	; 0xd0
    28b0:	031b      	lsls	r3, r3, #12
    28b2:	4313      	orrs	r3, r2
    28b4:	6043      	str	r3, [r0, #4]
    28b6:	e797      	b.n	27e8 <_can_async_write+0x50>
	} else if (msg->len <= 48) {
    28b8:	2a30      	cmp	r2, #48	; 0x30
    28ba:	d807      	bhi.n	28cc <_can_async_write+0x134>
		f->T1.bit.DLC = 0xE;
    28bc:	6842      	ldr	r2, [r0, #4]
    28be:	4b0d      	ldr	r3, [pc, #52]	; (28f4 <_can_async_write+0x15c>)
    28c0:	401a      	ands	r2, r3
    28c2:	23e0      	movs	r3, #224	; 0xe0
    28c4:	031b      	lsls	r3, r3, #12
    28c6:	4313      	orrs	r3, r2
    28c8:	6043      	str	r3, [r0, #4]
    28ca:	e78d      	b.n	27e8 <_can_async_write+0x50>
	} else if (msg->len <= 64) {
    28cc:	2a40      	cmp	r2, #64	; 0x40
    28ce:	d900      	bls.n	28d2 <_can_async_write+0x13a>
    28d0:	e78a      	b.n	27e8 <_can_async_write+0x50>
		f->T1.bit.DLC = 0xF;
    28d2:	6842      	ldr	r2, [r0, #4]
    28d4:	23f0      	movs	r3, #240	; 0xf0
    28d6:	031b      	lsls	r3, r3, #12
    28d8:	4313      	orrs	r3, r2
    28da:	6043      	str	r3, [r0, #4]
    28dc:	e784      	b.n	27e8 <_can_async_write+0x50>
		return ERR_NO_RESOURCE;
    28de:	201c      	movs	r0, #28
    28e0:	4240      	negs	r0, r0
    28e2:	e7a6      	b.n	2832 <_can_async_write+0x9a>
		return ERR_NO_RESOURCE;
    28e4:	201c      	movs	r0, #28
    28e6:	4240      	negs	r0, r0
    28e8:	e7a3      	b.n	2832 <_can_async_write+0x9a>
    28ea:	46c0      	nop			; (mov r8, r8)
    28ec:	42001c00 	.word	0x42001c00
    28f0:	42002000 	.word	0x42002000
    28f4:	fff0ffff 	.word	0xfff0ffff
    28f8:	ffdfffff 	.word	0xffdfffff
    28fc:	ffefffff 	.word	0xffefffff
    2900:	00003a85 	.word	0x00003a85
    2904:	20003690 	.word	0x20003690
    2908:	20003570 	.word	0x20003570

0000290c <_can_async_set_irq_state>:

/**
 * \brief Set CAN Interrupt State
 */
void _can_async_set_irq_state(struct _can_async_device *const dev, enum can_async_callback_type type, bool state)
{
    290c:	b510      	push	{r4, lr}
	uint32_t ie;

	if (type == CAN_ASYNC_RX_CB) {
    290e:	2900      	cmp	r1, #0
    2910:	d00b      	beq.n	292a <_can_async_set_irq_state+0x1e>
		hri_can_write_IE_RF0NE_bit(dev->hw, state);
	} else if (type == CAN_ASYNC_TX_CB) {
    2912:	2901      	cmp	r1, #1
    2914:	d010      	beq.n	2938 <_can_async_set_irq_state+0x2c>
		hri_can_write_IE_TCE_bit(dev->hw, state);
		hri_can_write_TXBTIE_reg(dev->hw, CAN_TXBTIE_MASK);
	} else if (type == CAN_ASYNC_IRQ_CB) {
    2916:	2902      	cmp	r1, #2
    2918:	d10d      	bne.n	2936 <_can_async_set_irq_state+0x2a>
		ie = hri_can_get_IE_reg(dev->hw, CAN_IE_RF0NE | CAN_IE_TCE);
    291a:	6801      	ldr	r1, [r0, #0]
	tmp = ((Can *)hw)->IE.reg;
    291c:	6d4b      	ldr	r3, [r1, #84]	; 0x54
	tmp &= mask;
    291e:	4a0d      	ldr	r2, [pc, #52]	; (2954 <_can_async_set_irq_state+0x48>)
    2920:	401a      	ands	r2, r3
		hri_can_write_IE_reg(dev->hw, ie | CONF_CAN0_IE_REG);
    2922:	4b0d      	ldr	r3, [pc, #52]	; (2958 <_can_async_set_irq_state+0x4c>)
    2924:	4313      	orrs	r3, r2
	((Can *)hw)->IE.reg = data;
    2926:	654b      	str	r3, [r1, #84]	; 0x54
	}

	return;
    2928:	e005      	b.n	2936 <_can_async_set_irq_state+0x2a>
		hri_can_write_IE_RF0NE_bit(dev->hw, state);
    292a:	6801      	ldr	r1, [r0, #0]
	tmp = ((Can *)hw)->IE.reg;
    292c:	6d4b      	ldr	r3, [r1, #84]	; 0x54
	tmp &= ~CAN_IE_RF0NE;
    292e:	2001      	movs	r0, #1
    2930:	4383      	bics	r3, r0
	tmp |= value << CAN_IE_RF0NE_Pos;
    2932:	431a      	orrs	r2, r3
	((Can *)hw)->IE.reg = tmp;
    2934:	654a      	str	r2, [r1, #84]	; 0x54
}
    2936:	bd10      	pop	{r4, pc}
		hri_can_write_IE_TCE_bit(dev->hw, state);
    2938:	6801      	ldr	r1, [r0, #0]
	tmp = ((Can *)hw)->IE.reg;
    293a:	6d4b      	ldr	r3, [r1, #84]	; 0x54
	tmp &= ~CAN_IE_TCE;
    293c:	4c07      	ldr	r4, [pc, #28]	; (295c <_can_async_set_irq_state+0x50>)
    293e:	4023      	ands	r3, r4
	tmp |= value << CAN_IE_TCE_Pos;
    2940:	0252      	lsls	r2, r2, #9
    2942:	431a      	orrs	r2, r3
	((Can *)hw)->IE.reg = tmp;
    2944:	654a      	str	r2, [r1, #84]	; 0x54
		hri_can_write_TXBTIE_reg(dev->hw, CAN_TXBTIE_MASK);
    2946:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->TXBTIE.reg = data;
    2948:	2101      	movs	r1, #1
    294a:	4249      	negs	r1, r1
    294c:	23e0      	movs	r3, #224	; 0xe0
    294e:	50d1      	str	r1, [r2, r3]
    2950:	e7f1      	b.n	2936 <_can_async_set_irq_state+0x2a>
    2952:	46c0      	nop			; (mov r8, r8)
    2954:	00000201 	.word	0x00000201
    2958:	03800008 	.word	0x03800008
    295c:	fffffdff 	.word	0xfffffdff

00002960 <_can_async_set_filter>:
/**
 * \brief Set CAN to the specified mode
 */
int32_t _can_async_set_filter(struct _can_async_device *const dev, uint8_t index, enum can_format fmt,
                              struct can_filter *filter)
{
    2960:	b530      	push	{r4, r5, lr}
	struct _can_standard_message_filter_element *sf;
	struct _can_extended_message_filter_element *ef;

	sf = &((struct _can_context *)dev->context)->rx_std_filter[index];
    2962:	6984      	ldr	r4, [r0, #24]
    2964:	0088      	lsls	r0, r1, #2
    2966:	68e5      	ldr	r5, [r4, #12]
    2968:	46ac      	mov	ip, r5
    296a:	4460      	add	r0, ip
	ef = &((struct _can_context *)dev->context)->rx_ext_filter[index];
    296c:	6924      	ldr	r4, [r4, #16]
    296e:	00c9      	lsls	r1, r1, #3
    2970:	1861      	adds	r1, r4, r1

	if (fmt == CAN_FMT_STDID) {
    2972:	2a00      	cmp	r2, #0
    2974:	d11d      	bne.n	29b2 <_can_async_set_filter+0x52>
		if (filter == NULL) {
    2976:	2b00      	cmp	r3, #0
    2978:	d019      	beq.n	29ae <_can_async_set_filter+0x4e>
			sf->S0.val = 0;
			return ERR_NONE;
		}
		sf->S0.val       = filter->mask;
    297a:	685a      	ldr	r2, [r3, #4]
    297c:	6002      	str	r2, [r0, #0]
		sf->S0.bit.SFID1 = filter->id;
    297e:	681b      	ldr	r3, [r3, #0]
    2980:	6802      	ldr	r2, [r0, #0]
    2982:	055b      	lsls	r3, r3, #21
    2984:	095b      	lsrs	r3, r3, #5
    2986:	4917      	ldr	r1, [pc, #92]	; (29e4 <_can_async_set_filter+0x84>)
    2988:	400a      	ands	r2, r1
    298a:	4313      	orrs	r3, r2
    298c:	6003      	str	r3, [r0, #0]
		sf->S0.bit.SFT   = _CAN_SFT_CLASSIC;
    298e:	6803      	ldr	r3, [r0, #0]
    2990:	009b      	lsls	r3, r3, #2
    2992:	089b      	lsrs	r3, r3, #2
    2994:	2280      	movs	r2, #128	; 0x80
    2996:	0612      	lsls	r2, r2, #24
    2998:	431a      	orrs	r2, r3
    299a:	6002      	str	r2, [r0, #0]
		sf->S0.bit.SFEC  = _CAN_SFEC_STF0M;
    299c:	6802      	ldr	r2, [r0, #0]
    299e:	4b12      	ldr	r3, [pc, #72]	; (29e8 <_can_async_set_filter+0x88>)
    29a0:	401a      	ands	r2, r3
    29a2:	2380      	movs	r3, #128	; 0x80
    29a4:	051b      	lsls	r3, r3, #20
    29a6:	4313      	orrs	r3, r2
    29a8:	6003      	str	r3, [r0, #0]
		ef->F1.val      = filter->mask;
		ef->F1.bit.EFT  = _CAN_EFT_CLASSIC;
	}

	return ERR_NONE;
}
    29aa:	2000      	movs	r0, #0
    29ac:	bd30      	pop	{r4, r5, pc}
			sf->S0.val = 0;
    29ae:	6003      	str	r3, [r0, #0]
			return ERR_NONE;
    29b0:	e7fb      	b.n	29aa <_can_async_set_filter+0x4a>
	} else if (fmt == CAN_FMT_EXTID) {
    29b2:	2a01      	cmp	r2, #1
    29b4:	d1f9      	bne.n	29aa <_can_async_set_filter+0x4a>
		if (filter == NULL) {
    29b6:	2b00      	cmp	r3, #0
    29b8:	d012      	beq.n	29e0 <_can_async_set_filter+0x80>
		ef->F0.val      = filter->id;
    29ba:	681a      	ldr	r2, [r3, #0]
    29bc:	600a      	str	r2, [r1, #0]
		ef->F0.bit.EFEC = _CAN_EFEC_STF0M;
    29be:	680a      	ldr	r2, [r1, #0]
    29c0:	00d2      	lsls	r2, r2, #3
    29c2:	08d2      	lsrs	r2, r2, #3
    29c4:	2080      	movs	r0, #128	; 0x80
    29c6:	0580      	lsls	r0, r0, #22
    29c8:	4310      	orrs	r0, r2
    29ca:	6008      	str	r0, [r1, #0]
		ef->F1.val      = filter->mask;
    29cc:	685b      	ldr	r3, [r3, #4]
    29ce:	604b      	str	r3, [r1, #4]
		ef->F1.bit.EFT  = _CAN_EFT_CLASSIC;
    29d0:	684b      	ldr	r3, [r1, #4]
    29d2:	009b      	lsls	r3, r3, #2
    29d4:	089b      	lsrs	r3, r3, #2
    29d6:	2280      	movs	r2, #128	; 0x80
    29d8:	0612      	lsls	r2, r2, #24
    29da:	431a      	orrs	r2, r3
    29dc:	604a      	str	r2, [r1, #4]
    29de:	e7e4      	b.n	29aa <_can_async_set_filter+0x4a>
			ef->F0.val = 0;
    29e0:	600b      	str	r3, [r1, #0]
			return ERR_NONE;
    29e2:	e7e2      	b.n	29aa <_can_async_set_filter+0x4a>
    29e4:	f800ffff 	.word	0xf800ffff
    29e8:	c7ffffff 	.word	0xc7ffffff

000029ec <CAN0_Handler>:

/*
 * \brief CAN interrupt handler
 */
void CAN0_Handler(void)
{
    29ec:	b570      	push	{r4, r5, r6, lr}
	struct _can_async_device *dev = _can0_dev;
    29ee:	4b1a      	ldr	r3, [pc, #104]	; (2a58 <CAN0_Handler+0x6c>)
    29f0:	681d      	ldr	r5, [r3, #0]
	uint32_t                  ir;
	ir = hri_can_read_IR_reg(dev->hw);
    29f2:	682b      	ldr	r3, [r5, #0]
	return ((Can *)hw)->IR.reg;
    29f4:	6d1c      	ldr	r4, [r3, #80]	; 0x50

	if (ir & CAN_IR_RF0N) {
    29f6:	07e3      	lsls	r3, r4, #31
    29f8:	d414      	bmi.n	2a24 <CAN0_Handler+0x38>
		dev->cb.rx_done(dev);
	}

	if (ir & CAN_IR_TC) {
    29fa:	05a3      	lsls	r3, r4, #22
    29fc:	d416      	bmi.n	2a2c <CAN0_Handler+0x40>
		dev->cb.tx_done(dev);
	}

	if (ir & CAN_IR_BO) {
    29fe:	01a3      	lsls	r3, r4, #6
    2a00:	d418      	bmi.n	2a34 <CAN0_Handler+0x48>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
	}

	if (ir & CAN_IR_EW) {
    2a02:	01e3      	lsls	r3, r4, #7
    2a04:	d41b      	bmi.n	2a3e <CAN0_Handler+0x52>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
	}

	if (ir & CAN_IR_EP) {
    2a06:	0223      	lsls	r3, r4, #8
    2a08:	d507      	bpl.n	2a1a <CAN0_Handler+0x2e>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
    2a0a:	68eb      	ldr	r3, [r5, #12]
    2a0c:	682a      	ldr	r2, [r5, #0]
	return (((Can *)hw)->PSR.reg & CAN_PSR_EP) >> CAN_PSR_EP_Pos;
    2a0e:	6c52      	ldr	r2, [r2, #68]	; 0x44
    2a10:	0692      	lsls	r2, r2, #26
    2a12:	d519      	bpl.n	2a48 <CAN0_Handler+0x5c>
    2a14:	2102      	movs	r1, #2
    2a16:	0028      	movs	r0, r5
    2a18:	4798      	blx	r3
	}

	if (ir & CAN_IR_RF0L) {
    2a1a:	0723      	lsls	r3, r4, #28
    2a1c:	d416      	bmi.n	2a4c <CAN0_Handler+0x60>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
	}

	hri_can_write_IR_reg(dev->hw, ir);
    2a1e:	682b      	ldr	r3, [r5, #0]
	((Can *)hw)->IR.reg = data;
    2a20:	651c      	str	r4, [r3, #80]	; 0x50
}
    2a22:	bd70      	pop	{r4, r5, r6, pc}
		dev->cb.rx_done(dev);
    2a24:	0028      	movs	r0, r5
    2a26:	68ab      	ldr	r3, [r5, #8]
    2a28:	4798      	blx	r3
    2a2a:	e7e6      	b.n	29fa <CAN0_Handler+0xe>
		dev->cb.tx_done(dev);
    2a2c:	0028      	movs	r0, r5
    2a2e:	686b      	ldr	r3, [r5, #4]
    2a30:	4798      	blx	r3
    2a32:	e7e4      	b.n	29fe <CAN0_Handler+0x12>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
    2a34:	2103      	movs	r1, #3
    2a36:	0028      	movs	r0, r5
    2a38:	68eb      	ldr	r3, [r5, #12]
    2a3a:	4798      	blx	r3
    2a3c:	e7e1      	b.n	2a02 <CAN0_Handler+0x16>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
    2a3e:	2100      	movs	r1, #0
    2a40:	0028      	movs	r0, r5
    2a42:	68eb      	ldr	r3, [r5, #12]
    2a44:	4798      	blx	r3
    2a46:	e7de      	b.n	2a06 <CAN0_Handler+0x1a>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
    2a48:	2101      	movs	r1, #1
    2a4a:	e7e4      	b.n	2a16 <CAN0_Handler+0x2a>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
    2a4c:	2104      	movs	r1, #4
    2a4e:	0028      	movs	r0, r5
    2a50:	68eb      	ldr	r3, [r5, #12]
    2a52:	4798      	blx	r3
    2a54:	e7e3      	b.n	2a1e <CAN0_Handler+0x32>
    2a56:	46c0      	nop			; (mov r8, r8)
    2a58:	20002af4 	.word	0x20002af4

00002a5c <CAN1_Handler>:

/*
 * \brief CAN interrupt handler
 */
void CAN1_Handler(void)
{
    2a5c:	b570      	push	{r4, r5, r6, lr}
	struct _can_async_device *dev = _can1_dev;
    2a5e:	4b1a      	ldr	r3, [pc, #104]	; (2ac8 <CAN1_Handler+0x6c>)
    2a60:	6edd      	ldr	r5, [r3, #108]	; 0x6c
	uint32_t                  ir;
	ir = hri_can_read_IR_reg(dev->hw);
    2a62:	682b      	ldr	r3, [r5, #0]
	return ((Can *)hw)->IR.reg;
    2a64:	6d1c      	ldr	r4, [r3, #80]	; 0x50

	if (ir & CAN_IR_RF0N) {
    2a66:	07e3      	lsls	r3, r4, #31
    2a68:	d414      	bmi.n	2a94 <CAN1_Handler+0x38>
		dev->cb.rx_done(dev);
	}

	if (ir & CAN_IR_TC) {
    2a6a:	05a3      	lsls	r3, r4, #22
    2a6c:	d416      	bmi.n	2a9c <CAN1_Handler+0x40>
		dev->cb.tx_done(dev);
	}

	if (ir & CAN_IR_BO) {
    2a6e:	01a3      	lsls	r3, r4, #6
    2a70:	d418      	bmi.n	2aa4 <CAN1_Handler+0x48>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
	}

	if (ir & CAN_IR_EW) {
    2a72:	01e3      	lsls	r3, r4, #7
    2a74:	d41b      	bmi.n	2aae <CAN1_Handler+0x52>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
	}

	if (ir & CAN_IR_EP) {
    2a76:	0223      	lsls	r3, r4, #8
    2a78:	d507      	bpl.n	2a8a <CAN1_Handler+0x2e>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
    2a7a:	68eb      	ldr	r3, [r5, #12]
    2a7c:	682a      	ldr	r2, [r5, #0]
	return (((Can *)hw)->PSR.reg & CAN_PSR_EP) >> CAN_PSR_EP_Pos;
    2a7e:	6c52      	ldr	r2, [r2, #68]	; 0x44
    2a80:	0692      	lsls	r2, r2, #26
    2a82:	d519      	bpl.n	2ab8 <CAN1_Handler+0x5c>
    2a84:	2102      	movs	r1, #2
    2a86:	0028      	movs	r0, r5
    2a88:	4798      	blx	r3
	}

	if (ir & CAN_IR_RF0L) {
    2a8a:	0723      	lsls	r3, r4, #28
    2a8c:	d416      	bmi.n	2abc <CAN1_Handler+0x60>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
	}

	hri_can_write_IR_reg(dev->hw, ir);
    2a8e:	682b      	ldr	r3, [r5, #0]
	((Can *)hw)->IR.reg = data;
    2a90:	651c      	str	r4, [r3, #80]	; 0x50
}
    2a92:	bd70      	pop	{r4, r5, r6, pc}
		dev->cb.rx_done(dev);
    2a94:	0028      	movs	r0, r5
    2a96:	68ab      	ldr	r3, [r5, #8]
    2a98:	4798      	blx	r3
    2a9a:	e7e6      	b.n	2a6a <CAN1_Handler+0xe>
		dev->cb.tx_done(dev);
    2a9c:	0028      	movs	r0, r5
    2a9e:	686b      	ldr	r3, [r5, #4]
    2aa0:	4798      	blx	r3
    2aa2:	e7e4      	b.n	2a6e <CAN1_Handler+0x12>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
    2aa4:	2103      	movs	r1, #3
    2aa6:	0028      	movs	r0, r5
    2aa8:	68eb      	ldr	r3, [r5, #12]
    2aaa:	4798      	blx	r3
    2aac:	e7e1      	b.n	2a72 <CAN1_Handler+0x16>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
    2aae:	2100      	movs	r1, #0
    2ab0:	0028      	movs	r0, r5
    2ab2:	68eb      	ldr	r3, [r5, #12]
    2ab4:	4798      	blx	r3
    2ab6:	e7de      	b.n	2a76 <CAN1_Handler+0x1a>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
    2ab8:	2101      	movs	r1, #1
    2aba:	e7e4      	b.n	2a86 <CAN1_Handler+0x2a>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
    2abc:	2104      	movs	r1, #4
    2abe:	0028      	movs	r0, r5
    2ac0:	68eb      	ldr	r3, [r5, #12]
    2ac2:	4798      	blx	r3
    2ac4:	e7e3      	b.n	2a8e <CAN1_Handler+0x32>
    2ac6:	46c0      	nop			; (mov r8, r8)
    2ac8:	20002af4 	.word	0x20002af4

00002acc <_irq_set>:
/**
 * \brief Set the given IRQ
 */
void _irq_set(uint8_t n)
{
	NVIC_SetPendingIRQ((IRQn_Type)n);
    2acc:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    2ace:	2b00      	cmp	r3, #0
    2ad0:	db07      	blt.n	2ae2 <_irq_set+0x16>
    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2ad2:	231f      	movs	r3, #31
    2ad4:	4018      	ands	r0, r3
    2ad6:	3b1e      	subs	r3, #30
    2ad8:	4083      	lsls	r3, r0
    2ada:	2280      	movs	r2, #128	; 0x80
    2adc:	0052      	lsls	r2, r2, #1
    2ade:	4901      	ldr	r1, [pc, #4]	; (2ae4 <_irq_set+0x18>)
    2ae0:	508b      	str	r3, [r1, r2]
}
    2ae2:	4770      	bx	lr
    2ae4:	e000e100 	.word	0xe000e100

00002ae8 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    2ae8:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
    2aea:	4b08      	ldr	r3, [pc, #32]	; (2b0c <_init_chip+0x24>)
    2aec:	685a      	ldr	r2, [r3, #4]
    2aee:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    2af0:	4b07      	ldr	r3, [pc, #28]	; (2b10 <_init_chip+0x28>)
    2af2:	4798      	blx	r3
	_oscctrl_init_sources();
    2af4:	4b07      	ldr	r3, [pc, #28]	; (2b14 <_init_chip+0x2c>)
    2af6:	4798      	blx	r3
	_mclk_init();
    2af8:	4b07      	ldr	r3, [pc, #28]	; (2b18 <_init_chip+0x30>)
    2afa:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
    2afc:	4b07      	ldr	r3, [pc, #28]	; (2b1c <_init_chip+0x34>)
    2afe:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    2b00:	20ff      	movs	r0, #255	; 0xff
    2b02:	4b07      	ldr	r3, [pc, #28]	; (2b20 <_init_chip+0x38>)
    2b04:	4798      	blx	r3

	_div_init();
    2b06:	4b07      	ldr	r3, [pc, #28]	; (2b24 <_init_chip+0x3c>)
    2b08:	4798      	blx	r3
#endif

#if (CONF_PORT_EVCTRL_PORT_0 | CONF_PORT_EVCTRL_PORT_1 | CONF_PORT_EVCTRL_PORT_2 | CONF_PORT_EVCTRL_PORT_3)
	_port_event_init();
#endif
}
    2b0a:	bd10      	pop	{r4, pc}
    2b0c:	41004000 	.word	0x41004000
    2b10:	00002ca1 	.word	0x00002ca1
    2b14:	00002cbd 	.word	0x00002cbd
    2b18:	00002c05 	.word	0x00002c05
    2b1c:	00002cf9 	.word	0x00002cf9
    2b20:	00002be1 	.word	0x00002be1
    2b24:	00002b29 	.word	0x00002b29

00002b28 <_div_init>:

static inline void hri_divas_write_CTRLA_DLZ_bit(const void *const hw, bool value)
{
	uint8_t tmp;
	DIVAS_CRITICAL_SECTION_ENTER();
	tmp = ((Divas *)hw)->CTRLA.reg;
    2b28:	2290      	movs	r2, #144	; 0x90
    2b2a:	05d2      	lsls	r2, r2, #23
    2b2c:	7813      	ldrb	r3, [r2, #0]
	tmp &= ~DIVAS_CTRLA_DLZ;
    2b2e:	2102      	movs	r1, #2
    2b30:	438b      	bics	r3, r1
	tmp |= value << DIVAS_CTRLA_DLZ_Pos;
	((Divas *)hw)->CTRLA.reg = tmp;
    2b32:	7013      	strb	r3, [r2, #0]
 * \brief Initialize hardware for division operation
 */
void _div_init(void)
{
	hri_divas_write_CTRLA_DLZ_bit(DIVAS, CONF_DIVAS_DLZ);
}
    2b34:	4770      	bx	lr

00002b36 <__aeabi_idiv>:

/**
 * \brief Do signed division
 */
int32_t __aeabi_idiv(int32_t numerator, int32_t denominator)
{
    2b36:	b510      	push	{r4, lr}
    2b38:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    2b3a:	f3ef 8310 	mrs	r3, PRIMASK
	int32_t res;
	_DIVAS_CRITICAL_ENTER();
    2b3e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
    2b40:	b672      	cpsid	i
	DIVAS->CTRLA.bit.SIGNED = s;
    2b42:	2390      	movs	r3, #144	; 0x90
    2b44:	05db      	lsls	r3, r3, #23
    2b46:	781a      	ldrb	r2, [r3, #0]
    2b48:	2401      	movs	r4, #1
    2b4a:	4322      	orrs	r2, r4
    2b4c:	701a      	strb	r2, [r3, #0]
	DIVAS->DIVIDEND.reg     = n;
    2b4e:	6098      	str	r0, [r3, #8]
	DIVAS->DIVISOR.reg      = d;
    2b50:	60d9      	str	r1, [r3, #12]
	while (DIVAS->STATUS.bit.BUSY) {
    2b52:	2390      	movs	r3, #144	; 0x90
    2b54:	05db      	lsls	r3, r3, #23
    2b56:	791b      	ldrb	r3, [r3, #4]
    2b58:	07db      	lsls	r3, r3, #31
    2b5a:	d4fa      	bmi.n	2b52 <__aeabi_idiv+0x1c>
	_divas_div(1, numerator, denominator);
	res = _divas_result32();
    2b5c:	2390      	movs	r3, #144	; 0x90
    2b5e:	05db      	lsls	r3, r3, #23
    2b60:	6918      	ldr	r0, [r3, #16]
	_DIVAS_CRITICAL_LEAVE();
    2b62:	9b01      	ldr	r3, [sp, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    2b64:	f383 8810 	msr	PRIMASK, r3
	return res;
}
    2b68:	b002      	add	sp, #8
    2b6a:	bd10      	pop	{r4, pc}

00002b6c <__aeabi_uidiv>:

/**
 * \brief Do unsigned division
 */
uint32_t __aeabi_uidiv(uint32_t numerator, uint32_t denominator)
{
    2b6c:	b510      	push	{r4, lr}
    2b6e:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    2b70:	f3ef 8310 	mrs	r3, PRIMASK
	uint32_t res;
	_DIVAS_CRITICAL_ENTER();
    2b74:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
    2b76:	b672      	cpsid	i
	DIVAS->CTRLA.bit.SIGNED = s;
    2b78:	2390      	movs	r3, #144	; 0x90
    2b7a:	05db      	lsls	r3, r3, #23
    2b7c:	781a      	ldrb	r2, [r3, #0]
    2b7e:	2401      	movs	r4, #1
    2b80:	43a2      	bics	r2, r4
    2b82:	701a      	strb	r2, [r3, #0]
	DIVAS->DIVIDEND.reg     = n;
    2b84:	6098      	str	r0, [r3, #8]
	DIVAS->DIVISOR.reg      = d;
    2b86:	60d9      	str	r1, [r3, #12]
	while (DIVAS->STATUS.bit.BUSY) {
    2b88:	2390      	movs	r3, #144	; 0x90
    2b8a:	05db      	lsls	r3, r3, #23
    2b8c:	791b      	ldrb	r3, [r3, #4]
    2b8e:	07db      	lsls	r3, r3, #31
    2b90:	d4fa      	bmi.n	2b88 <__aeabi_uidiv+0x1c>
	_divas_div(0, numerator, denominator);
	res = _divas_result32();
    2b92:	2390      	movs	r3, #144	; 0x90
    2b94:	05db      	lsls	r3, r3, #23
    2b96:	6918      	ldr	r0, [r3, #16]
	_DIVAS_CRITICAL_LEAVE();
    2b98:	9b01      	ldr	r3, [sp, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    2b9a:	f383 8810 	msr	PRIMASK, r3
	return res;
}
    2b9e:	b002      	add	sp, #8
    2ba0:	bd10      	pop	{r4, pc}
	...

00002ba4 <__aeabi_uidivmod>:

/**
 * \brief Do unsigned division, return result and remainder
 */
uint64_t __aeabi_uidivmod(unsigned numerator, unsigned denominator)
{
    2ba4:	b510      	push	{r4, lr}
    2ba6:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    2ba8:	f3ef 8310 	mrs	r3, PRIMASK
	uint64_t res;
	_DIVAS_CRITICAL_ENTER();
    2bac:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
    2bae:	b672      	cpsid	i
	DIVAS->CTRLA.bit.SIGNED = s;
    2bb0:	2390      	movs	r3, #144	; 0x90
    2bb2:	05db      	lsls	r3, r3, #23
    2bb4:	781a      	ldrb	r2, [r3, #0]
    2bb6:	2401      	movs	r4, #1
    2bb8:	43a2      	bics	r2, r4
    2bba:	701a      	strb	r2, [r3, #0]
	DIVAS->DIVIDEND.reg     = n;
    2bbc:	6098      	str	r0, [r3, #8]
	DIVAS->DIVISOR.reg      = d;
    2bbe:	60d9      	str	r1, [r3, #12]
	while (DIVAS->STATUS.bit.BUSY) {
    2bc0:	2390      	movs	r3, #144	; 0x90
    2bc2:	05db      	lsls	r3, r3, #23
    2bc4:	791b      	ldrb	r3, [r3, #4]
    2bc6:	07db      	lsls	r3, r3, #31
    2bc8:	d4fa      	bmi.n	2bc0 <__aeabi_uidivmod+0x1c>
	_divas_div(0, numerator, denominator);
	res = _divas_result64();
    2bca:	4b04      	ldr	r3, [pc, #16]	; (2bdc <__aeabi_uidivmod+0x38>)
    2bcc:	6818      	ldr	r0, [r3, #0]
    2bce:	6859      	ldr	r1, [r3, #4]
	_DIVAS_CRITICAL_LEAVE();
    2bd0:	9b01      	ldr	r3, [sp, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    2bd2:	f383 8810 	msr	PRIMASK, r3
	return res;
}
    2bd6:	b002      	add	sp, #8
    2bd8:	bd10      	pop	{r4, pc}
    2bda:	46c0      	nop			; (mov r8, r8)
    2bdc:	48000010 	.word	0x48000010

00002be0 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    2be0:	07c3      	lsls	r3, r0, #31
    2be2:	d507      	bpl.n	2bf4 <_gclk_init_generators_by_fref+0x14>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    2be4:	4a04      	ldr	r2, [pc, #16]	; (2bf8 <_gclk_init_generators_by_fref+0x18>)
    2be6:	4b05      	ldr	r3, [pc, #20]	; (2bfc <_gclk_init_generators_by_fref+0x1c>)
    2be8:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    2bea:	4b04      	ldr	r3, [pc, #16]	; (2bfc <_gclk_init_generators_by_fref+0x1c>)
    2bec:	685a      	ldr	r2, [r3, #4]
    2bee:	4b04      	ldr	r3, [pc, #16]	; (2c00 <_gclk_init_generators_by_fref+0x20>)
    2bf0:	421a      	tst	r2, r3
    2bf2:	d1fa      	bne.n	2bea <_gclk_init_generators_by_fref+0xa>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SOURCE);
	}
#endif
}
    2bf4:	4770      	bx	lr
    2bf6:	46c0      	nop			; (mov r8, r8)
    2bf8:	00010106 	.word	0x00010106
    2bfc:	40001c00 	.word	0x40001c00
    2c00:	000007fd 	.word	0x000007fd

00002c04 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    2c04:	2201      	movs	r2, #1
    2c06:	4b01      	ldr	r3, [pc, #4]	; (2c0c <_mclk_init+0x8>)
    2c08:	711a      	strb	r2, [r3, #4]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_CPUDIV(CONF_MCLK_CPUDIV));
}
    2c0a:	4770      	bx	lr
    2c0c:	40000800 	.word	0x40000800

00002c10 <_flash_init>:

/**
 * \brief Initialize NVM
 */
int32_t _flash_init(struct _flash_device *const device, void *const hw)
{
    2c10:	b570      	push	{r4, r5, r6, lr}
    2c12:	0005      	movs	r5, r0
    2c14:	000c      	movs	r4, r1
	ASSERT(device && (hw == NVMCTRL));
    2c16:	2800      	cmp	r0, #0
    2c18:	d01c      	beq.n	2c54 <_flash_init+0x44>
    2c1a:	4b10      	ldr	r3, [pc, #64]	; (2c5c <_flash_init+0x4c>)
    2c1c:	4299      	cmp	r1, r3
    2c1e:	d01b      	beq.n	2c58 <_flash_init+0x48>
    2c20:	2000      	movs	r0, #0
    2c22:	2246      	movs	r2, #70	; 0x46
    2c24:	490e      	ldr	r1, [pc, #56]	; (2c60 <_flash_init+0x50>)
    2c26:	4b0f      	ldr	r3, [pc, #60]	; (2c64 <_flash_init+0x54>)
    2c28:	4798      	blx	r3
	uint32_t ctrlb;

	device->hw = hw;
    2c2a:	612c      	str	r4, [r5, #16]
}

static inline hri_nvmctrl_ctrlb_reg_t hri_nvmctrl_get_CTRLB_reg(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Nvmctrl *)hw)->CTRLB.reg;
    2c2c:	6862      	ldr	r2, [r4, #4]
	tmp &= mask;
    2c2e:	239e      	movs	r3, #158	; 0x9e
    2c30:	4013      	ands	r3, r2
}

static inline void hri_nvmctrl_write_CTRLB_reg(const void *const hw, hri_nvmctrl_ctrlb_reg_t data)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg = data;
    2c32:	6063      	str	r3, [r4, #4]
	ctrlb      = _nvm.ctrlb & ~(NVMCTRL_CTRLB_RWS_Msk | NVMCTRL_CTRLB_MANW);
	ctrlb |= hri_nvmctrl_get_CTRLB_reg(device->hw, NVMCTRL_CTRLB_RWS_Msk | NVMCTRL_CTRLB_MANW);
	hri_nvmctrl_write_CTRLB_reg(device->hw, ctrlb);

	_nvm_dev = device;
    2c34:	4b0c      	ldr	r3, [pc, #48]	; (2c68 <_flash_init+0x58>)
    2c36:	601d      	str	r5, [r3, #0]
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2c38:	4b0c      	ldr	r3, [pc, #48]	; (2c6c <_flash_init+0x5c>)
    2c3a:	2240      	movs	r2, #64	; 0x40
    2c3c:	2180      	movs	r1, #128	; 0x80
    2c3e:	505a      	str	r2, [r3, r1]
  __ASM volatile ("dsb 0xF":::"memory");
    2c40:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2c44:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2c48:	3101      	adds	r1, #1
    2c4a:	31ff      	adds	r1, #255	; 0xff
    2c4c:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2c4e:	601a      	str	r2, [r3, #0]
	NVIC_DisableIRQ(NVMCTRL_IRQn);
	NVIC_ClearPendingIRQ(NVMCTRL_IRQn);
	NVIC_EnableIRQ(NVMCTRL_IRQn);
	return ERR_NONE;
}
    2c50:	2000      	movs	r0, #0
    2c52:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(device && (hw == NVMCTRL));
    2c54:	2000      	movs	r0, #0
    2c56:	e7e4      	b.n	2c22 <_flash_init+0x12>
    2c58:	2001      	movs	r0, #1
    2c5a:	e7e2      	b.n	2c22 <_flash_init+0x12>
    2c5c:	41004000 	.word	0x41004000
    2c60:	00003be8 	.word	0x00003be8
    2c64:	0000245d 	.word	0x0000245d
    2c68:	20002bcc 	.word	0x20002bcc
    2c6c:	e000e100 	.word	0xe000e100

00002c70 <NVMCTRL_Handler>:

/**
 * \internal NVM interrupt handler
 */
void NVMCTRL_Handler(void)
{
    2c70:	b510      	push	{r4, lr}
	void *const hw = _nvm_dev->hw;
    2c72:	4b0a      	ldr	r3, [pc, #40]	; (2c9c <NVMCTRL_Handler+0x2c>)
    2c74:	6818      	ldr	r0, [r3, #0]
    2c76:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_READY) >> NVMCTRL_INTFLAG_READY_Pos;
    2c78:	7d1a      	ldrb	r2, [r3, #20]

	if (hri_nvmctrl_get_interrupt_READY_bit(hw)) {
    2c7a:	07d2      	lsls	r2, r2, #31
    2c7c:	d504      	bpl.n	2c88 <NVMCTRL_Handler+0x18>
		if (NULL != _nvm_dev->flash_cb.ready_cb) {
    2c7e:	6803      	ldr	r3, [r0, #0]
    2c80:	2b00      	cmp	r3, #0
    2c82:	d000      	beq.n	2c86 <NVMCTRL_Handler+0x16>
			_nvm_dev->flash_cb.ready_cb(_nvm_dev);
    2c84:	4798      	blx	r3
		hri_nvmctrl_clear_interrupt_ERROR_bit(hw);
		if (NULL != _nvm_dev->flash_cb.error_cb) {
			_nvm_dev->flash_cb.error_cb(_nvm_dev);
		}
	}
}
    2c86:	bd10      	pop	{r4, pc}
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_ERROR) >> NVMCTRL_INTFLAG_ERROR_Pos;
    2c88:	7d1a      	ldrb	r2, [r3, #20]
	} else if (hri_nvmctrl_get_interrupt_ERROR_bit(hw)) {
    2c8a:	0792      	lsls	r2, r2, #30
    2c8c:	d5fb      	bpl.n	2c86 <NVMCTRL_Handler+0x16>
	((Nvmctrl *)hw)->INTFLAG.reg = NVMCTRL_INTFLAG_ERROR;
    2c8e:	2202      	movs	r2, #2
    2c90:	751a      	strb	r2, [r3, #20]
		if (NULL != _nvm_dev->flash_cb.error_cb) {
    2c92:	6843      	ldr	r3, [r0, #4]
    2c94:	2b00      	cmp	r3, #0
    2c96:	d0f6      	beq.n	2c86 <NVMCTRL_Handler+0x16>
			_nvm_dev->flash_cb.error_cb(_nvm_dev);
    2c98:	4798      	blx	r3
}
    2c9a:	e7f4      	b.n	2c86 <NVMCTRL_Handler+0x16>
    2c9c:	20002bcc 	.word	0x20002bcc

00002ca0 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    2ca0:	4a05      	ldr	r2, [pc, #20]	; (2cb8 <_osc32kctrl_init_sources+0x18>)
    2ca2:	69d3      	ldr	r3, [r2, #28]
	tmp = (tmp & OSC32KCTRL_OSCULP32K_CALIB_Msk) >> OSC32KCTRL_OSCULP32K_CALIB_Pos;
    2ca4:	0a1b      	lsrs	r3, r3, #8
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSC32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSC32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    2ca6:	021b      	lsls	r3, r3, #8
    2ca8:	21f8      	movs	r1, #248	; 0xf8
    2caa:	0149      	lsls	r1, r1, #5
    2cac:	400b      	ands	r3, r1
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    2cae:	61d3      	str	r3, [r2, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    2cb0:	2301      	movs	r3, #1
    2cb2:	6113      	str	r3, [r2, #16]
		;
#endif
#endif
	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    2cb4:	4770      	bx	lr
    2cb6:	46c0      	nop			; (mov r8, r8)
    2cb8:	40001400 	.word	0x40001400

00002cbc <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_OSC48MCTRL_reg(const void *const hw, hri_oscctrl_osc48mctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MCTRL.reg = data;
    2cbc:	4b0d      	ldr	r3, [pc, #52]	; (2cf4 <_oscctrl_init_sources+0x38>)
    2cbe:	2202      	movs	r2, #2
    2cc0:	751a      	strb	r2, [r3, #20]
}

static inline void hri_oscctrl_write_OSC48MDIV_reg(const void *const hw, hri_oscctrl_osc48mdiv_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MDIV.reg = data;
    2cc2:	3209      	adds	r2, #9
    2cc4:	755a      	strb	r2, [r3, #21]
	while (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & reg) {
    2cc6:	4b0b      	ldr	r3, [pc, #44]	; (2cf4 <_oscctrl_init_sources+0x38>)
    2cc8:	699b      	ldr	r3, [r3, #24]
    2cca:	075b      	lsls	r3, r3, #29
    2ccc:	d4fb      	bmi.n	2cc6 <_oscctrl_init_sources+0xa>
	return (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV)
    2cce:	4b09      	ldr	r3, [pc, #36]	; (2cf4 <_oscctrl_init_sources+0x38>)
    2cd0:	699b      	ldr	r3, [r3, #24]
#if CONF_OSC48M_CONFIG == 1
	hri_oscctrl_write_OSC48MCTRL_reg(hw,
	                                 (CONF_OSC48M_RUNSTDBY << OSCCTRL_OSC48MCTRL_RUNSTDBY_Pos)
	                                     | (CONF_OSC48M_ENABLE << OSCCTRL_OSC48MCTRL_ENABLE_Pos));
	hri_oscctrl_write_OSC48MDIV_reg(hw, OSCCTRL_OSC48MDIV_DIV(CONF_OSC48M_DIV));
	while (hri_oscctrl_get_OSC48MSYNCBUSY_OSC48MDIV_bit(hw))
    2cd2:	075b      	lsls	r3, r3, #29
    2cd4:	d4fb      	bmi.n	2cce <_oscctrl_init_sources+0x12>
}

static inline void hri_oscctrl_write_OSC48MSTUP_reg(const void *const hw, hri_oscctrl_osc48mstup_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MSTUP.reg = data;
    2cd6:	2207      	movs	r2, #7
    2cd8:	4b06      	ldr	r3, [pc, #24]	; (2cf4 <_oscctrl_init_sources+0x38>)
    2cda:	759a      	strb	r2, [r3, #22]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_OSC48MRDY) >> OSCCTRL_STATUS_OSC48MRDY_Pos;
    2cdc:	4b05      	ldr	r3, [pc, #20]	; (2cf4 <_oscctrl_init_sources+0x38>)
    2cde:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC48M_CONFIG == 1
#if CONF_OSC48M_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_OSC48MRDY_bit(hw))
    2ce0:	06db      	lsls	r3, r3, #27
    2ce2:	d5fb      	bpl.n	2cdc <_oscctrl_init_sources+0x20>
	((Oscctrl *)hw)->OSC48MCTRL.reg |= OSCCTRL_OSC48MCTRL_ONDEMAND;
    2ce4:	4a03      	ldr	r2, [pc, #12]	; (2cf4 <_oscctrl_init_sources+0x38>)
    2ce6:	7d13      	ldrb	r3, [r2, #20]
    2ce8:	2180      	movs	r1, #128	; 0x80
    2cea:	4249      	negs	r1, r1
    2cec:	430b      	orrs	r3, r1
    2cee:	b2db      	uxtb	r3, r3
    2cf0:	7513      	strb	r3, [r2, #20]
#if CONF_OSC48M_ONDEMAND == 1
	hri_oscctrl_set_OSC48MCTRL_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
    2cf2:	4770      	bx	lr
    2cf4:	40001000 	.word	0x40001000

00002cf8 <_oscctrl_init_referenced_generators>:
#if CONF_DPLL_ONDEMAND == 1
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
    2cf8:	4770      	bx	lr
	...

00002cfc <_sercom_get_hardware_index>:
{
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
    2cfc:	4b02      	ldr	r3, [pc, #8]	; (2d08 <_sercom_get_hardware_index+0xc>)
    2cfe:	469c      	mov	ip, r3
    2d00:	4460      	add	r0, ip
    2d02:	0a80      	lsrs	r0, r0, #10
    2d04:	b2c0      	uxtb	r0, r0
}
    2d06:	4770      	bx	lr
    2d08:	bdfffc00 	.word	0xbdfffc00

00002d0c <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    2d0c:	b570      	push	{r4, r5, r6, lr}
    2d0e:	0006      	movs	r6, r0
    2d10:	000c      	movs	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    2d12:	0008      	movs	r0, r1
    2d14:	4b71      	ldr	r3, [pc, #452]	; (2edc <_spi_m_sync_init+0x1d0>)
    2d16:	4798      	blx	r3
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    2d18:	2300      	movs	r3, #0
    2d1a:	2b00      	cmp	r3, #0
    2d1c:	d100      	bne.n	2d20 <_spi_m_sync_init+0x14>
    2d1e:	e084      	b.n	2e2a <_spi_m_sync_init+0x11e>
	return NULL;
    2d20:	2500      	movs	r5, #0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
    2d22:	2e00      	cmp	r6, #0
    2d24:	d100      	bne.n	2d28 <_spi_m_sync_init+0x1c>
    2d26:	e08d      	b.n	2e44 <_spi_m_sync_init+0x138>
    2d28:	2c00      	cmp	r4, #0
    2d2a:	d100      	bne.n	2d2e <_spi_m_sync_init+0x22>
    2d2c:	e088      	b.n	2e40 <_spi_m_sync_init+0x134>
    2d2e:	2001      	movs	r0, #1
    2d30:	4a6b      	ldr	r2, [pc, #428]	; (2ee0 <_spi_m_sync_init+0x1d4>)
    2d32:	496c      	ldr	r1, [pc, #432]	; (2ee4 <_spi_m_sync_init+0x1d8>)
    2d34:	4b6c      	ldr	r3, [pc, #432]	; (2ee8 <_spi_m_sync_init+0x1dc>)
    2d36:	4798      	blx	r3

	if (regs == NULL) {
    2d38:	2d00      	cmp	r5, #0
    2d3a:	d100      	bne.n	2d3e <_spi_m_sync_init+0x32>
    2d3c:	e0cb      	b.n	2ed6 <_spi_m_sync_init+0x1ca>
	};
}

static inline bool hri_sercomspi_is_syncing(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    2d3e:	69e3      	ldr	r3, [r4, #28]
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    2d40:	07db      	lsls	r3, r3, #31
    2d42:	d421      	bmi.n	2d88 <_spi_m_sync_init+0x7c>
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
    2d44:	782a      	ldrb	r2, [r5, #0]
    2d46:	786b      	ldrb	r3, [r5, #1]
    2d48:	021b      	lsls	r3, r3, #8
    2d4a:	4313      	orrs	r3, r2
    2d4c:	78aa      	ldrb	r2, [r5, #2]
    2d4e:	0412      	lsls	r2, r2, #16
    2d50:	4313      	orrs	r3, r2
    2d52:	78ea      	ldrb	r2, [r5, #3]
    2d54:	0612      	lsls	r2, r2, #24
    2d56:	431a      	orrs	r2, r3
    2d58:	231c      	movs	r3, #28
    2d5a:	401a      	ands	r2, r3
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2d5c:	69e3      	ldr	r3, [r4, #28]
    2d5e:	079b      	lsls	r3, r3, #30
    2d60:	d1fc      	bne.n	2d5c <_spi_m_sync_init+0x50>
static inline hri_sercomspi_ctrla_reg_t hri_sercomspi_get_CTRLA_reg(const void *const         hw,
                                                                    hri_sercomspi_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    2d62:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    2d64:	079b      	lsls	r3, r3, #30
    2d66:	d509      	bpl.n	2d7c <_spi_m_sync_init+0x70>
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    2d68:	6823      	ldr	r3, [r4, #0]
    2d6a:	2102      	movs	r1, #2
    2d6c:	438b      	bics	r3, r1
    2d6e:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2d70:	69e3      	ldr	r3, [r4, #28]
    2d72:	079b      	lsls	r3, r3, #30
    2d74:	d1fc      	bne.n	2d70 <_spi_m_sync_init+0x64>
    2d76:	69e3      	ldr	r3, [r4, #28]
    2d78:	079b      	lsls	r3, r3, #30
    2d7a:	d4fc      	bmi.n	2d76 <_spi_m_sync_init+0x6a>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
    2d7c:	2301      	movs	r3, #1
    2d7e:	4313      	orrs	r3, r2
}

static inline void hri_sercomspi_write_CTRLA_reg(const void *const hw, hri_sercomspi_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    2d80:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2d82:	69e3      	ldr	r3, [r4, #28]
    2d84:	079b      	lsls	r3, r3, #30
    2d86:	d1fc      	bne.n	2d82 <_spi_m_sync_init+0x76>
    2d88:	69e3      	ldr	r3, [r4, #28]
    2d8a:	07db      	lsls	r3, r3, #31
    2d8c:	d4fc      	bmi.n	2d88 <_spi_m_sync_init+0x7c>
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
    2d8e:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    2d90:	782b      	ldrb	r3, [r5, #0]
    2d92:	786a      	ldrb	r2, [r5, #1]
    2d94:	0212      	lsls	r2, r2, #8
    2d96:	431a      	orrs	r2, r3
    2d98:	78ab      	ldrb	r3, [r5, #2]
    2d9a:	041b      	lsls	r3, r3, #16
    2d9c:	431a      	orrs	r2, r3
    2d9e:	78eb      	ldrb	r3, [r5, #3]
    2da0:	061b      	lsls	r3, r3, #24
    2da2:	4313      	orrs	r3, r2
    2da4:	221c      	movs	r2, #28
    2da6:	4013      	ands	r3, r2
    2da8:	2b08      	cmp	r3, #8
    2daa:	d04d      	beq.n	2e48 <_spi_m_sync_init+0x13c>
	ASSERT(hw && regs);
    2dac:	2c00      	cmp	r4, #0
    2dae:	d100      	bne.n	2db2 <_spi_m_sync_init+0xa6>
    2db0:	e08d      	b.n	2ece <_spi_m_sync_init+0x1c2>
    2db2:	2d00      	cmp	r5, #0
    2db4:	d100      	bne.n	2db8 <_spi_m_sync_init+0xac>
    2db6:	e088      	b.n	2eca <_spi_m_sync_init+0x1be>
    2db8:	2001      	movs	r0, #1
    2dba:	4a4c      	ldr	r2, [pc, #304]	; (2eec <_spi_m_sync_init+0x1e0>)
    2dbc:	4949      	ldr	r1, [pc, #292]	; (2ee4 <_spi_m_sync_init+0x1d8>)
    2dbe:	4b4a      	ldr	r3, [pc, #296]	; (2ee8 <_spi_m_sync_init+0x1dc>)
    2dc0:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    2dc2:	782b      	ldrb	r3, [r5, #0]
    2dc4:	786a      	ldrb	r2, [r5, #1]
    2dc6:	0212      	lsls	r2, r2, #8
    2dc8:	431a      	orrs	r2, r3
    2dca:	78ab      	ldrb	r3, [r5, #2]
    2dcc:	041b      	lsls	r3, r3, #16
    2dce:	431a      	orrs	r2, r3
    2dd0:	78eb      	ldrb	r3, [r5, #3]
    2dd2:	061b      	lsls	r3, r3, #24
    2dd4:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    2dd6:	4a46      	ldr	r2, [pc, #280]	; (2ef0 <_spi_m_sync_init+0x1e4>)
    2dd8:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    2dda:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2ddc:	69e3      	ldr	r3, [r4, #28]
    2dde:	079b      	lsls	r3, r3, #30
    2de0:	d1fc      	bne.n	2ddc <_spi_m_sync_init+0xd0>
	    (regs->ctrlb
    2de2:	792b      	ldrb	r3, [r5, #4]
    2de4:	796a      	ldrb	r2, [r5, #5]
    2de6:	0212      	lsls	r2, r2, #8
    2de8:	431a      	orrs	r2, r3
    2dea:	79ab      	ldrb	r3, [r5, #6]
    2dec:	041b      	lsls	r3, r3, #16
    2dee:	431a      	orrs	r2, r3
    2df0:	79eb      	ldrb	r3, [r5, #7]
    2df2:	061b      	lsls	r3, r3, #24
    2df4:	4313      	orrs	r3, r2
	        | (SERCOM_SPI_CTRLB_RXEN));
    2df6:	4a3f      	ldr	r2, [pc, #252]	; (2ef4 <_spi_m_sync_init+0x1e8>)
    2df8:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
    2dfa:	2280      	movs	r2, #128	; 0x80
    2dfc:	0292      	lsls	r2, r2, #10
    2dfe:	4313      	orrs	r3, r2
}

static inline void hri_sercomspi_write_CTRLB_reg(const void *const hw, hri_sercomspi_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    2e00:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2e02:	69e3      	ldr	r3, [r4, #28]
    2e04:	075b      	lsls	r3, r3, #29
    2e06:	d1fc      	bne.n	2e02 <_spi_m_sync_init+0xf6>
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    2e08:	7b2b      	ldrb	r3, [r5, #12]
}

static inline void hri_sercomspi_write_BAUD_reg(const void *const hw, hri_sercomspi_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.BAUD.reg = data;
    2e0a:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    2e0c:	7b6a      	ldrb	r2, [r5, #13]
}

static inline void hri_sercomspi_write_DBGCTRL_reg(const void *const hw, hri_sercomspi_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    2e0e:	2330      	movs	r3, #48	; 0x30
    2e10:	54e2      	strb	r2, [r4, r3]
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    2e12:	792b      	ldrb	r3, [r5, #4]
    2e14:	075b      	lsls	r3, r3, #29
    2e16:	d15c      	bne.n	2ed2 <_spi_m_sync_init+0x1c6>
    2e18:	2301      	movs	r3, #1
    2e1a:	7133      	strb	r3, [r6, #4]

	dev->dummy_byte = regs->dummy_byte;
    2e1c:	7baa      	ldrb	r2, [r5, #14]
    2e1e:	7beb      	ldrb	r3, [r5, #15]
    2e20:	021b      	lsls	r3, r3, #8
    2e22:	4313      	orrs	r3, r2
    2e24:	80f3      	strh	r3, [r6, #6]

	return ERR_NONE;
    2e26:	2000      	movs	r0, #0
}
    2e28:	bd70      	pop	{r4, r5, r6, pc}
		if (sercomspi_regs[i].n == n) {
    2e2a:	2801      	cmp	r0, #1
    2e2c:	d002      	beq.n	2e34 <_spi_m_sync_init+0x128>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    2e2e:	3301      	adds	r3, #1
    2e30:	b2db      	uxtb	r3, r3
    2e32:	e772      	b.n	2d1a <_spi_m_sync_init+0xe>
			return &sercomspi_regs[i];
    2e34:	011d      	lsls	r5, r3, #4
    2e36:	18ea      	adds	r2, r5, r3
    2e38:	4d2f      	ldr	r5, [pc, #188]	; (2ef8 <_spi_m_sync_init+0x1ec>)
    2e3a:	353c      	adds	r5, #60	; 0x3c
    2e3c:	18ad      	adds	r5, r5, r2
    2e3e:	e770      	b.n	2d22 <_spi_m_sync_init+0x16>
	ASSERT(dev && hw);
    2e40:	2000      	movs	r0, #0
    2e42:	e775      	b.n	2d30 <_spi_m_sync_init+0x24>
    2e44:	2000      	movs	r0, #0
    2e46:	e773      	b.n	2d30 <_spi_m_sync_init+0x24>
	ASSERT(hw && regs);
    2e48:	2c00      	cmp	r4, #0
    2e4a:	d03c      	beq.n	2ec6 <_spi_m_sync_init+0x1ba>
    2e4c:	2d00      	cmp	r5, #0
    2e4e:	d038      	beq.n	2ec2 <_spi_m_sync_init+0x1b6>
    2e50:	2001      	movs	r0, #1
    2e52:	4a2a      	ldr	r2, [pc, #168]	; (2efc <_spi_m_sync_init+0x1f0>)
    2e54:	4923      	ldr	r1, [pc, #140]	; (2ee4 <_spi_m_sync_init+0x1d8>)
    2e56:	4b24      	ldr	r3, [pc, #144]	; (2ee8 <_spi_m_sync_init+0x1dc>)
    2e58:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    2e5a:	782b      	ldrb	r3, [r5, #0]
    2e5c:	786a      	ldrb	r2, [r5, #1]
    2e5e:	0212      	lsls	r2, r2, #8
    2e60:	431a      	orrs	r2, r3
    2e62:	78ab      	ldrb	r3, [r5, #2]
    2e64:	041b      	lsls	r3, r3, #16
    2e66:	431a      	orrs	r2, r3
    2e68:	78eb      	ldrb	r3, [r5, #3]
    2e6a:	061b      	lsls	r3, r3, #24
    2e6c:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    2e6e:	4a20      	ldr	r2, [pc, #128]	; (2ef0 <_spi_m_sync_init+0x1e4>)
    2e70:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    2e72:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2e74:	69e3      	ldr	r3, [r4, #28]
    2e76:	079b      	lsls	r3, r3, #30
    2e78:	d1fc      	bne.n	2e74 <_spi_m_sync_init+0x168>
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
    2e7a:	792b      	ldrb	r3, [r5, #4]
    2e7c:	796a      	ldrb	r2, [r5, #5]
    2e7e:	0212      	lsls	r2, r2, #8
    2e80:	431a      	orrs	r2, r3
    2e82:	79ab      	ldrb	r3, [r5, #6]
    2e84:	041b      	lsls	r3, r3, #16
    2e86:	431a      	orrs	r2, r3
    2e88:	79eb      	ldrb	r3, [r5, #7]
    2e8a:	061b      	lsls	r3, r3, #24
    2e8c:	4313      	orrs	r3, r2
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
    2e8e:	4a1c      	ldr	r2, [pc, #112]	; (2f00 <_spi_m_sync_init+0x1f4>)
    2e90:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(hw,
    2e92:	4a1c      	ldr	r2, [pc, #112]	; (2f04 <_spi_m_sync_init+0x1f8>)
    2e94:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    2e96:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2e98:	69e3      	ldr	r3, [r4, #28]
    2e9a:	075b      	lsls	r3, r3, #29
    2e9c:	d1fc      	bne.n	2e98 <_spi_m_sync_init+0x18c>
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    2e9e:	7a2b      	ldrb	r3, [r5, #8]
    2ea0:	7a6a      	ldrb	r2, [r5, #9]
    2ea2:	0212      	lsls	r2, r2, #8
    2ea4:	431a      	orrs	r2, r3
    2ea6:	7aab      	ldrb	r3, [r5, #10]
    2ea8:	041b      	lsls	r3, r3, #16
    2eaa:	431a      	orrs	r2, r3
    2eac:	7aeb      	ldrb	r3, [r5, #11]
    2eae:	061b      	lsls	r3, r3, #24
    2eb0:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.ADDR.reg = data;
    2eb2:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    2eb4:	7b6a      	ldrb	r2, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    2eb6:	2330      	movs	r3, #48	; 0x30
    2eb8:	54e2      	strb	r2, [r4, r3]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    2eba:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
    2ebc:	2b00      	cmp	r3, #0
    2ebe:	d1fc      	bne.n	2eba <_spi_m_sync_init+0x1ae>
    2ec0:	e7a7      	b.n	2e12 <_spi_m_sync_init+0x106>
	ASSERT(hw && regs);
    2ec2:	2000      	movs	r0, #0
    2ec4:	e7c5      	b.n	2e52 <_spi_m_sync_init+0x146>
    2ec6:	2000      	movs	r0, #0
    2ec8:	e7c3      	b.n	2e52 <_spi_m_sync_init+0x146>
	ASSERT(hw && regs);
    2eca:	2000      	movs	r0, #0
    2ecc:	e775      	b.n	2dba <_spi_m_sync_init+0xae>
    2ece:	2000      	movs	r0, #0
    2ed0:	e773      	b.n	2dba <_spi_m_sync_init+0xae>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    2ed2:	2302      	movs	r3, #2
    2ed4:	e7a1      	b.n	2e1a <_spi_m_sync_init+0x10e>
		return ERR_INVALID_ARG;
    2ed6:	200d      	movs	r0, #13
    2ed8:	4240      	negs	r0, r0
    2eda:	e7a5      	b.n	2e28 <_spi_m_sync_init+0x11c>
    2edc:	00002cfd 	.word	0x00002cfd
    2ee0:	00000925 	.word	0x00000925
    2ee4:	00003c58 	.word	0x00003c58
    2ee8:	0000245d 	.word	0x0000245d
    2eec:	000008ef 	.word	0x000008ef
    2ef0:	fffffefc 	.word	0xfffffefc
    2ef4:	fffd1dbf 	.word	0xfffd1dbf
    2ef8:	00003c08 	.word	0x00003c08
    2efc:	00000903 	.word	0x00000903
    2f00:	fffdddbf 	.word	0xfffdddbf
    2f04:	00020240 	.word	0x00020240

00002f08 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    2f08:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f0a:	46ce      	mov	lr, r9
    2f0c:	4647      	mov	r7, r8
    2f0e:	b580      	push	{r7, lr}
    2f10:	b089      	sub	sp, #36	; 0x24
    2f12:	4681      	mov	r9, r0
    2f14:	000d      	movs	r5, r1
	void *                 hw   = dev->prvt;
    2f16:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    2f18:	680b      	ldr	r3, [r1, #0]
    2f1a:	9303      	str	r3, [sp, #12]
    2f1c:	684b      	ldr	r3, [r1, #4]
    2f1e:	9304      	str	r3, [sp, #16]
    2f20:	2300      	movs	r3, #0
    2f22:	9305      	str	r3, [sp, #20]
    2f24:	9306      	str	r3, [sp, #24]
    2f26:	7906      	ldrb	r6, [r0, #4]

	ASSERT(dev && hw);
    2f28:	2800      	cmp	r0, #0
    2f2a:	d014      	beq.n	2f56 <_spi_m_sync_trans+0x4e>
    2f2c:	2c00      	cmp	r4, #0
    2f2e:	d010      	beq.n	2f52 <_spi_m_sync_trans+0x4a>
    2f30:	2001      	movs	r0, #1
    2f32:	4a37      	ldr	r2, [pc, #220]	; (3010 <_spi_m_sync_trans+0x108>)
    2f34:	4937      	ldr	r1, [pc, #220]	; (3014 <_spi_m_sync_trans+0x10c>)
    2f36:	4b38      	ldr	r3, [pc, #224]	; (3018 <_spi_m_sync_trans+0x110>)
    2f38:	4798      	blx	r3
    2f3a:	69e3      	ldr	r3, [r4, #28]

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(
    2f3c:	075b      	lsls	r3, r3, #29
    2f3e:	d164      	bne.n	300a <_spi_m_sync_trans+0x102>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    2f40:	69e3      	ldr	r3, [r4, #28]
    2f42:	079b      	lsls	r3, r3, #30
    2f44:	d1fc      	bne.n	2f40 <_spi_m_sync_trans+0x38>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    2f46:	6823      	ldr	r3, [r4, #0]
	        hw, (SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE | SERCOM_SPI_SYNCBUSY_CTRLB))) {
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    2f48:	079b      	lsls	r3, r3, #30
    2f4a:	d420      	bmi.n	2f8e <_spi_m_sync_trans+0x86>
		return ERR_NOT_INITIALIZED;
    2f4c:	2014      	movs	r0, #20
    2f4e:	4240      	negs	r0, r0
    2f50:	e056      	b.n	3000 <_spi_m_sync_trans+0xf8>
	ASSERT(dev && hw);
    2f52:	2000      	movs	r0, #0
    2f54:	e7ed      	b.n	2f32 <_spi_m_sync_trans+0x2a>
    2f56:	2000      	movs	r0, #0
    2f58:	e7eb      	b.n	2f32 <_spi_m_sync_trans+0x2a>
		return false;
    2f5a:	2200      	movs	r2, #0
    2f5c:	e02d      	b.n	2fba <_spi_m_sync_trans+0xb2>
			data |= (*ctrl->txbuf) << 8;
    2f5e:	7848      	ldrb	r0, [r1, #1]
    2f60:	0200      	lsls	r0, r0, #8
    2f62:	4647      	mov	r7, r8
    2f64:	4307      	orrs	r7, r0
    2f66:	46b8      	mov	r8, r7
			ctrl->txbuf++;
    2f68:	3102      	adds	r1, #2
    2f6a:	9103      	str	r1, [sp, #12]
	ctrl->txcnt++;
    2f6c:	3201      	adds	r2, #1
    2f6e:	9205      	str	r2, [sp, #20]
	((Sercom *)hw)->SPI.DATA.reg = data;
    2f70:	4642      	mov	r2, r8
    2f72:	62a2      	str	r2, [r4, #40]	; 0x28
	if (SERCOM_SPI_INTFLAG_ERROR & iflag) {
    2f74:	b25b      	sxtb	r3, r3
    2f76:	2b00      	cmp	r3, #0
    2f78:	db35      	blt.n	2fe6 <_spi_m_sync_trans+0xde>
	return ERR_NONE;
    2f7a:	2000      	movs	r0, #0
			}
		}

		rc = _spi_err_check(iflag, hw);

		if (rc < 0) {
    2f7c:	2800      	cmp	r0, #0
    2f7e:	db3a      	blt.n	2ff6 <_spi_m_sync_trans+0xee>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    2f80:	9805      	ldr	r0, [sp, #20]
    2f82:	68ab      	ldr	r3, [r5, #8]
    2f84:	4298      	cmp	r0, r3
    2f86:	d302      	bcc.n	2f8e <_spi_m_sync_trans+0x86>
    2f88:	9a06      	ldr	r2, [sp, #24]
    2f8a:	4293      	cmp	r3, r2
    2f8c:	d933      	bls.n	2ff6 <_spi_m_sync_trans+0xee>
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    2f8e:	7e23      	ldrb	r3, [r4, #24]
    2f90:	b2db      	uxtb	r3, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    2f92:	075a      	lsls	r2, r3, #29
    2f94:	d5e1      	bpl.n	2f5a <_spi_m_sync_trans+0x52>
	return ((Sercom *)hw)->SPI.DATA.reg;
    2f96:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	if (ctrl->rxbuf) {
    2f98:	9a04      	ldr	r2, [sp, #16]
    2f9a:	2a00      	cmp	r2, #0
    2f9c:	d008      	beq.n	2fb0 <_spi_m_sync_trans+0xa8>
		*ctrl->rxbuf++ = (uint8_t)data;
    2f9e:	1c50      	adds	r0, r2, #1
    2fa0:	9004      	str	r0, [sp, #16]
    2fa2:	7011      	strb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
    2fa4:	2e01      	cmp	r6, #1
    2fa6:	d903      	bls.n	2fb0 <_spi_m_sync_trans+0xa8>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    2fa8:	1c90      	adds	r0, r2, #2
    2faa:	9004      	str	r0, [sp, #16]
    2fac:	0a09      	lsrs	r1, r1, #8
    2fae:	7051      	strb	r1, [r2, #1]
	ctrl->rxcnt++;
    2fb0:	9a06      	ldr	r2, [sp, #24]
    2fb2:	9201      	str	r2, [sp, #4]
    2fb4:	3201      	adds	r2, #1
    2fb6:	9206      	str	r2, [sp, #24]
	return true;
    2fb8:	2201      	movs	r2, #1
		if (!_spi_rx_check_and_receive(hw, iflag, &ctrl)) {
    2fba:	2a00      	cmp	r2, #0
    2fbc:	d1da      	bne.n	2f74 <_spi_m_sync_trans+0x6c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
    2fbe:	9906      	ldr	r1, [sp, #24]
    2fc0:	9a05      	ldr	r2, [sp, #20]
    2fc2:	4291      	cmp	r1, r2
    2fc4:	d3d6      	bcc.n	2f74 <_spi_m_sync_trans+0x6c>
				_spi_tx_check_and_send(hw, iflag, &ctrl, dev->dummy_byte);
    2fc6:	4649      	mov	r1, r9
    2fc8:	88c8      	ldrh	r0, [r1, #6]
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    2fca:	07d9      	lsls	r1, r3, #31
    2fcc:	d5d2      	bpl.n	2f74 <_spi_m_sync_trans+0x6c>
	if (ctrl->txbuf) {
    2fce:	9903      	ldr	r1, [sp, #12]
    2fd0:	2900      	cmp	r1, #0
    2fd2:	d006      	beq.n	2fe2 <_spi_m_sync_trans+0xda>
		data = *ctrl->txbuf++;
    2fd4:	1c48      	adds	r0, r1, #1
    2fd6:	9003      	str	r0, [sp, #12]
    2fd8:	7808      	ldrb	r0, [r1, #0]
    2fda:	4680      	mov	r8, r0
		if (ctrl->char_size > 1) {
    2fdc:	2e01      	cmp	r6, #1
    2fde:	d8be      	bhi.n	2f5e <_spi_m_sync_trans+0x56>
    2fe0:	e7c4      	b.n	2f6c <_spi_m_sync_trans+0x64>
		data = dummy;
    2fe2:	4680      	mov	r8, r0
    2fe4:	e7c2      	b.n	2f6c <_spi_m_sync_trans+0x64>
}

static inline void hri_sercomspi_clear_STATUS_reg(const void *const hw, hri_sercomspi_status_reg_t mask)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    2fe6:	2301      	movs	r3, #1
    2fe8:	425b      	negs	r3, r3
    2fea:	8363      	strh	r3, [r4, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    2fec:	3381      	adds	r3, #129	; 0x81
    2fee:	7623      	strb	r3, [r4, #24]
		return ERR_OVERFLOW;
    2ff0:	2013      	movs	r0, #19
    2ff2:	4240      	negs	r0, r0
    2ff4:	e7c2      	b.n	2f7c <_spi_m_sync_trans+0x74>
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    2ff6:	7e23      	ldrb	r3, [r4, #24]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    2ff8:	079b      	lsls	r3, r3, #30
    2ffa:	d0fc      	beq.n	2ff6 <_spi_m_sync_trans+0xee>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    2ffc:	2303      	movs	r3, #3
    2ffe:	7623      	strb	r3, [r4, #24]
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
    3000:	b009      	add	sp, #36	; 0x24
    3002:	bc0c      	pop	{r2, r3}
    3004:	4690      	mov	r8, r2
    3006:	4699      	mov	r9, r3
    3008:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_BUSY;
    300a:	2004      	movs	r0, #4
    300c:	4240      	negs	r0, r0
    300e:	e7f7      	b.n	3000 <_spi_m_sync_trans+0xf8>
    3010:	00000a85 	.word	0x00000a85
    3014:	00003c58 	.word	0x00003c58
    3018:	0000245d 	.word	0x0000245d

0000301c <tc_interrupt_handler>:
 * \internal TC interrupt handler for Timer
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
    301c:	b510      	push	{r4, lr}
	void *const hw = device->hw;
    301e:	68c3      	ldr	r3, [r0, #12]
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_MC1;
}

static inline bool hri_tc_get_interrupt_OVF_bit(const void *const hw)
{
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
    3020:	7a9a      	ldrb	r2, [r3, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
    3022:	07d2      	lsls	r2, r2, #31
    3024:	d400      	bmi.n	3028 <tc_interrupt_handler+0xc>
		hri_tc_clear_interrupt_OVF_bit(hw);
		device->timer_cb.period_expired(device);
	}
}
    3026:	bd10      	pop	{r4, pc}
}

static inline void hri_tc_clear_interrupt_OVF_bit(const void *const hw)
{
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    3028:	2201      	movs	r2, #1
    302a:	729a      	strb	r2, [r3, #10]
		device->timer_cb.period_expired(device);
    302c:	6803      	ldr	r3, [r0, #0]
    302e:	4798      	blx	r3
}
    3030:	e7f9      	b.n	3026 <tc_interrupt_handler+0xa>
	...

00003034 <_tc_init_irq_param>:
/**
 * \brief Init irq param with the given tc hardware instance
 */
static void _tc_init_irq_param(const void *const hw, void *dev)
{
	if (hw == TC0) {
    3034:	4b06      	ldr	r3, [pc, #24]	; (3050 <_tc_init_irq_param+0x1c>)
    3036:	4298      	cmp	r0, r3
    3038:	d003      	beq.n	3042 <_tc_init_irq_param+0xe>
		_tc0_dev = (struct _timer_device *)dev;
	}
	if (hw == TC1) {
    303a:	4b06      	ldr	r3, [pc, #24]	; (3054 <_tc_init_irq_param+0x20>)
    303c:	4298      	cmp	r0, r3
    303e:	d003      	beq.n	3048 <_tc_init_irq_param+0x14>
		_tc1_dev = (struct _timer_device *)dev;
	}
}
    3040:	4770      	bx	lr
		_tc0_dev = (struct _timer_device *)dev;
    3042:	4b05      	ldr	r3, [pc, #20]	; (3058 <_tc_init_irq_param+0x24>)
    3044:	6019      	str	r1, [r3, #0]
    3046:	e7f8      	b.n	303a <_tc_init_irq_param+0x6>
		_tc1_dev = (struct _timer_device *)dev;
    3048:	4b03      	ldr	r3, [pc, #12]	; (3058 <_tc_init_irq_param+0x24>)
    304a:	6059      	str	r1, [r3, #4]
}
    304c:	e7f8      	b.n	3040 <_tc_init_irq_param+0xc>
    304e:	46c0      	nop			; (mov r8, r8)
    3050:	42003000 	.word	0x42003000
    3054:	42003400 	.word	0x42003400
    3058:	20002bd0 	.word	0x20002bd0

0000305c <get_tc_index>:
{
    305c:	b510      	push	{r4, lr}
 *
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	if ((uint32_t)TC4 == (uint32_t)hw) {
    305e:	4b11      	ldr	r3, [pc, #68]	; (30a4 <get_tc_index+0x48>)
    3060:	4298      	cmp	r0, r3
    3062:	d011      	beq.n	3088 <get_tc_index+0x2c>
		return 4;
	}
	return (((uint32_t)hw - (uint32_t)TC0) >> 10);
    3064:	4b10      	ldr	r3, [pc, #64]	; (30a8 <get_tc_index+0x4c>)
    3066:	469c      	mov	ip, r3
    3068:	4460      	add	r0, ip
    306a:	0a80      	lsrs	r0, r0, #10
    306c:	b2c2      	uxtb	r2, r0
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
    306e:	2000      	movs	r0, #0
    3070:	2801      	cmp	r0, #1
    3072:	d80d      	bhi.n	3090 <get_tc_index+0x34>
		if (_tcs[i].number == index) {
    3074:	0083      	lsls	r3, r0, #2
    3076:	181b      	adds	r3, r3, r0
    3078:	0099      	lsls	r1, r3, #2
    307a:	4b0c      	ldr	r3, [pc, #48]	; (30ac <get_tc_index+0x50>)
    307c:	5ccb      	ldrb	r3, [r1, r3]
    307e:	4293      	cmp	r3, r2
    3080:	d004      	beq.n	308c <get_tc_index+0x30>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
    3082:	3001      	adds	r0, #1
    3084:	b2c0      	uxtb	r0, r0
    3086:	e7f3      	b.n	3070 <get_tc_index+0x14>
		return 4;
    3088:	2204      	movs	r2, #4
    308a:	e7f0      	b.n	306e <get_tc_index+0x12>
			return i;
    308c:	b240      	sxtb	r0, r0
    308e:	e007      	b.n	30a0 <get_tc_index+0x44>
	ASSERT(false);
    3090:	22a3      	movs	r2, #163	; 0xa3
    3092:	0052      	lsls	r2, r2, #1
    3094:	4906      	ldr	r1, [pc, #24]	; (30b0 <get_tc_index+0x54>)
    3096:	2000      	movs	r0, #0
    3098:	4b06      	ldr	r3, [pc, #24]	; (30b4 <get_tc_index+0x58>)
    309a:	4798      	blx	r3
	return -1;
    309c:	2001      	movs	r0, #1
    309e:	4240      	negs	r0, r0
}
    30a0:	bd10      	pop	{r4, pc}
    30a2:	46c0      	nop			; (mov r8, r8)
    30a4:	42004000 	.word	0x42004000
    30a8:	bdffd000 	.word	0xbdffd000
    30ac:	00003c74 	.word	0x00003c74
    30b0:	00003c9c 	.word	0x00003c9c
    30b4:	0000245d 	.word	0x0000245d

000030b8 <_timer_init>:
{
    30b8:	b570      	push	{r4, r5, r6, lr}
    30ba:	0006      	movs	r6, r0
    30bc:	000c      	movs	r4, r1
	int8_t i = get_tc_index(hw);
    30be:	0008      	movs	r0, r1
    30c0:	4b65      	ldr	r3, [pc, #404]	; (3258 <_timer_init+0x1a0>)
    30c2:	4798      	blx	r3
    30c4:	0005      	movs	r5, r0
	device->hw = hw;
    30c6:	60f4      	str	r4, [r6, #12]
	ASSERT(ARRAY_SIZE(_tcs));
    30c8:	228f      	movs	r2, #143	; 0x8f
    30ca:	4964      	ldr	r1, [pc, #400]	; (325c <_timer_init+0x1a4>)
    30cc:	2001      	movs	r0, #1
    30ce:	4b64      	ldr	r3, [pc, #400]	; (3260 <_timer_init+0x1a8>)
    30d0:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
    30d2:	6923      	ldr	r3, [r4, #16]
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
    30d4:	07db      	lsls	r3, r3, #31
    30d6:	d414      	bmi.n	3102 <_timer_init+0x4a>
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    30d8:	6923      	ldr	r3, [r4, #16]
    30da:	079b      	lsls	r3, r3, #30
    30dc:	d1fc      	bne.n	30d8 <_timer_init+0x20>

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    30de:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
    30e0:	079b      	lsls	r3, r3, #30
    30e2:	d509      	bpl.n	30f8 <_timer_init+0x40>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    30e4:	6823      	ldr	r3, [r4, #0]
    30e6:	2202      	movs	r2, #2
    30e8:	4393      	bics	r3, r2
    30ea:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    30ec:	6923      	ldr	r3, [r4, #16]
    30ee:	079b      	lsls	r3, r3, #30
    30f0:	d1fc      	bne.n	30ec <_timer_init+0x34>
    30f2:	6923      	ldr	r3, [r4, #16]
    30f4:	079b      	lsls	r3, r3, #30
    30f6:	d4fc      	bmi.n	30f2 <_timer_init+0x3a>
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    30f8:	2301      	movs	r3, #1
    30fa:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    30fc:	6923      	ldr	r3, [r4, #16]
    30fe:	079b      	lsls	r3, r3, #30
    3100:	d1fc      	bne.n	30fc <_timer_init+0x44>
    3102:	6923      	ldr	r3, [r4, #16]
    3104:	07db      	lsls	r3, r3, #31
    3106:	d4fc      	bmi.n	3102 <_timer_init+0x4a>
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
    3108:	00ab      	lsls	r3, r5, #2
    310a:	195b      	adds	r3, r3, r5
    310c:	009a      	lsls	r2, r3, #2
    310e:	4b55      	ldr	r3, [pc, #340]	; (3264 <_timer_init+0x1ac>)
    3110:	189b      	adds	r3, r3, r2
    3112:	685b      	ldr	r3, [r3, #4]
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    3114:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    3116:	6923      	ldr	r3, [r4, #16]
    3118:	079b      	lsls	r3, r3, #30
    311a:	d1fc      	bne.n	3116 <_timer_init+0x5e>
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
    311c:	00aa      	lsls	r2, r5, #2
    311e:	1952      	adds	r2, r2, r5
    3120:	0091      	lsls	r1, r2, #2
    3122:	4b50      	ldr	r3, [pc, #320]	; (3264 <_timer_init+0x1ac>)
    3124:	185b      	adds	r3, r3, r1
    3126:	7a9a      	ldrb	r2, [r3, #10]
}

static inline void hri_tc_write_DBGCTRL_reg(const void *const hw, hri_tc_dbgctrl_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
    3128:	73e2      	strb	r2, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
    312a:	891a      	ldrh	r2, [r3, #8]
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
    312c:	80e2      	strh	r2, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
    312e:	2201      	movs	r2, #1
    3130:	7322      	strb	r2, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    3132:	685a      	ldr	r2, [r3, #4]
    3134:	230c      	movs	r3, #12
    3136:	4013      	ands	r3, r2
    3138:	2b08      	cmp	r3, #8
    313a:	d056      	beq.n	31ea <_timer_init+0x132>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
    313c:	2b00      	cmp	r3, #0
    313e:	d168      	bne.n	3212 <_timer_init+0x15a>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
    3140:	00ab      	lsls	r3, r5, #2
    3142:	195b      	adds	r3, r3, r5
    3144:	009a      	lsls	r2, r3, #2
    3146:	4b47      	ldr	r3, [pc, #284]	; (3264 <_timer_init+0x1ac>)
    3148:	189b      	adds	r3, r3, r2
    314a:	899b      	ldrh	r3, [r3, #12]
}

static inline void hri_tccount16_write_CC_reg(const void *const hw, uint8_t index, hri_tccount16_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    314c:	83a3      	strh	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    314e:	6923      	ldr	r3, [r4, #16]
    3150:	22c0      	movs	r2, #192	; 0xc0
    3152:	421a      	tst	r2, r3
    3154:	d1fb      	bne.n	314e <_timer_init+0x96>
		hri_tccount16_write_CC_reg(hw, 1, (uint16_t)_tcs[i].cc1);
    3156:	00ab      	lsls	r3, r5, #2
    3158:	195b      	adds	r3, r3, r5
    315a:	009a      	lsls	r2, r3, #2
    315c:	4b41      	ldr	r3, [pc, #260]	; (3264 <_timer_init+0x1ac>)
    315e:	189b      	adds	r3, r3, r2
    3160:	8a1b      	ldrh	r3, [r3, #16]
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    3162:	83e3      	strh	r3, [r4, #30]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    3164:	6923      	ldr	r3, [r4, #16]
    3166:	22c0      	movs	r2, #192	; 0xc0
    3168:	421a      	tst	r2, r3
    316a:	d1fb      	bne.n	3164 <_timer_init+0xac>
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
    316c:	2301      	movs	r3, #1
    316e:	7263      	strb	r3, [r4, #9]
	_tc_init_irq_param(hw, (void *)device);
    3170:	0031      	movs	r1, r6
    3172:	0020      	movs	r0, r4
    3174:	4b3c      	ldr	r3, [pc, #240]	; (3268 <_timer_init+0x1b0>)
    3176:	4798      	blx	r3
	NVIC_DisableIRQ(_tcs[i].irq);
    3178:	00ab      	lsls	r3, r5, #2
    317a:	195b      	adds	r3, r3, r5
    317c:	009a      	lsls	r2, r3, #2
    317e:	4b39      	ldr	r3, [pc, #228]	; (3264 <_timer_init+0x1ac>)
    3180:	189b      	adds	r3, r3, r2
    3182:	785b      	ldrb	r3, [r3, #1]
    3184:	b25b      	sxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
    3186:	2b00      	cmp	r3, #0
    3188:	db0b      	blt.n	31a2 <_timer_init+0xea>
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    318a:	221f      	movs	r2, #31
    318c:	4013      	ands	r3, r2
    318e:	3a1e      	subs	r2, #30
    3190:	409a      	lsls	r2, r3
    3192:	0013      	movs	r3, r2
    3194:	2280      	movs	r2, #128	; 0x80
    3196:	4935      	ldr	r1, [pc, #212]	; (326c <_timer_init+0x1b4>)
    3198:	508b      	str	r3, [r1, r2]
  __ASM volatile ("dsb 0xF":::"memory");
    319a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    319e:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
    31a2:	00ab      	lsls	r3, r5, #2
    31a4:	195b      	adds	r3, r3, r5
    31a6:	009a      	lsls	r2, r3, #2
    31a8:	4b2e      	ldr	r3, [pc, #184]	; (3264 <_timer_init+0x1ac>)
    31aa:	189b      	adds	r3, r3, r2
    31ac:	785b      	ldrb	r3, [r3, #1]
    31ae:	b25b      	sxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
    31b0:	2b00      	cmp	r3, #0
    31b2:	db08      	blt.n	31c6 <_timer_init+0x10e>
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    31b4:	221f      	movs	r2, #31
    31b6:	4013      	ands	r3, r2
    31b8:	3a1e      	subs	r2, #30
    31ba:	409a      	lsls	r2, r3
    31bc:	0013      	movs	r3, r2
    31be:	22c0      	movs	r2, #192	; 0xc0
    31c0:	0052      	lsls	r2, r2, #1
    31c2:	492a      	ldr	r1, [pc, #168]	; (326c <_timer_init+0x1b4>)
    31c4:	508b      	str	r3, [r1, r2]
	NVIC_EnableIRQ(_tcs[i].irq);
    31c6:	00ab      	lsls	r3, r5, #2
    31c8:	195d      	adds	r5, r3, r5
    31ca:	00aa      	lsls	r2, r5, #2
    31cc:	4b25      	ldr	r3, [pc, #148]	; (3264 <_timer_init+0x1ac>)
    31ce:	189b      	adds	r3, r3, r2
    31d0:	785b      	ldrb	r3, [r3, #1]
    31d2:	b25b      	sxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
    31d4:	2b00      	cmp	r3, #0
    31d6:	db06      	blt.n	31e6 <_timer_init+0x12e>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    31d8:	221f      	movs	r2, #31
    31da:	4013      	ands	r3, r2
    31dc:	3a1e      	subs	r2, #30
    31de:	409a      	lsls	r2, r3
    31e0:	0013      	movs	r3, r2
    31e2:	4a22      	ldr	r2, [pc, #136]	; (326c <_timer_init+0x1b4>)
    31e4:	6013      	str	r3, [r2, #0]
}
    31e6:	2000      	movs	r0, #0
    31e8:	bd70      	pop	{r4, r5, r6, pc}
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    31ea:	4b1e      	ldr	r3, [pc, #120]	; (3264 <_timer_init+0x1ac>)
    31ec:	185b      	adds	r3, r3, r1
    31ee:	68db      	ldr	r3, [r3, #12]
}

static inline void hri_tccount32_write_CC_reg(const void *const hw, uint8_t index, hri_tccount32_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    31f0:	61e3      	str	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    31f2:	6923      	ldr	r3, [r4, #16]
    31f4:	22c0      	movs	r2, #192	; 0xc0
    31f6:	421a      	tst	r2, r3
    31f8:	d1fb      	bne.n	31f2 <_timer_init+0x13a>
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
    31fa:	00ab      	lsls	r3, r5, #2
    31fc:	195b      	adds	r3, r3, r5
    31fe:	009a      	lsls	r2, r3, #2
    3200:	4b18      	ldr	r3, [pc, #96]	; (3264 <_timer_init+0x1ac>)
    3202:	189b      	adds	r3, r3, r2
    3204:	691b      	ldr	r3, [r3, #16]
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    3206:	6223      	str	r3, [r4, #32]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    3208:	6923      	ldr	r3, [r4, #16]
    320a:	22c0      	movs	r2, #192	; 0xc0
    320c:	421a      	tst	r2, r3
    320e:	d1fb      	bne.n	3208 <_timer_init+0x150>
    3210:	e7ac      	b.n	316c <_timer_init+0xb4>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
    3212:	2b04      	cmp	r3, #4
    3214:	d1aa      	bne.n	316c <_timer_init+0xb4>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
    3216:	00ab      	lsls	r3, r5, #2
    3218:	195b      	adds	r3, r3, r5
    321a:	009a      	lsls	r2, r3, #2
    321c:	4b11      	ldr	r3, [pc, #68]	; (3264 <_timer_init+0x1ac>)
    321e:	189b      	adds	r3, r3, r2
    3220:	7b1b      	ldrb	r3, [r3, #12]
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    3222:	7723      	strb	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    3224:	6923      	ldr	r3, [r4, #16]
    3226:	22c0      	movs	r2, #192	; 0xc0
    3228:	421a      	tst	r2, r3
    322a:	d1fb      	bne.n	3224 <_timer_init+0x16c>
		hri_tccount8_write_CC_reg(hw, 1, (uint8_t)_tcs[i].cc1);
    322c:	00ab      	lsls	r3, r5, #2
    322e:	195b      	adds	r3, r3, r5
    3230:	009a      	lsls	r2, r3, #2
    3232:	4b0c      	ldr	r3, [pc, #48]	; (3264 <_timer_init+0x1ac>)
    3234:	189b      	adds	r3, r3, r2
    3236:	7c1b      	ldrb	r3, [r3, #16]
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    3238:	7763      	strb	r3, [r4, #29]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    323a:	6923      	ldr	r3, [r4, #16]
    323c:	22c0      	movs	r2, #192	; 0xc0
    323e:	421a      	tst	r2, r3
    3240:	d1fb      	bne.n	323a <_timer_init+0x182>
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
    3242:	00ab      	lsls	r3, r5, #2
    3244:	195b      	adds	r3, r3, r5
    3246:	009a      	lsls	r2, r3, #2
    3248:	4b06      	ldr	r3, [pc, #24]	; (3264 <_timer_init+0x1ac>)
    324a:	189b      	adds	r3, r3, r2
    324c:	7adb      	ldrb	r3, [r3, #11]
	((Tc *)hw)->COUNT8.PER.reg = data;
    324e:	76e3      	strb	r3, [r4, #27]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    3250:	6923      	ldr	r3, [r4, #16]
    3252:	069b      	lsls	r3, r3, #26
    3254:	d4fc      	bmi.n	3250 <_timer_init+0x198>
    3256:	e789      	b.n	316c <_timer_init+0xb4>
    3258:	0000305d 	.word	0x0000305d
    325c:	00003c9c 	.word	0x00003c9c
    3260:	0000245d 	.word	0x0000245d
    3264:	00003c74 	.word	0x00003c74
    3268:	00003035 	.word	0x00003035
    326c:	e000e100 	.word	0xe000e100

00003270 <_timer_start>:
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
    3270:	68c2      	ldr	r2, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
    3272:	6813      	ldr	r3, [r2, #0]
    3274:	2102      	movs	r1, #2
    3276:	430b      	orrs	r3, r1
    3278:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    327a:	6913      	ldr	r3, [r2, #16]
    327c:	079b      	lsls	r3, r3, #30
    327e:	d1fc      	bne.n	327a <_timer_start+0xa>
}
    3280:	4770      	bx	lr

00003282 <_timer_is_started>:
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
    3282:	68c2      	ldr	r2, [r0, #12]
    3284:	6913      	ldr	r3, [r2, #16]
    3286:	079b      	lsls	r3, r3, #30
    3288:	d1fc      	bne.n	3284 <_timer_is_started+0x2>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    328a:	6813      	ldr	r3, [r2, #0]
	tmp = (tmp & TC_CTRLA_ENABLE) >> TC_CTRLA_ENABLE_Pos;
    328c:	085b      	lsrs	r3, r3, #1
	return (bool)tmp;
    328e:	2001      	movs	r0, #1
    3290:	4018      	ands	r0, r3
}
    3292:	4770      	bx	lr

00003294 <_tc_get_timer>:
}
    3294:	2000      	movs	r0, #0
    3296:	4770      	bx	lr

00003298 <_timer_set_irq>:
{
    3298:	b510      	push	{r4, lr}
	void *const hw = device->hw;
    329a:	68c0      	ldr	r0, [r0, #12]
	int8_t      i  = get_tc_index(hw);
    329c:	4b08      	ldr	r3, [pc, #32]	; (32c0 <_timer_set_irq+0x28>)
    329e:	4798      	blx	r3
    32a0:	0004      	movs	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
    32a2:	2212      	movs	r2, #18
    32a4:	32ff      	adds	r2, #255	; 0xff
    32a6:	4907      	ldr	r1, [pc, #28]	; (32c4 <_timer_set_irq+0x2c>)
    32a8:	2001      	movs	r0, #1
    32aa:	4b07      	ldr	r3, [pc, #28]	; (32c8 <_timer_set_irq+0x30>)
    32ac:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
    32ae:	00a0      	lsls	r0, r4, #2
    32b0:	1900      	adds	r0, r0, r4
    32b2:	0082      	lsls	r2, r0, #2
    32b4:	4b05      	ldr	r3, [pc, #20]	; (32cc <_timer_set_irq+0x34>)
    32b6:	189b      	adds	r3, r3, r2
    32b8:	7858      	ldrb	r0, [r3, #1]
    32ba:	4b05      	ldr	r3, [pc, #20]	; (32d0 <_timer_set_irq+0x38>)
    32bc:	4798      	blx	r3
}
    32be:	bd10      	pop	{r4, pc}
    32c0:	0000305d 	.word	0x0000305d
    32c4:	00003c9c 	.word	0x00003c9c
    32c8:	0000245d 	.word	0x0000245d
    32cc:	00003c74 	.word	0x00003c74
    32d0:	00002acd 	.word	0x00002acd

000032d4 <TC0_Handler>:
{
    32d4:	b510      	push	{r4, lr}
	tc_interrupt_handler(_tc0_dev);
    32d6:	4b02      	ldr	r3, [pc, #8]	; (32e0 <TC0_Handler+0xc>)
    32d8:	6818      	ldr	r0, [r3, #0]
    32da:	4b02      	ldr	r3, [pc, #8]	; (32e4 <TC0_Handler+0x10>)
    32dc:	4798      	blx	r3
}
    32de:	bd10      	pop	{r4, pc}
    32e0:	20002bd0 	.word	0x20002bd0
    32e4:	0000301d 	.word	0x0000301d

000032e8 <TC1_Handler>:
{
    32e8:	b510      	push	{r4, lr}
	tc_interrupt_handler(_tc1_dev);
    32ea:	4b02      	ldr	r3, [pc, #8]	; (32f4 <TC1_Handler+0xc>)
    32ec:	6858      	ldr	r0, [r3, #4]
    32ee:	4b02      	ldr	r3, [pc, #8]	; (32f8 <TC1_Handler+0x10>)
    32f0:	4798      	blx	r3
}
    32f2:	bd10      	pop	{r4, pc}
    32f4:	20002bd0 	.word	0x20002bd0
    32f8:	0000301d 	.word	0x0000301d

000032fc <_wdt_init>:

/**
 * \brief WDT initialization function
 */
int32_t _wdt_init(struct wdt_dev *const dev)
{
    32fc:	b510      	push	{r4, lr}
    32fe:	1e04      	subs	r4, r0, #0
	/* Sanity check arguments */
	ASSERT(dev && dev->hw);
    3300:	d027      	beq.n	3352 <_wdt_init+0x56>
    3302:	6803      	ldr	r3, [r0, #0]
    3304:	2b00      	cmp	r3, #0
    3306:	d022      	beq.n	334e <_wdt_init+0x52>
    3308:	2001      	movs	r0, #1
    330a:	2250      	movs	r2, #80	; 0x50
    330c:	4915      	ldr	r1, [pc, #84]	; (3364 <_wdt_init+0x68>)
    330e:	4b16      	ldr	r3, [pc, #88]	; (3368 <_wdt_init+0x6c>)
    3310:	4798      	blx	r3

	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
    3312:	6823      	ldr	r3, [r4, #0]
typedef uint8_t  hri_wdt_intenset_reg_t;
typedef uint8_t  hri_wdt_intflag_reg_t;

static inline void hri_wdt_wait_for_sync(const void *const hw, hri_wdt_syncbusy_reg_t reg)
{
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    3314:	689a      	ldr	r2, [r3, #8]
    3316:	210e      	movs	r1, #14
    3318:	4211      	tst	r1, r2
    331a:	d1fb      	bne.n	3314 <_wdt_init+0x18>

static inline bool hri_wdt_get_CTRLA_ALWAYSON_bit(const void *const hw)
{
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	tmp = ((Wdt *)hw)->CTRLA.reg;
    331c:	781a      	ldrb	r2, [r3, #0]
	tmp = (tmp & WDT_CTRLA_ALWAYSON) >> WDT_CTRLA_ALWAYSON_Pos;
    331e:	09d2      	lsrs	r2, r2, #7
    3320:	d119      	bne.n	3356 <_wdt_init+0x5a>
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    3322:	689a      	ldr	r2, [r3, #8]
    3324:	210e      	movs	r1, #14
    3326:	4211      	tst	r1, r2
    3328:	d1fb      	bne.n	3322 <_wdt_init+0x26>
	tmp = ((Wdt *)hw)->CTRLA.reg;
    332a:	781a      	ldrb	r2, [r3, #0]
    332c:	0792      	lsls	r2, r2, #30
    332e:	d415      	bmi.n	335c <_wdt_init+0x60>
	((Wdt *)hw)->CTRLA.reg &= ~WDT_CTRLA_WEN;
    3330:	781a      	ldrb	r2, [r3, #0]
    3332:	390a      	subs	r1, #10
    3334:	438a      	bics	r2, r1
    3336:	701a      	strb	r2, [r3, #0]
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    3338:	689a      	ldr	r2, [r3, #8]
    333a:	210e      	movs	r1, #14
    333c:	4211      	tst	r1, r2
    333e:	d1fb      	bne.n	3338 <_wdt_init+0x3c>
			hri_wdt_write_CONFIG_WINDOW_bf(dev->hw, CONF_WDT_WINDOW);
		} else {
			hri_wdt_clear_CTRLA_WEN_bit(dev->hw);
		}

		hri_wdt_write_CONFIG_PER_bf(dev->hw, CONF_WDT_PER);
    3340:	6822      	ldr	r2, [r4, #0]

static inline void hri_wdt_write_CONFIG_PER_bf(const void *const hw, hri_wdt_config_reg_t data)
{
	uint8_t tmp;
	WDT_CRITICAL_SECTION_ENTER();
	tmp = ((Wdt *)hw)->CONFIG.reg;
    3342:	7853      	ldrb	r3, [r2, #1]
	tmp &= ~WDT_CONFIG_PER_Msk;
    3344:	3101      	adds	r1, #1
    3346:	438b      	bics	r3, r1
	tmp |= WDT_CONFIG_PER(data);
	((Wdt *)hw)->CONFIG.reg = tmp;
    3348:	7053      	strb	r3, [r2, #1]
	}

	return ERR_NONE;
    334a:	2000      	movs	r0, #0
}
    334c:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->hw);
    334e:	2000      	movs	r0, #0
    3350:	e7db      	b.n	330a <_wdt_init+0xe>
    3352:	2000      	movs	r0, #0
    3354:	e7d9      	b.n	330a <_wdt_init+0xe>
		return ERR_DENIED;
    3356:	2011      	movs	r0, #17
    3358:	4240      	negs	r0, r0
    335a:	e7f7      	b.n	334c <_wdt_init+0x50>
    335c:	2011      	movs	r0, #17
    335e:	4240      	negs	r0, r0
    3360:	e7f4      	b.n	334c <_wdt_init+0x50>
    3362:	46c0      	nop			; (mov r8, r8)
    3364:	00003cb0 	.word	0x00003cb0
    3368:	0000245d 	.word	0x0000245d

0000336c <main>:
#include "atmel_start.h"
#include "freertos.h"
int main(void)
{
    336c:	b510      	push	{r4, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    336e:	4b04      	ldr	r3, [pc, #16]	; (3380 <main+0x14>)
    3370:	4798      	blx	r3
	TIMER_0_example();
    3372:	4b04      	ldr	r3, [pc, #16]	; (3384 <main+0x18>)
    3374:	4798      	blx	r3
//	CAN_0_example();
	CAN1_Init();
    3376:	4b04      	ldr	r3, [pc, #16]	; (3388 <main+0x1c>)
    3378:	4798      	blx	r3
	 

	FREERTOS_Init();
    337a:	4b04      	ldr	r3, [pc, #16]	; (338c <main+0x20>)
    337c:	4798      	blx	r3
    337e:	e7fe      	b.n	337e <main+0x12>
    3380:	00000195 	.word	0x00000195
    3384:	00000685 	.word	0x00000685
    3388:	000005c5 	.word	0x000005c5
    338c:	000006ed 	.word	0x000006ed

00003390 <AFE_task>:
#define TASK_AFE_STACK_SIZE (512 / sizeof(portSTACK_TYPE))
#define TASK_AFE_STACK_PRIORITY (tskIDLE_PRIORITY + 1)
static TaskHandle_t      xCreatedAFETask;
static uint32_t  u32afe_cnt = 0;
static void AFE_task(void *p)
{
    3390:	b510      	push	{r4, lr}

	while (1) {
	
		u32afe_cnt++;
    3392:	4b09      	ldr	r3, [pc, #36]	; (33b8 <AFE_task+0x28>)
    3394:	681a      	ldr	r2, [r3, #0]
    3396:	3201      	adds	r2, #1
    3398:	601a      	str	r2, [r3, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    339a:	2080      	movs	r0, #128	; 0x80
    339c:	0200      	lsls	r0, r0, #8
    339e:	2394      	movs	r3, #148	; 0x94
    33a0:	21c0      	movs	r1, #192	; 0xc0
    33a2:	05c9      	lsls	r1, r1, #23
    33a4:	50c8      	str	r0, [r1, r3]
		gpio_set_pin_level(LED_PIN , false);
		SEGGER_RTT_printf(0,"u32afe_cnt = %d \r\n",u32afe_cnt);
    33a6:	4905      	ldr	r1, [pc, #20]	; (33bc <AFE_task+0x2c>)
    33a8:	2000      	movs	r0, #0
    33aa:	4b05      	ldr	r3, [pc, #20]	; (33c0 <AFE_task+0x30>)
    33ac:	4798      	blx	r3
		vTaskDelay(1);
    33ae:	2001      	movs	r0, #1
    33b0:	4b04      	ldr	r3, [pc, #16]	; (33c4 <AFE_task+0x34>)
    33b2:	4798      	blx	r3
    33b4:	e7ed      	b.n	3392 <AFE_task+0x2>
    33b6:	46c0      	nop			; (mov r8, r8)
    33b8:	20002bd8 	.word	0x20002bd8
    33bc:	00003cc8 	.word	0x00003cc8
    33c0:	00003a1d 	.word	0x00003a1d
    33c4:	00001839 	.word	0x00001839

000033c8 <create_afe_task>:
	}
}


void create_afe_task(void)
{
    33c8:	b510      	push	{r4, lr}
    33ca:	b082      	sub	sp, #8
	taskENTER_CRITICAL();	
    33cc:	4b09      	ldr	r3, [pc, #36]	; (33f4 <create_afe_task+0x2c>)
    33ce:	4798      	blx	r3
	if (xTaskCreate(AFE_task, 
    33d0:	2300      	movs	r3, #0
    33d2:	9301      	str	r3, [sp, #4]
    33d4:	3301      	adds	r3, #1
    33d6:	9300      	str	r3, [sp, #0]
    33d8:	2300      	movs	r3, #0
    33da:	2280      	movs	r2, #128	; 0x80
    33dc:	4906      	ldr	r1, [pc, #24]	; (33f8 <create_afe_task+0x30>)
    33de:	4807      	ldr	r0, [pc, #28]	; (33fc <create_afe_task+0x34>)
    33e0:	4c07      	ldr	r4, [pc, #28]	; (3400 <create_afe_task+0x38>)
    33e2:	47a0      	blx	r4
    33e4:	2801      	cmp	r0, #1
    33e6:	d000      	beq.n	33ea <create_afe_task+0x22>
    33e8:	e7fe      	b.n	33e8 <create_afe_task+0x20>
					TASK_AFE_STACK_PRIORITY, 
					xCreatedAFETask)
	!= pdPASS) {
		while (1);
	}
	taskEXIT_CRITICAL(); 	
    33ea:	4b06      	ldr	r3, [pc, #24]	; (3404 <create_afe_task+0x3c>)
    33ec:	4798      	blx	r3
	
    33ee:	b002      	add	sp, #8
    33f0:	bd10      	pop	{r4, pc}
    33f2:	46c0      	nop			; (mov r8, r8)
    33f4:	00000a61 	.word	0x00000a61
    33f8:	00003cdc 	.word	0x00003cdc
    33fc:	00003391 	.word	0x00003391
    3400:	00001551 	.word	0x00001551
    3404:	00000a79 	.word	0x00000a79

00003408 <_GetAvailWriteSpace>:
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
    3408:	6903      	ldr	r3, [r0, #16]
  WrOff = pRing->WrOff;
    340a:	68c2      	ldr	r2, [r0, #12]
  if (RdOff <= WrOff) {
    340c:	4293      	cmp	r3, r2
    340e:	d902      	bls.n	3416 <_GetAvailWriteSpace+0xe>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
  } else {
    r = RdOff - WrOff - 1u;
    3410:	1a98      	subs	r0, r3, r2
    3412:	3801      	subs	r0, #1
  }
  return r;
}
    3414:	4770      	bx	lr
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
    3416:	6880      	ldr	r0, [r0, #8]
    3418:	1a80      	subs	r0, r0, r2
    341a:	1818      	adds	r0, r3, r0
    341c:	3801      	subs	r0, #1
    341e:	e7f9      	b.n	3414 <_GetAvailWriteSpace+0xc>

00003420 <_WriteNoCheck>:
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
    3420:	b5f0      	push	{r4, r5, r6, r7, lr}
    3422:	b083      	sub	sp, #12
    3424:	0005      	movs	r5, r0
    3426:	9101      	str	r1, [sp, #4]
    3428:	0016      	movs	r6, r2
  WrOff = pRing->WrOff;
    342a:	68c7      	ldr	r7, [r0, #12]
  Rem = pRing->SizeOfBuffer - WrOff;
    342c:	6883      	ldr	r3, [r0, #8]
    342e:	1bdc      	subs	r4, r3, r7
  if (Rem > NumBytes) {
    3430:	4294      	cmp	r4, r2
    3432:	d80e      	bhi.n	3452 <_WriteNoCheck+0x32>
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    3434:	6843      	ldr	r3, [r0, #4]
    3436:	19d8      	adds	r0, r3, r7
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
    3438:	0022      	movs	r2, r4
    343a:	9901      	ldr	r1, [sp, #4]
    343c:	4f08      	ldr	r7, [pc, #32]	; (3460 <_WriteNoCheck+0x40>)
    343e:	47b8      	blx	r7
    NumBytesAtOnce = NumBytes - Rem;
    3440:	1b36      	subs	r6, r6, r4
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    3442:	9b01      	ldr	r3, [sp, #4]
    3444:	1919      	adds	r1, r3, r4
    3446:	0032      	movs	r2, r6
    3448:	6868      	ldr	r0, [r5, #4]
    344a:	47b8      	blx	r7
    pRing->WrOff = NumBytesAtOnce;
    344c:	60ee      	str	r6, [r5, #12]
}
    344e:	b003      	add	sp, #12
    3450:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    3452:	6843      	ldr	r3, [r0, #4]
    3454:	19d8      	adds	r0, r3, r7
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
    3456:	4b02      	ldr	r3, [pc, #8]	; (3460 <_WriteNoCheck+0x40>)
    3458:	4798      	blx	r3
    pRing->WrOff = WrOff + NumBytes;
    345a:	19be      	adds	r6, r7, r6
    345c:	60ee      	str	r6, [r5, #12]
    345e:	e7f6      	b.n	344e <_WriteNoCheck+0x2e>
    3460:	00003a85 	.word	0x00003a85

00003464 <_WriteBlocking>:
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
    3464:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3466:	46ce      	mov	lr, r9
    3468:	4647      	mov	r7, r8
    346a:	b580      	push	{r7, lr}
    346c:	0005      	movs	r5, r0
    346e:	4689      	mov	r9, r1
    3470:	0016      	movs	r6, r2
  WrOff = pRing->WrOff;
    3472:	68c4      	ldr	r4, [r0, #12]
  NumBytesWritten = 0u;
    3474:	2300      	movs	r3, #0
    3476:	4698      	mov	r8, r3
    3478:	e015      	b.n	34a6 <_WriteBlocking+0x42>
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
    347a:	1b1b      	subs	r3, r3, r4
    347c:	68aa      	ldr	r2, [r5, #8]
    347e:	4694      	mov	ip, r2
    3480:	4463      	add	r3, ip
    3482:	3b01      	subs	r3, #1
    3484:	e014      	b.n	34b0 <_WriteBlocking+0x4c>
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    3486:	686b      	ldr	r3, [r5, #4]
    3488:	1918      	adds	r0, r3, r4
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
    348a:	003a      	movs	r2, r7
    348c:	4649      	mov	r1, r9
    348e:	4b11      	ldr	r3, [pc, #68]	; (34d4 <_WriteBlocking+0x70>)
    3490:	4798      	blx	r3
    NumBytesWritten += NumBytesToWrite;
    3492:	44b8      	add	r8, r7
    pBuffer         += NumBytesToWrite;
    3494:	44b9      	add	r9, r7
    NumBytes        -= NumBytesToWrite;
    3496:	1bf6      	subs	r6, r6, r7
    WrOff           += NumBytesToWrite;
    3498:	19e4      	adds	r4, r4, r7
    if (WrOff == pRing->SizeOfBuffer) {
    349a:	68ab      	ldr	r3, [r5, #8]
    349c:	429c      	cmp	r4, r3
    349e:	d011      	beq.n	34c4 <_WriteBlocking+0x60>
    pRing->WrOff = WrOff;
    34a0:	60ec      	str	r4, [r5, #12]
  } while (NumBytes);
    34a2:	2e00      	cmp	r6, #0
    34a4:	d010      	beq.n	34c8 <_WriteBlocking+0x64>
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
    34a6:	692b      	ldr	r3, [r5, #16]
    if (RdOff > WrOff) {
    34a8:	429c      	cmp	r4, r3
    34aa:	d2e6      	bcs.n	347a <_WriteBlocking+0x16>
      NumBytesToWrite = RdOff - WrOff - 1u;
    34ac:	1b1b      	subs	r3, r3, r4
    34ae:	3b01      	subs	r3, #1
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
    34b0:	68aa      	ldr	r2, [r5, #8]
    34b2:	1b12      	subs	r2, r2, r4
    34b4:	4293      	cmp	r3, r2
    34b6:	d900      	bls.n	34ba <_WriteBlocking+0x56>
    34b8:	0013      	movs	r3, r2
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
    34ba:	0037      	movs	r7, r6
    34bc:	429e      	cmp	r6, r3
    34be:	d9e2      	bls.n	3486 <_WriteBlocking+0x22>
    34c0:	001f      	movs	r7, r3
    34c2:	e7e0      	b.n	3486 <_WriteBlocking+0x22>
      WrOff = 0u;
    34c4:	2400      	movs	r4, #0
    34c6:	e7eb      	b.n	34a0 <_WriteBlocking+0x3c>
}
    34c8:	4640      	mov	r0, r8
    34ca:	bc0c      	pop	{r2, r3}
    34cc:	4690      	mov	r8, r2
    34ce:	4699      	mov	r9, r3
    34d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    34d2:	46c0      	nop			; (mov r8, r8)
    34d4:	00003a85 	.word	0x00003a85

000034d8 <_DoInit>:
static void _DoInit(void) {
    34d8:	b510      	push	{r4, lr}
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
    34da:	4c14      	ldr	r4, [pc, #80]	; (352c <_DoInit+0x54>)
    34dc:	22a8      	movs	r2, #168	; 0xa8
    34de:	2100      	movs	r1, #0
    34e0:	0020      	movs	r0, r4
    34e2:	4b13      	ldr	r3, [pc, #76]	; (3530 <_DoInit+0x58>)
    34e4:	4798      	blx	r3
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    34e6:	2303      	movs	r3, #3
    34e8:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    34ea:	6163      	str	r3, [r4, #20]
  p->aUp[0].sName         = "Terminal";
    34ec:	4a11      	ldr	r2, [pc, #68]	; (3534 <_DoInit+0x5c>)
    34ee:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    34f0:	4b11      	ldr	r3, [pc, #68]	; (3538 <_DoInit+0x60>)
    34f2:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
    34f4:	2380      	movs	r3, #128	; 0x80
    34f6:	00db      	lsls	r3, r3, #3
    34f8:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
    34fa:	2300      	movs	r3, #0
    34fc:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    34fe:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    3500:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].sName         = "Terminal";
    3502:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    3504:	4a0d      	ldr	r2, [pc, #52]	; (353c <_DoInit+0x64>)
    3506:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
    3508:	2210      	movs	r2, #16
    350a:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
    350c:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    350e:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    3510:	6763      	str	r3, [r4, #116]	; 0x74
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
    3512:	e007      	b.n	3524 <_DoInit+0x4c>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
    3514:	210f      	movs	r1, #15
    3516:	1ac9      	subs	r1, r1, r3
    3518:	4a09      	ldr	r2, [pc, #36]	; (3540 <_DoInit+0x68>)
    351a:	1852      	adds	r2, r2, r1
    351c:	7c11      	ldrb	r1, [r2, #16]
    351e:	4a03      	ldr	r2, [pc, #12]	; (352c <_DoInit+0x54>)
    3520:	54d1      	strb	r1, [r2, r3]
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
    3522:	3301      	adds	r3, #1
    3524:	2b0f      	cmp	r3, #15
    3526:	d9f5      	bls.n	3514 <_DoInit+0x3c>
}
    3528:	bd10      	pop	{r4, pc}
    352a:	46c0      	nop			; (mov r8, r8)
    352c:	200036b0 	.word	0x200036b0
    3530:	00003a97 	.word	0x00003a97
    3534:	00003d04 	.word	0x00003d04
    3538:	20002bdc 	.word	0x20002bdc
    353c:	20002fdc 	.word	0x20002fdc
    3540:	00003ce0 	.word	0x00003ce0

00003544 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    3544:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3546:	000f      	movs	r7, r1
    3548:	0016      	movs	r6, r2
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
    354a:	1c42      	adds	r2, r0, #1
    354c:	0053      	lsls	r3, r2, #1
    354e:	189b      	adds	r3, r3, r2
    3550:	00dd      	lsls	r5, r3, #3
    3552:	4b17      	ldr	r3, [pc, #92]	; (35b0 <SEGGER_RTT_WriteNoLock+0x6c>)
    3554:	18ed      	adds	r5, r5, r3
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
    3556:	0042      	lsls	r2, r0, #1
    3558:	1810      	adds	r0, r2, r0
    355a:	00c2      	lsls	r2, r0, #3
    355c:	189b      	adds	r3, r3, r2
    355e:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    3560:	2c01      	cmp	r4, #1
    3562:	d011      	beq.n	3588 <SEGGER_RTT_WriteNoLock+0x44>
    3564:	2c00      	cmp	r4, #0
    3566:	d003      	beq.n	3570 <SEGGER_RTT_WriteNoLock+0x2c>
    3568:	2c02      	cmp	r4, #2
    356a:	d01b      	beq.n	35a4 <SEGGER_RTT_WriteNoLock+0x60>
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
    break;
  default:
    Status = 0u;
    356c:	2400      	movs	r4, #0
    break;
  }
  //
  // Finish up.
  //
  return Status;
    356e:	e017      	b.n	35a0 <SEGGER_RTT_WriteNoLock+0x5c>
    Avail = _GetAvailWriteSpace(pRing);
    3570:	0028      	movs	r0, r5
    3572:	4b10      	ldr	r3, [pc, #64]	; (35b4 <SEGGER_RTT_WriteNoLock+0x70>)
    3574:	4798      	blx	r3
    if (Avail < NumBytes) {
    3576:	42b0      	cmp	r0, r6
    3578:	d312      	bcc.n	35a0 <SEGGER_RTT_WriteNoLock+0x5c>
      _WriteNoCheck(pRing, pData, NumBytes);
    357a:	0032      	movs	r2, r6
    357c:	0039      	movs	r1, r7
    357e:	0028      	movs	r0, r5
    3580:	4b0d      	ldr	r3, [pc, #52]	; (35b8 <SEGGER_RTT_WriteNoLock+0x74>)
    3582:	4798      	blx	r3
      Status = NumBytes;
    3584:	0034      	movs	r4, r6
    3586:	e00b      	b.n	35a0 <SEGGER_RTT_WriteNoLock+0x5c>
    Avail = _GetAvailWriteSpace(pRing);
    3588:	0028      	movs	r0, r5
    358a:	4b0a      	ldr	r3, [pc, #40]	; (35b4 <SEGGER_RTT_WriteNoLock+0x70>)
    358c:	4798      	blx	r3
    Status = Avail < NumBytes ? Avail : NumBytes;
    358e:	0034      	movs	r4, r6
    3590:	4286      	cmp	r6, r0
    3592:	d900      	bls.n	3596 <SEGGER_RTT_WriteNoLock+0x52>
    3594:	0004      	movs	r4, r0
    _WriteNoCheck(pRing, pData, Status);
    3596:	0022      	movs	r2, r4
    3598:	0039      	movs	r1, r7
    359a:	0028      	movs	r0, r5
    359c:	4b06      	ldr	r3, [pc, #24]	; (35b8 <SEGGER_RTT_WriteNoLock+0x74>)
    359e:	4798      	blx	r3
}
    35a0:	0020      	movs	r0, r4
    35a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Status = _WriteBlocking(pRing, pData, NumBytes);
    35a4:	0032      	movs	r2, r6
    35a6:	0028      	movs	r0, r5
    35a8:	4b04      	ldr	r3, [pc, #16]	; (35bc <SEGGER_RTT_WriteNoLock+0x78>)
    35aa:	4798      	blx	r3
    35ac:	0004      	movs	r4, r0
    break;
    35ae:	e7f7      	b.n	35a0 <SEGGER_RTT_WriteNoLock+0x5c>
    35b0:	200036b0 	.word	0x200036b0
    35b4:	00003409 	.word	0x00003409
    35b8:	00003421 	.word	0x00003421
    35bc:	00003465 	.word	0x00003465

000035c0 <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    35c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    35c2:	0005      	movs	r5, r0
    35c4:	000e      	movs	r6, r1
    35c6:	0017      	movs	r7, r2
  unsigned Status;

  INIT();
    35c8:	4b09      	ldr	r3, [pc, #36]	; (35f0 <SEGGER_RTT_Write+0x30>)
    35ca:	781b      	ldrb	r3, [r3, #0]
    35cc:	2b00      	cmp	r3, #0
    35ce:	d00c      	beq.n	35ea <SEGGER_RTT_Write+0x2a>
  SEGGER_RTT_LOCK();
    35d0:	f3ef 8410 	mrs	r4, PRIMASK
    35d4:	2101      	movs	r1, #1
    35d6:	f381 8810 	msr	PRIMASK, r1
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
    35da:	003a      	movs	r2, r7
    35dc:	0031      	movs	r1, r6
    35de:	0028      	movs	r0, r5
    35e0:	4b04      	ldr	r3, [pc, #16]	; (35f4 <SEGGER_RTT_Write+0x34>)
    35e2:	4798      	blx	r3
  SEGGER_RTT_UNLOCK();
    35e4:	f384 8810 	msr	PRIMASK, r4
  return Status;
}
    35e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  INIT();
    35ea:	4b03      	ldr	r3, [pc, #12]	; (35f8 <SEGGER_RTT_Write+0x38>)
    35ec:	4798      	blx	r3
    35ee:	e7ef      	b.n	35d0 <SEGGER_RTT_Write+0x10>
    35f0:	200036b0 	.word	0x200036b0
    35f4:	00003545 	.word	0x00003545
    35f8:	000034d9 	.word	0x000034d9

000035fc <_StoreChar>:
*/
/*********************************************************************
*
*       _StoreChar
*/
static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
    35fc:	b510      	push	{r4, lr}
    35fe:	0004      	movs	r4, r0
  unsigned Cnt;

  Cnt = p->Cnt;
    3600:	6882      	ldr	r2, [r0, #8]
  if ((Cnt + 1u) <= p->BufferSize) {
    3602:	1c53      	adds	r3, r2, #1
    3604:	6840      	ldr	r0, [r0, #4]
    3606:	4283      	cmp	r3, r0
    3608:	d805      	bhi.n	3616 <_StoreChar+0x1a>
    *(p->pBuffer + Cnt) = c;
    360a:	6820      	ldr	r0, [r4, #0]
    360c:	5481      	strb	r1, [r0, r2]
    p->Cnt = Cnt + 1u;
    360e:	60a3      	str	r3, [r4, #8]
    p->ReturnValue++;
    3610:	68e3      	ldr	r3, [r4, #12]
    3612:	3301      	adds	r3, #1
    3614:	60e3      	str	r3, [r4, #12]
  }
  //
  // Write part of string, when the buffer is full
  //
  if (p->Cnt == p->BufferSize) {
    3616:	68a2      	ldr	r2, [r4, #8]
    3618:	6863      	ldr	r3, [r4, #4]
    361a:	429a      	cmp	r2, r3
    361c:	d000      	beq.n	3620 <_StoreChar+0x24>
      p->ReturnValue = -1;
    } else {
      p->Cnt = 0u;
    }
  }
}
    361e:	bd10      	pop	{r4, pc}
    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
    3620:	6821      	ldr	r1, [r4, #0]
    3622:	6920      	ldr	r0, [r4, #16]
    3624:	4b05      	ldr	r3, [pc, #20]	; (363c <_StoreChar+0x40>)
    3626:	4798      	blx	r3
    3628:	68a3      	ldr	r3, [r4, #8]
    362a:	4298      	cmp	r0, r3
    362c:	d003      	beq.n	3636 <_StoreChar+0x3a>
      p->ReturnValue = -1;
    362e:	2301      	movs	r3, #1
    3630:	425b      	negs	r3, r3
    3632:	60e3      	str	r3, [r4, #12]
    3634:	e7f3      	b.n	361e <_StoreChar+0x22>
      p->Cnt = 0u;
    3636:	2300      	movs	r3, #0
    3638:	60a3      	str	r3, [r4, #8]
}
    363a:	e7f0      	b.n	361e <_StoreChar+0x22>
    363c:	000035c1 	.word	0x000035c1

00003640 <_PrintUnsigned>:

/*********************************************************************
*
*       _PrintUnsigned
*/
static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    3640:	b5f0      	push	{r4, r5, r6, r7, lr}
    3642:	46de      	mov	lr, fp
    3644:	464f      	mov	r7, r9
    3646:	4646      	mov	r6, r8
    3648:	b5c0      	push	{r6, r7, lr}
    364a:	b082      	sub	sp, #8
    364c:	0006      	movs	r6, r0
    364e:	9101      	str	r1, [sp, #4]
    3650:	0015      	movs	r5, r2
    3652:	001c      	movs	r4, r3
    3654:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    3656:	4698      	mov	r8, r3
  unsigned Digit;
  unsigned Number;
  unsigned Width;
  char c;

  Number = v;
    3658:	0008      	movs	r0, r1
  Digit = 1u;
  //
  // Get actual field width
  //
  Width = 1u;
    365a:	2301      	movs	r3, #1
    365c:	4699      	mov	r9, r3
  while (Number >= Base) {
    365e:	e005      	b.n	366c <_PrintUnsigned+0x2c>
    Number = (Number / Base);
    3660:	0029      	movs	r1, r5
    3662:	4b38      	ldr	r3, [pc, #224]	; (3744 <_PrintUnsigned+0x104>)
    3664:	4798      	blx	r3
    Width++;
    3666:	2301      	movs	r3, #1
    3668:	469c      	mov	ip, r3
    366a:	44e1      	add	r9, ip
  while (Number >= Base) {
    366c:	42a8      	cmp	r0, r5
    366e:	d2f7      	bcs.n	3660 <_PrintUnsigned+0x20>
  }
  if (NumDigits > Width) {
    3670:	45a1      	cmp	r9, r4
    3672:	d200      	bcs.n	3676 <_PrintUnsigned+0x36>
    Width = NumDigits;
    3674:	46a1      	mov	r9, r4
  }
  //
  // Print leading chars if necessary
  //
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
    3676:	2301      	movs	r3, #1
    3678:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    367a:	401a      	ands	r2, r3
    367c:	4693      	mov	fp, r2
    367e:	d11a      	bne.n	36b6 <_PrintUnsigned+0x76>
    if (FieldWidth != 0u) {
    3680:	4643      	mov	r3, r8
    3682:	2b00      	cmp	r3, #0
    3684:	d017      	beq.n	36b6 <_PrintUnsigned+0x76>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
    3686:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3688:	079b      	lsls	r3, r3, #30
    368a:	d503      	bpl.n	3694 <_PrintUnsigned+0x54>
    368c:	2c00      	cmp	r4, #0
    368e:	d017      	beq.n	36c0 <_PrintUnsigned+0x80>
        c = '0';
      } else {
        c = ' ';
    3690:	2720      	movs	r7, #32
    3692:	e000      	b.n	3696 <_PrintUnsigned+0x56>
    3694:	2720      	movs	r7, #32
      }
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    3696:	4643      	mov	r3, r8
    3698:	2b00      	cmp	r3, #0
    369a:	d00c      	beq.n	36b6 <_PrintUnsigned+0x76>
    369c:	45c8      	cmp	r8, r9
    369e:	d90a      	bls.n	36b6 <_PrintUnsigned+0x76>
        FieldWidth--;
    36a0:	2301      	movs	r3, #1
    36a2:	425b      	negs	r3, r3
    36a4:	469c      	mov	ip, r3
    36a6:	44e0      	add	r8, ip
        _StoreChar(pBufferDesc, c);
    36a8:	0039      	movs	r1, r7
    36aa:	0030      	movs	r0, r6
    36ac:	4b26      	ldr	r3, [pc, #152]	; (3748 <_PrintUnsigned+0x108>)
    36ae:	4798      	blx	r3
        if (pBufferDesc->ReturnValue < 0) {
    36b0:	68f3      	ldr	r3, [r6, #12]
    36b2:	2b00      	cmp	r3, #0
    36b4:	daef      	bge.n	3696 <_PrintUnsigned+0x56>
          break;
        }
      }
    }
  }
  if (pBufferDesc->ReturnValue >= 0) {
    36b6:	68f3      	ldr	r3, [r6, #12]
    36b8:	2b00      	cmp	r3, #0
    36ba:	db3c      	blt.n	3736 <_PrintUnsigned+0xf6>
    36bc:	2701      	movs	r7, #1
    36be:	e008      	b.n	36d2 <_PrintUnsigned+0x92>
        c = '0';
    36c0:	2730      	movs	r7, #48	; 0x30
    36c2:	e7e8      	b.n	3696 <_PrintUnsigned+0x56>
    //
    while (1) {
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
        NumDigits--;
      } else {
        Div = v / Digit;
    36c4:	0039      	movs	r1, r7
    36c6:	9801      	ldr	r0, [sp, #4]
    36c8:	4b1e      	ldr	r3, [pc, #120]	; (3744 <_PrintUnsigned+0x104>)
    36ca:	4798      	blx	r3
        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
    36cc:	4285      	cmp	r5, r0
    36ce:	d804      	bhi.n	36da <_PrintUnsigned+0x9a>
          break;
        }
      }
      Digit *= Base;
    36d0:	436f      	muls	r7, r5
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
    36d2:	2c01      	cmp	r4, #1
    36d4:	d9f6      	bls.n	36c4 <_PrintUnsigned+0x84>
        NumDigits--;
    36d6:	3c01      	subs	r4, #1
    36d8:	e7fa      	b.n	36d0 <_PrintUnsigned+0x90>
    }
    //
    // Output digits
    //
    do {
      Div = v / Digit;
    36da:	0039      	movs	r1, r7
    36dc:	9801      	ldr	r0, [sp, #4]
    36de:	4b19      	ldr	r3, [pc, #100]	; (3744 <_PrintUnsigned+0x104>)
    36e0:	4798      	blx	r3
    36e2:	0004      	movs	r4, r0
    36e4:	0039      	movs	r1, r7
    36e6:	9801      	ldr	r0, [sp, #4]
    36e8:	4b18      	ldr	r3, [pc, #96]	; (374c <_PrintUnsigned+0x10c>)
    36ea:	4798      	blx	r3
    36ec:	9101      	str	r1, [sp, #4]
      v -= Div * Digit;
      _StoreChar(pBufferDesc, _aV2C[Div]);
    36ee:	4b18      	ldr	r3, [pc, #96]	; (3750 <_PrintUnsigned+0x110>)
    36f0:	5d19      	ldrb	r1, [r3, r4]
    36f2:	0030      	movs	r0, r6
    36f4:	4b14      	ldr	r3, [pc, #80]	; (3748 <_PrintUnsigned+0x108>)
    36f6:	4798      	blx	r3
      if (pBufferDesc->ReturnValue < 0) {
    36f8:	68f3      	ldr	r3, [r6, #12]
    36fa:	2b00      	cmp	r3, #0
    36fc:	db05      	blt.n	370a <_PrintUnsigned+0xca>
        break;
      }
      Digit /= Base;
    36fe:	0029      	movs	r1, r5
    3700:	0038      	movs	r0, r7
    3702:	4b10      	ldr	r3, [pc, #64]	; (3744 <_PrintUnsigned+0x104>)
    3704:	4798      	blx	r3
    3706:	1e07      	subs	r7, r0, #0
    } while (Digit);
    3708:	d1e7      	bne.n	36da <_PrintUnsigned+0x9a>
    //
    // Print trailing spaces if necessary
    //
    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
    370a:	465b      	mov	r3, fp
    370c:	2b00      	cmp	r3, #0
    370e:	d012      	beq.n	3736 <_PrintUnsigned+0xf6>
      if (FieldWidth != 0u) {
    3710:	4643      	mov	r3, r8
    3712:	2b00      	cmp	r3, #0
    3714:	d00f      	beq.n	3736 <_PrintUnsigned+0xf6>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    3716:	4643      	mov	r3, r8
    3718:	2b00      	cmp	r3, #0
    371a:	d00c      	beq.n	3736 <_PrintUnsigned+0xf6>
    371c:	45c8      	cmp	r8, r9
    371e:	d90a      	bls.n	3736 <_PrintUnsigned+0xf6>
          FieldWidth--;
    3720:	2301      	movs	r3, #1
    3722:	425b      	negs	r3, r3
    3724:	469c      	mov	ip, r3
    3726:	44e0      	add	r8, ip
          _StoreChar(pBufferDesc, ' ');
    3728:	2120      	movs	r1, #32
    372a:	0030      	movs	r0, r6
    372c:	4b06      	ldr	r3, [pc, #24]	; (3748 <_PrintUnsigned+0x108>)
    372e:	4798      	blx	r3
          if (pBufferDesc->ReturnValue < 0) {
    3730:	68f3      	ldr	r3, [r6, #12]
    3732:	2b00      	cmp	r3, #0
    3734:	daef      	bge.n	3716 <_PrintUnsigned+0xd6>
          }
        }
      }
    }
  }
}
    3736:	b002      	add	sp, #8
    3738:	bc1c      	pop	{r2, r3, r4}
    373a:	4690      	mov	r8, r2
    373c:	4699      	mov	r9, r3
    373e:	46a3      	mov	fp, r4
    3740:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3742:	46c0      	nop			; (mov r8, r8)
    3744:	00002b6d 	.word	0x00002b6d
    3748:	000035fd 	.word	0x000035fd
    374c:	00002ba5 	.word	0x00002ba5
    3750:	00003d10 	.word	0x00003d10

00003754 <_PrintInt>:

/*********************************************************************
*
*       _PrintInt
*/
static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    3754:	b5f0      	push	{r4, r5, r6, r7, lr}
    3756:	46d6      	mov	lr, sl
    3758:	464f      	mov	r7, r9
    375a:	b580      	push	{r7, lr}
    375c:	b083      	sub	sp, #12
    375e:	0006      	movs	r6, r0
    3760:	4689      	mov	r9, r1
    3762:	0015      	movs	r5, r2
    3764:	469a      	mov	sl, r3
    3766:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  unsigned Width;
  int Number;

  Number = (v < 0) ? -v : v;
    3768:	17ca      	asrs	r2, r1, #31
    376a:	1888      	adds	r0, r1, r2
    376c:	4050      	eors	r0, r2

  //
  // Get actual field width
  //
  Width = 1u;
    376e:	2401      	movs	r4, #1
  while (Number >= (int)Base) {
    3770:	e003      	b.n	377a <_PrintInt+0x26>
    Number = (Number / (int)Base);
    3772:	0029      	movs	r1, r5
    3774:	4b34      	ldr	r3, [pc, #208]	; (3848 <_PrintInt+0xf4>)
    3776:	4798      	blx	r3
    Width++;
    3778:	3401      	adds	r4, #1
  while (Number >= (int)Base) {
    377a:	42a8      	cmp	r0, r5
    377c:	daf9      	bge.n	3772 <_PrintInt+0x1e>
  }
  if (NumDigits > Width) {
    377e:	4554      	cmp	r4, sl
    3780:	d200      	bcs.n	3784 <_PrintInt+0x30>
    Width = NumDigits;
    3782:	4654      	mov	r4, sl
  }
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
    3784:	2f00      	cmp	r7, #0
    3786:	d006      	beq.n	3796 <_PrintInt+0x42>
    3788:	464b      	mov	r3, r9
    378a:	2b00      	cmp	r3, #0
    378c:	db02      	blt.n	3794 <_PrintInt+0x40>
    378e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3790:	075b      	lsls	r3, r3, #29
    3792:	d500      	bpl.n	3796 <_PrintInt+0x42>
    FieldWidth--;
    3794:	3f01      	subs	r7, #1
  }

  //
  // Print leading spaces if necessary
  //
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
    3796:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3798:	079b      	lsls	r3, r3, #30
    379a:	d502      	bpl.n	37a2 <_PrintInt+0x4e>
    379c:	4653      	mov	r3, sl
    379e:	2b00      	cmp	r3, #0
    37a0:	d004      	beq.n	37ac <_PrintInt+0x58>
    37a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    37a4:	07db      	lsls	r3, r3, #31
    37a6:	d401      	bmi.n	37ac <_PrintInt+0x58>
    if (FieldWidth != 0u) {
    37a8:	2f00      	cmp	r7, #0
    37aa:	d121      	bne.n	37f0 <_PrintInt+0x9c>
    }
  }
  //
  // Print sign if necessary
  //
  if (pBufferDesc->ReturnValue >= 0) {
    37ac:	68f3      	ldr	r3, [r6, #12]
    37ae:	2b00      	cmp	r3, #0
    37b0:	db19      	blt.n	37e6 <_PrintInt+0x92>
    if (v < 0) {
    37b2:	464b      	mov	r3, r9
    37b4:	2b00      	cmp	r3, #0
    37b6:	db28      	blt.n	380a <_PrintInt+0xb6>
      v = -v;
      _StoreChar(pBufferDesc, '-');
    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
    37b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    37ba:	075b      	lsls	r3, r3, #29
    37bc:	d42c      	bmi.n	3818 <_PrintInt+0xc4>
      _StoreChar(pBufferDesc, '+');
    } else {

    }
    if (pBufferDesc->ReturnValue >= 0) {
    37be:	68f3      	ldr	r3, [r6, #12]
    37c0:	2b00      	cmp	r3, #0
    37c2:	db10      	blt.n	37e6 <_PrintInt+0x92>
      //
      // Print leading zeros if necessary
      //
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
    37c4:	2303      	movs	r3, #3
    37c6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    37c8:	4013      	ands	r3, r2
    37ca:	2b02      	cmp	r3, #2
    37cc:	d029      	beq.n	3822 <_PrintInt+0xce>
              break;
            }
          }
        }
      }
      if (pBufferDesc->ReturnValue >= 0) {
    37ce:	68f3      	ldr	r3, [r6, #12]
    37d0:	2b00      	cmp	r3, #0
    37d2:	db08      	blt.n	37e6 <_PrintInt+0x92>
        //
        // Print number without sign
        //
        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
    37d4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    37d6:	9301      	str	r3, [sp, #4]
    37d8:	9700      	str	r7, [sp, #0]
    37da:	4653      	mov	r3, sl
    37dc:	002a      	movs	r2, r5
    37de:	4649      	mov	r1, r9
    37e0:	0030      	movs	r0, r6
    37e2:	4c1a      	ldr	r4, [pc, #104]	; (384c <_PrintInt+0xf8>)
    37e4:	47a0      	blx	r4
      }
    }
  }
}
    37e6:	b003      	add	sp, #12
    37e8:	bc0c      	pop	{r2, r3}
    37ea:	4691      	mov	r9, r2
    37ec:	469a      	mov	sl, r3
    37ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    37f0:	2f00      	cmp	r7, #0
    37f2:	d0db      	beq.n	37ac <_PrintInt+0x58>
    37f4:	42a7      	cmp	r7, r4
    37f6:	d9d9      	bls.n	37ac <_PrintInt+0x58>
        FieldWidth--;
    37f8:	3f01      	subs	r7, #1
        _StoreChar(pBufferDesc, ' ');
    37fa:	2120      	movs	r1, #32
    37fc:	0030      	movs	r0, r6
    37fe:	4b14      	ldr	r3, [pc, #80]	; (3850 <_PrintInt+0xfc>)
    3800:	4798      	blx	r3
        if (pBufferDesc->ReturnValue < 0) {
    3802:	68f3      	ldr	r3, [r6, #12]
    3804:	2b00      	cmp	r3, #0
    3806:	daf3      	bge.n	37f0 <_PrintInt+0x9c>
    3808:	e7d0      	b.n	37ac <_PrintInt+0x58>
      v = -v;
    380a:	425b      	negs	r3, r3
    380c:	4699      	mov	r9, r3
      _StoreChar(pBufferDesc, '-');
    380e:	212d      	movs	r1, #45	; 0x2d
    3810:	0030      	movs	r0, r6
    3812:	4b0f      	ldr	r3, [pc, #60]	; (3850 <_PrintInt+0xfc>)
    3814:	4798      	blx	r3
    3816:	e7d2      	b.n	37be <_PrintInt+0x6a>
      _StoreChar(pBufferDesc, '+');
    3818:	212b      	movs	r1, #43	; 0x2b
    381a:	0030      	movs	r0, r6
    381c:	4b0c      	ldr	r3, [pc, #48]	; (3850 <_PrintInt+0xfc>)
    381e:	4798      	blx	r3
    3820:	e7cd      	b.n	37be <_PrintInt+0x6a>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
    3822:	4653      	mov	r3, sl
    3824:	2b00      	cmp	r3, #0
    3826:	d1d2      	bne.n	37ce <_PrintInt+0x7a>
        if (FieldWidth != 0u) {
    3828:	2f00      	cmp	r7, #0
    382a:	d0d0      	beq.n	37ce <_PrintInt+0x7a>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    382c:	2f00      	cmp	r7, #0
    382e:	d0ce      	beq.n	37ce <_PrintInt+0x7a>
    3830:	42a7      	cmp	r7, r4
    3832:	d9cc      	bls.n	37ce <_PrintInt+0x7a>
            FieldWidth--;
    3834:	3f01      	subs	r7, #1
            _StoreChar(pBufferDesc, '0');
    3836:	2130      	movs	r1, #48	; 0x30
    3838:	0030      	movs	r0, r6
    383a:	4b05      	ldr	r3, [pc, #20]	; (3850 <_PrintInt+0xfc>)
    383c:	4798      	blx	r3
            if (pBufferDesc->ReturnValue < 0) {
    383e:	68f3      	ldr	r3, [r6, #12]
    3840:	2b00      	cmp	r3, #0
    3842:	daf3      	bge.n	382c <_PrintInt+0xd8>
    3844:	e7c3      	b.n	37ce <_PrintInt+0x7a>
    3846:	46c0      	nop			; (mov r8, r8)
    3848:	00002b37 	.word	0x00002b37
    384c:	00003641 	.word	0x00003641
    3850:	000035fd 	.word	0x000035fd

00003854 <SEGGER_RTT_vprintf>:
*
*  Return values
*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
*     < 0:  Error
*/
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
    3854:	b5f0      	push	{r4, r5, r6, r7, lr}
    3856:	46c6      	mov	lr, r8
    3858:	b500      	push	{lr}
    385a:	b09a      	sub	sp, #104	; 0x68
    385c:	4680      	mov	r8, r0
    385e:	000c      	movs	r4, r1
    3860:	0015      	movs	r5, r2
  unsigned NumDigits;
  unsigned FormatFlags;
  unsigned FieldWidth;
  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];

  BufferDesc.pBuffer        = acBuffer;
    3862:	ab05      	add	r3, sp, #20
    3864:	9315      	str	r3, [sp, #84]	; 0x54
  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
    3866:	2340      	movs	r3, #64	; 0x40
    3868:	9316      	str	r3, [sp, #88]	; 0x58
  BufferDesc.Cnt            = 0u;
    386a:	2300      	movs	r3, #0
    386c:	9317      	str	r3, [sp, #92]	; 0x5c
  BufferDesc.RTTBufferIndex = BufferIndex;
    386e:	9019      	str	r0, [sp, #100]	; 0x64
  BufferDesc.ReturnValue    = 0;
    3870:	9318      	str	r3, [sp, #96]	; 0x60
    3872:	e08d      	b.n	3990 <SEGGER_RTT_vprintf+0x13c>
    3874:	2000      	movs	r0, #0
    3876:	2201      	movs	r2, #1
    3878:	e00a      	b.n	3890 <SEGGER_RTT_vprintf+0x3c>
      //
      FormatFlags = 0u;
      v = 1;
      do {
        c = *sFormat;
        switch (c) {
    387a:	2b23      	cmp	r3, #35	; 0x23
    387c:	d118      	bne.n	38b0 <SEGGER_RTT_vprintf+0x5c>
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
    387e:	2308      	movs	r3, #8
    3880:	4318      	orrs	r0, r3
    3882:	3401      	adds	r4, #1
    3884:	e002      	b.n	388c <SEGGER_RTT_vprintf+0x38>
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
    3886:	2301      	movs	r3, #1
    3888:	4318      	orrs	r0, r3
    388a:	3401      	adds	r4, #1
        default:  v = 0; break;
        }
      } while (v);
    388c:	2a00      	cmp	r2, #0
    388e:	d011      	beq.n	38b4 <SEGGER_RTT_vprintf+0x60>
        c = *sFormat;
    3890:	7823      	ldrb	r3, [r4, #0]
        switch (c) {
    3892:	2b2b      	cmp	r3, #43	; 0x2b
    3894:	d008      	beq.n	38a8 <SEGGER_RTT_vprintf+0x54>
    3896:	d9f0      	bls.n	387a <SEGGER_RTT_vprintf+0x26>
    3898:	2b2d      	cmp	r3, #45	; 0x2d
    389a:	d0f4      	beq.n	3886 <SEGGER_RTT_vprintf+0x32>
    389c:	2b30      	cmp	r3, #48	; 0x30
    389e:	d107      	bne.n	38b0 <SEGGER_RTT_vprintf+0x5c>
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
    38a0:	2302      	movs	r3, #2
    38a2:	4318      	orrs	r0, r3
    38a4:	3401      	adds	r4, #1
    38a6:	e7f1      	b.n	388c <SEGGER_RTT_vprintf+0x38>
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
    38a8:	2304      	movs	r3, #4
    38aa:	4318      	orrs	r0, r3
    38ac:	3401      	adds	r4, #1
    38ae:	e7ed      	b.n	388c <SEGGER_RTT_vprintf+0x38>
        default:  v = 0; break;
    38b0:	2200      	movs	r2, #0
    38b2:	e7eb      	b.n	388c <SEGGER_RTT_vprintf+0x38>
      //
      // filter out field with
      //
      FieldWidth = 0u;
      do {
        c = *sFormat;
    38b4:	7827      	ldrb	r7, [r4, #0]
        if ((c < '0') || (c > '9')) {
    38b6:	0039      	movs	r1, r7
    38b8:	3930      	subs	r1, #48	; 0x30
    38ba:	b2c9      	uxtb	r1, r1
    38bc:	2909      	cmp	r1, #9
    38be:	d807      	bhi.n	38d0 <SEGGER_RTT_vprintf+0x7c>
          break;
        }
        sFormat++;
    38c0:	3401      	adds	r4, #1
        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
    38c2:	0091      	lsls	r1, r2, #2
    38c4:	188a      	adds	r2, r1, r2
    38c6:	0053      	lsls	r3, r2, #1
    38c8:	19db      	adds	r3, r3, r7
    38ca:	3b30      	subs	r3, #48	; 0x30
    38cc:	001a      	movs	r2, r3
        c = *sFormat;
    38ce:	e7f1      	b.n	38b4 <SEGGER_RTT_vprintf+0x60>
      //
      // Filter out precision (number of digits to display)
      //
      NumDigits = 0u;
      c = *sFormat;
      if (c == '.') {
    38d0:	2f2e      	cmp	r7, #46	; 0x2e
    38d2:	d002      	beq.n	38da <SEGGER_RTT_vprintf+0x86>
      NumDigits = 0u;
    38d4:	2300      	movs	r3, #0
        } while (1);
      }
      //
      // Filter out length modifier
      //
      c = *sFormat;
    38d6:	7821      	ldrb	r1, [r4, #0]
    38d8:	e011      	b.n	38fe <SEGGER_RTT_vprintf+0xaa>
        sFormat++;
    38da:	3401      	adds	r4, #1
      NumDigits = 0u;
    38dc:	2300      	movs	r3, #0
          c = *sFormat;
    38de:	7826      	ldrb	r6, [r4, #0]
          if ((c < '0') || (c > '9')) {
    38e0:	0037      	movs	r7, r6
    38e2:	3f30      	subs	r7, #48	; 0x30
    38e4:	b2ff      	uxtb	r7, r7
    38e6:	2f09      	cmp	r7, #9
    38e8:	d8f5      	bhi.n	38d6 <SEGGER_RTT_vprintf+0x82>
          sFormat++;
    38ea:	3401      	adds	r4, #1
          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
    38ec:	009f      	lsls	r7, r3, #2
    38ee:	18fb      	adds	r3, r7, r3
    38f0:	0059      	lsls	r1, r3, #1
    38f2:	1989      	adds	r1, r1, r6
    38f4:	000b      	movs	r3, r1
    38f6:	3b30      	subs	r3, #48	; 0x30
          c = *sFormat;
    38f8:	e7f1      	b.n	38de <SEGGER_RTT_vprintf+0x8a>
      do {
        if ((c == 'l') || (c == 'h')) {
          sFormat++;
    38fa:	3401      	adds	r4, #1
          c = *sFormat;
    38fc:	7821      	ldrb	r1, [r4, #0]
        if ((c == 'l') || (c == 'h')) {
    38fe:	296c      	cmp	r1, #108	; 0x6c
    3900:	d0fb      	beq.n	38fa <SEGGER_RTT_vprintf+0xa6>
    3902:	2968      	cmp	r1, #104	; 0x68
    3904:	d0f9      	beq.n	38fa <SEGGER_RTT_vprintf+0xa6>
        }
      } while (1);
      //
      // Handle specifiers
      //
      switch (c) {
    3906:	2964      	cmp	r1, #100	; 0x64
    3908:	d04d      	beq.n	39a6 <SEGGER_RTT_vprintf+0x152>
    390a:	d90f      	bls.n	392c <SEGGER_RTT_vprintf+0xd8>
    390c:	2973      	cmp	r1, #115	; 0x73
    390e:	d055      	beq.n	39bc <SEGGER_RTT_vprintf+0x168>
    3910:	d917      	bls.n	3942 <SEGGER_RTT_vprintf+0xee>
    3912:	2975      	cmp	r1, #117	; 0x75
    3914:	d124      	bne.n	3960 <SEGGER_RTT_vprintf+0x10c>
      case 'd':
        v = va_arg(*pParamList, int);
        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
        break;
      case 'u':
        v = va_arg(*pParamList, int);
    3916:	6829      	ldr	r1, [r5, #0]
    3918:	1d0f      	adds	r7, r1, #4
    391a:	602f      	str	r7, [r5, #0]
    391c:	6809      	ldr	r1, [r1, #0]
        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
    391e:	9001      	str	r0, [sp, #4]
    3920:	9200      	str	r2, [sp, #0]
    3922:	220a      	movs	r2, #10
    3924:	a815      	add	r0, sp, #84	; 0x54
    3926:	4f39      	ldr	r7, [pc, #228]	; (3a0c <SEGGER_RTT_vprintf+0x1b8>)
    3928:	47b8      	blx	r7
        break;
    392a:	e02d      	b.n	3988 <SEGGER_RTT_vprintf+0x134>
      switch (c) {
    392c:	2958      	cmp	r1, #88	; 0x58
    392e:	d019      	beq.n	3964 <SEGGER_RTT_vprintf+0x110>
    3930:	2963      	cmp	r1, #99	; 0x63
    3932:	d022      	beq.n	397a <SEGGER_RTT_vprintf+0x126>
    3934:	2925      	cmp	r1, #37	; 0x25
    3936:	d127      	bne.n	3988 <SEGGER_RTT_vprintf+0x134>
      case 'p':
        v = va_arg(*pParamList, int);
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
        break;
      case '%':
        _StoreChar(&BufferDesc, '%');
    3938:	2125      	movs	r1, #37	; 0x25
    393a:	a815      	add	r0, sp, #84	; 0x54
    393c:	4b34      	ldr	r3, [pc, #208]	; (3a10 <SEGGER_RTT_vprintf+0x1bc>)
    393e:	4798      	blx	r3
        break;
    3940:	e022      	b.n	3988 <SEGGER_RTT_vprintf+0x134>
      switch (c) {
    3942:	2970      	cmp	r1, #112	; 0x70
    3944:	d120      	bne.n	3988 <SEGGER_RTT_vprintf+0x134>
        v = va_arg(*pParamList, int);
    3946:	682b      	ldr	r3, [r5, #0]
    3948:	1d1a      	adds	r2, r3, #4
    394a:	602a      	str	r2, [r5, #0]
    394c:	6819      	ldr	r1, [r3, #0]
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
    394e:	2300      	movs	r3, #0
    3950:	9301      	str	r3, [sp, #4]
    3952:	3308      	adds	r3, #8
    3954:	9300      	str	r3, [sp, #0]
    3956:	2210      	movs	r2, #16
    3958:	a815      	add	r0, sp, #84	; 0x54
    395a:	4f2c      	ldr	r7, [pc, #176]	; (3a0c <SEGGER_RTT_vprintf+0x1b8>)
    395c:	47b8      	blx	r7
        break;
    395e:	e013      	b.n	3988 <SEGGER_RTT_vprintf+0x134>
      switch (c) {
    3960:	2978      	cmp	r1, #120	; 0x78
    3962:	d111      	bne.n	3988 <SEGGER_RTT_vprintf+0x134>
        v = va_arg(*pParamList, int);
    3964:	6829      	ldr	r1, [r5, #0]
    3966:	1d0f      	adds	r7, r1, #4
    3968:	602f      	str	r7, [r5, #0]
    396a:	6809      	ldr	r1, [r1, #0]
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
    396c:	9001      	str	r0, [sp, #4]
    396e:	9200      	str	r2, [sp, #0]
    3970:	2210      	movs	r2, #16
    3972:	a815      	add	r0, sp, #84	; 0x54
    3974:	4f25      	ldr	r7, [pc, #148]	; (3a0c <SEGGER_RTT_vprintf+0x1b8>)
    3976:	47b8      	blx	r7
        break;
    3978:	e006      	b.n	3988 <SEGGER_RTT_vprintf+0x134>
        v = va_arg(*pParamList, int);
    397a:	682b      	ldr	r3, [r5, #0]
    397c:	1d1a      	adds	r2, r3, #4
    397e:	602a      	str	r2, [r5, #0]
        c0 = (char)v;
    3980:	7819      	ldrb	r1, [r3, #0]
        _StoreChar(&BufferDesc, c0);
    3982:	a815      	add	r0, sp, #84	; 0x54
    3984:	4b22      	ldr	r3, [pc, #136]	; (3a10 <SEGGER_RTT_vprintf+0x1bc>)
    3986:	4798      	blx	r3
      default:
        break;
      }
      sFormat++;
    3988:	3401      	adds	r4, #1
    } else {
      _StoreChar(&BufferDesc, c);
    }
  } while (BufferDesc.ReturnValue >= 0);
    398a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    398c:	2b00      	cmp	r3, #0
    398e:	db24      	blt.n	39da <SEGGER_RTT_vprintf+0x186>
    c = *sFormat;
    3990:	7821      	ldrb	r1, [r4, #0]
    sFormat++;
    3992:	3401      	adds	r4, #1
    if (c == 0u) {
    3994:	2900      	cmp	r1, #0
    3996:	d020      	beq.n	39da <SEGGER_RTT_vprintf+0x186>
    if (c == '%') {
    3998:	2925      	cmp	r1, #37	; 0x25
    399a:	d100      	bne.n	399e <SEGGER_RTT_vprintf+0x14a>
    399c:	e76a      	b.n	3874 <SEGGER_RTT_vprintf+0x20>
      _StoreChar(&BufferDesc, c);
    399e:	a815      	add	r0, sp, #84	; 0x54
    39a0:	4b1b      	ldr	r3, [pc, #108]	; (3a10 <SEGGER_RTT_vprintf+0x1bc>)
    39a2:	4798      	blx	r3
    39a4:	e7f1      	b.n	398a <SEGGER_RTT_vprintf+0x136>
        v = va_arg(*pParamList, int);
    39a6:	6829      	ldr	r1, [r5, #0]
    39a8:	1d0f      	adds	r7, r1, #4
    39aa:	602f      	str	r7, [r5, #0]
    39ac:	6809      	ldr	r1, [r1, #0]
        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
    39ae:	9001      	str	r0, [sp, #4]
    39b0:	9200      	str	r2, [sp, #0]
    39b2:	220a      	movs	r2, #10
    39b4:	a815      	add	r0, sp, #84	; 0x54
    39b6:	4f17      	ldr	r7, [pc, #92]	; (3a14 <SEGGER_RTT_vprintf+0x1c0>)
    39b8:	47b8      	blx	r7
        break;
    39ba:	e7e5      	b.n	3988 <SEGGER_RTT_vprintf+0x134>
          const char * s = va_arg(*pParamList, const char *);
    39bc:	682b      	ldr	r3, [r5, #0]
    39be:	1d1a      	adds	r2, r3, #4
    39c0:	602a      	str	r2, [r5, #0]
    39c2:	681f      	ldr	r7, [r3, #0]
            c = *s;
    39c4:	7839      	ldrb	r1, [r7, #0]
            s++;
    39c6:	3701      	adds	r7, #1
            if (c == '\0') {
    39c8:	2900      	cmp	r1, #0
    39ca:	d0dd      	beq.n	3988 <SEGGER_RTT_vprintf+0x134>
           _StoreChar(&BufferDesc, c);
    39cc:	a815      	add	r0, sp, #84	; 0x54
    39ce:	4b10      	ldr	r3, [pc, #64]	; (3a10 <SEGGER_RTT_vprintf+0x1bc>)
    39d0:	4798      	blx	r3
          } while (BufferDesc.ReturnValue >= 0);
    39d2:	9b18      	ldr	r3, [sp, #96]	; 0x60
    39d4:	2b00      	cmp	r3, #0
    39d6:	daf5      	bge.n	39c4 <SEGGER_RTT_vprintf+0x170>
    39d8:	e7d6      	b.n	3988 <SEGGER_RTT_vprintf+0x134>

  if (BufferDesc.ReturnValue > 0) {
    39da:	9b18      	ldr	r3, [sp, #96]	; 0x60
    39dc:	2b00      	cmp	r3, #0
    39de:	dd0b      	ble.n	39f8 <SEGGER_RTT_vprintf+0x1a4>
    //
    // Write remaining data, if any
    //
    if (BufferDesc.Cnt != 0u) {
    39e0:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    39e2:	2a00      	cmp	r2, #0
    39e4:	d10d      	bne.n	3a02 <SEGGER_RTT_vprintf+0x1ae>
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
    }
    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
    39e6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    39e8:	9302      	str	r3, [sp, #8]
    39ea:	9b18      	ldr	r3, [sp, #96]	; 0x60
    39ec:	9303      	str	r3, [sp, #12]
    39ee:	9b02      	ldr	r3, [sp, #8]
    39f0:	9a03      	ldr	r2, [sp, #12]
    39f2:	4694      	mov	ip, r2
    39f4:	4463      	add	r3, ip
    39f6:	9318      	str	r3, [sp, #96]	; 0x60
  }
  return BufferDesc.ReturnValue;
}
    39f8:	9818      	ldr	r0, [sp, #96]	; 0x60
    39fa:	b01a      	add	sp, #104	; 0x68
    39fc:	bc04      	pop	{r2}
    39fe:	4690      	mov	r8, r2
    3a00:	bdf0      	pop	{r4, r5, r6, r7, pc}
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
    3a02:	a905      	add	r1, sp, #20
    3a04:	4640      	mov	r0, r8
    3a06:	4b04      	ldr	r3, [pc, #16]	; (3a18 <SEGGER_RTT_vprintf+0x1c4>)
    3a08:	4798      	blx	r3
    3a0a:	e7ec      	b.n	39e6 <SEGGER_RTT_vprintf+0x192>
    3a0c:	00003641 	.word	0x00003641
    3a10:	000035fd 	.word	0x000035fd
    3a14:	00003755 	.word	0x00003755
    3a18:	000035c1 	.word	0x000035c1

00003a1c <SEGGER_RTT_printf>:
*          u: Print the argument as an unsigned integer
*          x: Print the argument as an hexadecimal integer
*          s: Print the string pointed to by the argument
*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
*/
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
    3a1c:	b40e      	push	{r1, r2, r3}
    3a1e:	b500      	push	{lr}
    3a20:	b082      	sub	sp, #8
    3a22:	ab03      	add	r3, sp, #12
    3a24:	cb02      	ldmia	r3!, {r1}
  int r;
  va_list ParamList;

  va_start(ParamList, sFormat);
    3a26:	9301      	str	r3, [sp, #4]
  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
    3a28:	aa01      	add	r2, sp, #4
    3a2a:	4b03      	ldr	r3, [pc, #12]	; (3a38 <SEGGER_RTT_printf+0x1c>)
    3a2c:	4798      	blx	r3
  va_end(ParamList);
  return r;
}
    3a2e:	b002      	add	sp, #8
    3a30:	bc08      	pop	{r3}
    3a32:	b003      	add	sp, #12
    3a34:	4718      	bx	r3
    3a36:	46c0      	nop			; (mov r8, r8)
    3a38:	00003855 	.word	0x00003855

00003a3c <__libc_init_array>:
    3a3c:	b570      	push	{r4, r5, r6, lr}
    3a3e:	2600      	movs	r6, #0
    3a40:	4d0c      	ldr	r5, [pc, #48]	; (3a74 <__libc_init_array+0x38>)
    3a42:	4c0d      	ldr	r4, [pc, #52]	; (3a78 <__libc_init_array+0x3c>)
    3a44:	1b64      	subs	r4, r4, r5
    3a46:	10a4      	asrs	r4, r4, #2
    3a48:	42a6      	cmp	r6, r4
    3a4a:	d109      	bne.n	3a60 <__libc_init_array+0x24>
    3a4c:	2600      	movs	r6, #0
    3a4e:	f000 f967 	bl	3d20 <_init>
    3a52:	4d0a      	ldr	r5, [pc, #40]	; (3a7c <__libc_init_array+0x40>)
    3a54:	4c0a      	ldr	r4, [pc, #40]	; (3a80 <__libc_init_array+0x44>)
    3a56:	1b64      	subs	r4, r4, r5
    3a58:	10a4      	asrs	r4, r4, #2
    3a5a:	42a6      	cmp	r6, r4
    3a5c:	d105      	bne.n	3a6a <__libc_init_array+0x2e>
    3a5e:	bd70      	pop	{r4, r5, r6, pc}
    3a60:	00b3      	lsls	r3, r6, #2
    3a62:	58eb      	ldr	r3, [r5, r3]
    3a64:	4798      	blx	r3
    3a66:	3601      	adds	r6, #1
    3a68:	e7ee      	b.n	3a48 <__libc_init_array+0xc>
    3a6a:	00b3      	lsls	r3, r6, #2
    3a6c:	58eb      	ldr	r3, [r5, r3]
    3a6e:	4798      	blx	r3
    3a70:	3601      	adds	r6, #1
    3a72:	e7f2      	b.n	3a5a <__libc_init_array+0x1e>
    3a74:	00003d2c 	.word	0x00003d2c
    3a78:	00003d2c 	.word	0x00003d2c
    3a7c:	00003d2c 	.word	0x00003d2c
    3a80:	00003d30 	.word	0x00003d30

00003a84 <memcpy>:
    3a84:	2300      	movs	r3, #0
    3a86:	b510      	push	{r4, lr}
    3a88:	429a      	cmp	r2, r3
    3a8a:	d100      	bne.n	3a8e <memcpy+0xa>
    3a8c:	bd10      	pop	{r4, pc}
    3a8e:	5ccc      	ldrb	r4, [r1, r3]
    3a90:	54c4      	strb	r4, [r0, r3]
    3a92:	3301      	adds	r3, #1
    3a94:	e7f8      	b.n	3a88 <memcpy+0x4>

00003a96 <memset>:
    3a96:	0003      	movs	r3, r0
    3a98:	1882      	adds	r2, r0, r2
    3a9a:	4293      	cmp	r3, r2
    3a9c:	d100      	bne.n	3aa0 <memset+0xa>
    3a9e:	4770      	bx	lr
    3aa0:	7019      	strb	r1, [r3, #0]
    3aa2:	3301      	adds	r3, #1
    3aa4:	e7f9      	b.n	3a9a <memset+0x4>
    3aa6:	0000      	movs	r0, r0
    3aa8:	63323375 	.word	0x63323375
    3aac:	5f6d6d6f 	.word	0x5f6d6d6f
    3ab0:	20746e63 	.word	0x20746e63
    3ab4:	6425203d 	.word	0x6425203d
    3ab8:	000a0d20 	.word	0x000a0d20
    3abc:	6d6d6f63 	.word	0x6d6d6f63
    3ac0:	00000000 	.word	0x00000000
    3ac4:	682f2e2e 	.word	0x682f2e2e
    3ac8:	692f6c61 	.word	0x692f6c61
    3acc:	756c636e 	.word	0x756c636e
    3ad0:	682f6564 	.word	0x682f6564
    3ad4:	775f6c61 	.word	0x775f6c61
    3ad8:	682e7464 	.word	0x682e7464
    3adc:	00000000 	.word	0x00000000
    3ae0:	314e4143 	.word	0x314e4143
    3ae4:	74616420 	.word	0x74616420
    3ae8:	203d2061 	.word	0x203d2061
    3aec:	78323025 	.word	0x78323025
    3af0:	000a0d20 	.word	0x000a0d20
    3af4:	206e656c 	.word	0x206e656c
    3af8:	6425203d 	.word	0x6425203d
    3afc:	000a0d20 	.word	0x000a0d20
    3b00:	454c4449 	.word	0x454c4449
    3b04:	00000000 	.word	0x00000000
    3b08:	09632509 	.word	0x09632509
    3b0c:	25097525 	.word	0x25097525
    3b10:	75250975 	.word	0x75250975
    3b14:	00000a0d 	.word	0x00000a0d
    3b18:	00001e64 	.word	0x00001e64
    3b1c:	00001e64 	.word	0x00001e64
    3b20:	00001e64 	.word	0x00001e64
    3b24:	00001eb2 	.word	0x00001eb2
    3b28:	00001ebe 	.word	0x00001ebe
    3b2c:	00001ee2 	.word	0x00001ee2
    3b30:	00001e64 	.word	0x00001e64
    3b34:	00001e64 	.word	0x00001e64
    3b38:	00001eb2 	.word	0x00001eb2
    3b3c:	00001ebe 	.word	0x00001ebe
    3b40:	51726d54 	.word	0x51726d54
    3b44:	00000000 	.word	0x00000000
    3b48:	20726d54 	.word	0x20726d54
    3b4c:	00637653 	.word	0x00637653
    3b50:	682f2e2e 	.word	0x682f2e2e
    3b54:	732f6c61 	.word	0x732f6c61
    3b58:	682f6372 	.word	0x682f6372
    3b5c:	635f6c61 	.word	0x635f6c61
    3b60:	615f6e61 	.word	0x615f6e61
    3b64:	636e7973 	.word	0x636e7973
    3b68:	0000632e 	.word	0x0000632e
    3b6c:	682f2e2e 	.word	0x682f2e2e
    3b70:	732f6c61 	.word	0x732f6c61
    3b74:	682f6372 	.word	0x682f6372
    3b78:	665f6c61 	.word	0x665f6c61
    3b7c:	6873616c 	.word	0x6873616c
    3b80:	0000632e 	.word	0x0000632e
    3b84:	682f2e2e 	.word	0x682f2e2e
    3b88:	732f6c61 	.word	0x732f6c61
    3b8c:	682f6372 	.word	0x682f6372
    3b90:	735f6c61 	.word	0x735f6c61
    3b94:	6d5f6970 	.word	0x6d5f6970
    3b98:	6e79735f 	.word	0x6e79735f
    3b9c:	00632e63 	.word	0x00632e63
    3ba0:	682f2e2e 	.word	0x682f2e2e
    3ba4:	732f6c61 	.word	0x732f6c61
    3ba8:	682f6372 	.word	0x682f6372
    3bac:	745f6c61 	.word	0x745f6c61
    3bb0:	72656d69 	.word	0x72656d69
    3bb4:	0000632e 	.word	0x0000632e
    3bb8:	682f2e2e 	.word	0x682f2e2e
    3bbc:	752f6c61 	.word	0x752f6c61
    3bc0:	736c6974 	.word	0x736c6974
    3bc4:	6372732f 	.word	0x6372732f
    3bc8:	6974752f 	.word	0x6974752f
    3bcc:	6c5f736c 	.word	0x6c5f736c
    3bd0:	2e747369 	.word	0x2e747369
    3bd4:	00000063 	.word	0x00000063
    3bd8:	03020100 	.word	0x03020100
    3bdc:	07060504 	.word	0x07060504
    3be0:	14100c08 	.word	0x14100c08
    3be4:	40302018 	.word	0x40302018
    3be8:	682f2e2e 	.word	0x682f2e2e
    3bec:	6e2f6c70 	.word	0x6e2f6c70
    3bf0:	74636d76 	.word	0x74636d76
    3bf4:	682f6c72 	.word	0x682f6c72
    3bf8:	6e5f6c70 	.word	0x6e5f6c70
    3bfc:	74636d76 	.word	0x74636d76
    3c00:	632e6c72 	.word	0x632e6c72
    3c04:	00000000 	.word	0x00000000

00003c08 <_usarts>:
	...

00003c1c <_i2cms>:
	...

00003c34 <_i2css>:
	...

00003c44 <sercomspi_regs>:
    3c44:	0001000c 00020000 00000000 01ff0027     ............'...
    3c54:	00000001 682f2e2e 732f6c70 6f637265     ....../hpl/serco
    3c64:	70682f6d 65735f6c 6d6f6372 0000632e     m/hpl_sercom.c..

00003c74 <_tcs>:
    3c74:	00001400 00000308 00000000 000001f4     ................
    3c84:	00000000 00001501 00000308 00000000     ................
    3c94:	000001f4 00000000 682f2e2e 742f6c70     ........../hpl/t
    3ca4:	70682f63 63745f6c 0000632e 682f2e2e     c/hpl_tc.c..../h
    3cb4:	772f6c70 682f7464 775f6c70 632e7464     pl/wdt/hpl_wdt.c
    3cc4:	00000000 61323375 635f6566 3d20746e     ....u32afe_cnt =
    3cd4:	20642520 00000a0d 00454641               %d ....AFE.

00003ce0 <_aTerminalId>:
    3ce0:	33323130 37363534 42413938 46454443     0123456789ABCDEF

00003cf0 <_aInitStr.5072>:
    3cf0:	00000000 54540000 45522052 53454747     ......TTR REGGES
    3d00:	00000000 6d726554 6c616e69 00000000     ....Terminal....

00003d10 <_aV2C.4903>:
    3d10:	33323130 37363534 42413938 46454443     0123456789ABCDEF

00003d20 <_init>:
    3d20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3d22:	46c0      	nop			; (mov r8, r8)
    3d24:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3d26:	bc08      	pop	{r3}
    3d28:	469e      	mov	lr, r3
    3d2a:	4770      	bx	lr

00003d2c <__init_array_start>:
    3d2c:	000000e5 	.word	0x000000e5

00003d30 <_fini>:
    3d30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3d32:	46c0      	nop			; (mov r8, r8)
    3d34:	bcf8      	pop	{r3, r4, r5, r6, r7}
    3d36:	bc08      	pop	{r3}
    3d38:	469e      	mov	lr, r3
    3d3a:	4770      	bx	lr

00003d3c <__fini_array_start>:
    3d3c:	000000bd 	.word	0x000000bd
