
FreeRtos_Motor.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000023e0  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000028  20000000  000023e0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000d44  20000028  00002408  00020028  2**2
                  ALLOC
  3 .stack        00002004  20000d6c  0000314c  00020028  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020028  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020050  2**0
                  CONTENTS, READONLY
  6 .debug_info   0002f787  00000000  00000000  000200a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000428d  00000000  00000000  0004f830  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00015624  00000000  00000000  00053abd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001028  00000000  00000000  000690e1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000013d0  00000000  00000000  0006a109  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001ed8b  00000000  00000000  0006b4d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001491e  00000000  00000000  0008a264  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a2f75  00000000  00000000  0009eb82  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00002c2c  00000000  00000000  00141af8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	70 2d 00 20 2d 01 00 00 29 01 00 00 29 01 00 00     p-. -...)...)...
	...
      2c:	29 01 00 00 00 00 00 00 00 00 00 00 51 06 00 00     )...........Q...
      3c:	95 06 00 00 29 01 00 00 29 01 00 00 29 01 00 00     ....)...)...)...
      4c:	29 01 00 00 29 01 00 00 29 01 00 00 79 14 00 00     )...)...)...y...
      5c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      6c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      7c:	11 12 00 00 81 12 00 00 29 01 00 00 29 01 00 00     ........)...)...
      8c:	29 01 00 00 7d 1a 00 00 91 1a 00 00 29 01 00 00     )...}.......)...
      9c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
      ac:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...

000000bc <__do_global_dtors_aux>:
      bc:	b510      	push	{r4, lr}
      be:	4c06      	ldr	r4, [pc, #24]	; (d8 <__do_global_dtors_aux+0x1c>)
      c0:	7823      	ldrb	r3, [r4, #0]
      c2:	2b00      	cmp	r3, #0
      c4:	d107      	bne.n	d6 <__do_global_dtors_aux+0x1a>
      c6:	4b05      	ldr	r3, [pc, #20]	; (dc <__do_global_dtors_aux+0x20>)
      c8:	2b00      	cmp	r3, #0
      ca:	d002      	beq.n	d2 <__do_global_dtors_aux+0x16>
      cc:	4804      	ldr	r0, [pc, #16]	; (e0 <__do_global_dtors_aux+0x24>)
      ce:	e000      	b.n	d2 <__do_global_dtors_aux+0x16>
      d0:	bf00      	nop
      d2:	2301      	movs	r3, #1
      d4:	7023      	strb	r3, [r4, #0]
      d6:	bd10      	pop	{r4, pc}
      d8:	20000028 	.word	0x20000028
      dc:	00000000 	.word	0x00000000
      e0:	000023e0 	.word	0x000023e0

000000e4 <frame_dummy>:
      e4:	4b08      	ldr	r3, [pc, #32]	; (108 <frame_dummy+0x24>)
      e6:	b510      	push	{r4, lr}
      e8:	2b00      	cmp	r3, #0
      ea:	d003      	beq.n	f4 <frame_dummy+0x10>
      ec:	4907      	ldr	r1, [pc, #28]	; (10c <frame_dummy+0x28>)
      ee:	4808      	ldr	r0, [pc, #32]	; (110 <frame_dummy+0x2c>)
      f0:	e000      	b.n	f4 <frame_dummy+0x10>
      f2:	bf00      	nop
      f4:	4807      	ldr	r0, [pc, #28]	; (114 <frame_dummy+0x30>)
      f6:	6803      	ldr	r3, [r0, #0]
      f8:	2b00      	cmp	r3, #0
      fa:	d100      	bne.n	fe <frame_dummy+0x1a>
      fc:	bd10      	pop	{r4, pc}
      fe:	4b06      	ldr	r3, [pc, #24]	; (118 <frame_dummy+0x34>)
     100:	2b00      	cmp	r3, #0
     102:	d0fb      	beq.n	fc <frame_dummy+0x18>
     104:	4798      	blx	r3
     106:	e7f9      	b.n	fc <frame_dummy+0x18>
     108:	00000000 	.word	0x00000000
     10c:	2000002c 	.word	0x2000002c
     110:	000023e0 	.word	0x000023e0
     114:	000023e0 	.word	0x000023e0
     118:	00000000 	.word	0x00000000

0000011c <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     11c:	b510      	push	{r4, lr}
	system_init();
     11e:	4b01      	ldr	r3, [pc, #4]	; (124 <atmel_start_init+0x8>)
     120:	4798      	blx	r3
}
     122:	bd10      	pop	{r4, pc}
     124:	0000048d 	.word	0x0000048d

00000128 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     128:	e7fe      	b.n	128 <Dummy_Handler>
	...

0000012c <Reset_Handler>:
{
     12c:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
     12e:	4a10      	ldr	r2, [pc, #64]	; (170 <Reset_Handler+0x44>)
     130:	4b10      	ldr	r3, [pc, #64]	; (174 <Reset_Handler+0x48>)
     132:	429a      	cmp	r2, r3
     134:	d009      	beq.n	14a <Reset_Handler+0x1e>
     136:	4b0f      	ldr	r3, [pc, #60]	; (174 <Reset_Handler+0x48>)
     138:	4a0d      	ldr	r2, [pc, #52]	; (170 <Reset_Handler+0x44>)
     13a:	e003      	b.n	144 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
     13c:	6811      	ldr	r1, [r2, #0]
     13e:	6019      	str	r1, [r3, #0]
     140:	3304      	adds	r3, #4
     142:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     144:	490c      	ldr	r1, [pc, #48]	; (178 <Reset_Handler+0x4c>)
     146:	428b      	cmp	r3, r1
     148:	d3f8      	bcc.n	13c <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
     14a:	4b0c      	ldr	r3, [pc, #48]	; (17c <Reset_Handler+0x50>)
     14c:	e002      	b.n	154 <Reset_Handler+0x28>
                *pDest++ = 0;
     14e:	2200      	movs	r2, #0
     150:	601a      	str	r2, [r3, #0]
     152:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
     154:	4a0a      	ldr	r2, [pc, #40]	; (180 <Reset_Handler+0x54>)
     156:	4293      	cmp	r3, r2
     158:	d3f9      	bcc.n	14e <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     15a:	4a0a      	ldr	r2, [pc, #40]	; (184 <Reset_Handler+0x58>)
     15c:	21ff      	movs	r1, #255	; 0xff
     15e:	4b0a      	ldr	r3, [pc, #40]	; (188 <Reset_Handler+0x5c>)
     160:	438b      	bics	r3, r1
     162:	6093      	str	r3, [r2, #8]
        __libc_init_array();
     164:	4b09      	ldr	r3, [pc, #36]	; (18c <Reset_Handler+0x60>)
     166:	4798      	blx	r3
        main();
     168:	4b09      	ldr	r3, [pc, #36]	; (190 <Reset_Handler+0x64>)
     16a:	4798      	blx	r3
     16c:	e7fe      	b.n	16c <Reset_Handler+0x40>
     16e:	46c0      	nop			; (mov r8, r8)
     170:	000023e0 	.word	0x000023e0
     174:	20000000 	.word	0x20000000
     178:	20000028 	.word	0x20000028
     17c:	20000028 	.word	0x20000028
     180:	20000d6c 	.word	0x20000d6c
     184:	e000ed00 	.word	0xe000ed00
     188:	00000000 	.word	0x00000000
     18c:	00002175 	.word	0x00002175
     190:	00001b15 	.word	0x00001b15

00000194 <TIMER_0_init>:
 * \brief Timer initialization function
 *
 * Enables Timer peripheral, clocks and initializes Timer driver
 */
static void TIMER_0_init(void)
{
     194:	b510      	push	{r4, lr}
}

static inline void hri_mclk_set_APBCMASK_TC0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TC0;
     196:	4a09      	ldr	r2, [pc, #36]	; (1bc <TIMER_0_init+0x28>)
     198:	69d1      	ldr	r1, [r2, #28]
     19a:	2380      	movs	r3, #128	; 0x80
     19c:	015b      	lsls	r3, r3, #5
     19e:	430b      	orrs	r3, r1
     1a0:	61d3      	str	r3, [r2, #28]
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     1a2:	2140      	movs	r1, #64	; 0x40
     1a4:	23f8      	movs	r3, #248	; 0xf8
     1a6:	4a06      	ldr	r2, [pc, #24]	; (1c0 <TIMER_0_init+0x2c>)
     1a8:	50d1      	str	r1, [r2, r3]
	hri_mclk_set_APBCMASK_TC0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, TC0_GCLK_ID, CONF_GCLK_TC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	timer_init(&TIMER_0, TC0, _tc_get_timer());
     1aa:	4b06      	ldr	r3, [pc, #24]	; (1c4 <TIMER_0_init+0x30>)
     1ac:	4798      	blx	r3
     1ae:	0002      	movs	r2, r0
     1b0:	4905      	ldr	r1, [pc, #20]	; (1c8 <TIMER_0_init+0x34>)
     1b2:	4806      	ldr	r0, [pc, #24]	; (1cc <TIMER_0_init+0x38>)
     1b4:	4b06      	ldr	r3, [pc, #24]	; (1d0 <TIMER_0_init+0x3c>)
     1b6:	4798      	blx	r3
}
     1b8:	bd10      	pop	{r4, pc}
     1ba:	46c0      	nop			; (mov r8, r8)
     1bc:	40000800 	.word	0x40000800
     1c0:	40001c00 	.word	0x40001c00
     1c4:	00001a79 	.word	0x00001a79
     1c8:	42003000 	.word	0x42003000
     1cc:	200006e8 	.word	0x200006e8
     1d0:	00000c3d 	.word	0x00000c3d

000001d4 <TIMER_1_init>:
 * \brief Timer initialization function
 *
 * Enables Timer peripheral, clocks and initializes Timer driver
 */
static void TIMER_1_init(void)
{
     1d4:	b510      	push	{r4, lr}
}

static inline void hri_mclk_set_APBCMASK_TC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TC1;
     1d6:	4a09      	ldr	r2, [pc, #36]	; (1fc <TIMER_1_init+0x28>)
     1d8:	69d1      	ldr	r1, [r2, #28]
     1da:	2380      	movs	r3, #128	; 0x80
     1dc:	019b      	lsls	r3, r3, #6
     1de:	430b      	orrs	r3, r1
     1e0:	61d3      	str	r3, [r2, #28]
     1e2:	2140      	movs	r1, #64	; 0x40
     1e4:	23f8      	movs	r3, #248	; 0xf8
     1e6:	4a06      	ldr	r2, [pc, #24]	; (200 <TIMER_1_init+0x2c>)
     1e8:	50d1      	str	r1, [r2, r3]
	hri_mclk_set_APBCMASK_TC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, TC1_GCLK_ID, CONF_GCLK_TC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	timer_init(&TIMER_1, TC1, _tc_get_timer());
     1ea:	4b06      	ldr	r3, [pc, #24]	; (204 <TIMER_1_init+0x30>)
     1ec:	4798      	blx	r3
     1ee:	0002      	movs	r2, r0
     1f0:	4905      	ldr	r1, [pc, #20]	; (208 <TIMER_1_init+0x34>)
     1f2:	4806      	ldr	r0, [pc, #24]	; (20c <TIMER_1_init+0x38>)
     1f4:	4b06      	ldr	r3, [pc, #24]	; (210 <TIMER_1_init+0x3c>)
     1f6:	4798      	blx	r3
}
     1f8:	bd10      	pop	{r4, pc}
     1fa:	46c0      	nop			; (mov r8, r8)
     1fc:	40000800 	.word	0x40000800
     200:	40001c00 	.word	0x40001c00
     204:	00001a79 	.word	0x00001a79
     208:	42003400 	.word	0x42003400
     20c:	200006b4 	.word	0x200006b4
     210:	00000c3d 	.word	0x00000c3d

00000214 <FLASH_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_NVMCTRL;
     214:	4a02      	ldr	r2, [pc, #8]	; (220 <FLASH_0_CLOCK_init+0xc>)
     216:	6913      	ldr	r3, [r2, #16]
     218:	2120      	movs	r1, #32
     21a:	430b      	orrs	r3, r1
     21c:	6113      	str	r3, [r2, #16]
}
     21e:	4770      	bx	lr
     220:	40000800 	.word	0x40000800

00000224 <FLASH_0_init>:
{
     224:	b510      	push	{r4, lr}
	FLASH_0_CLOCK_init();
     226:	4b03      	ldr	r3, [pc, #12]	; (234 <FLASH_0_init+0x10>)
     228:	4798      	blx	r3
	flash_init(&FLASH_0, NVMCTRL);
     22a:	4903      	ldr	r1, [pc, #12]	; (238 <FLASH_0_init+0x14>)
     22c:	4803      	ldr	r0, [pc, #12]	; (23c <FLASH_0_init+0x18>)
     22e:	4b04      	ldr	r3, [pc, #16]	; (240 <FLASH_0_init+0x1c>)
     230:	4798      	blx	r3
}
     232:	bd10      	pop	{r4, pc}
     234:	00000215 	.word	0x00000215
     238:	41004000 	.word	0x41004000
     23c:	2000066c 	.word	0x2000066c
     240:	00000a1d 	.word	0x00000a1d

00000244 <SPI_0_PORT_init>:
{
     244:	b5f0      	push	{r4, r5, r6, r7, lr}
     246:	46c6      	mov	lr, r8
     248:	b500      	push	{lr}
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     24a:	24c0      	movs	r4, #192	; 0xc0
     24c:	05e4      	lsls	r4, r4, #23
     24e:	2380      	movs	r3, #128	; 0x80
     250:	025b      	lsls	r3, r3, #9
     252:	6063      	str	r3, [r4, #4]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     254:	2382      	movs	r3, #130	; 0x82
     256:	05db      	lsls	r3, r3, #23
     258:	4a23      	ldr	r2, [pc, #140]	; (2e8 <SPI_0_PORT_init+0xa4>)
     25a:	629a      	str	r2, [r3, #40]	; 0x28
     25c:	4a23      	ldr	r2, [pc, #140]	; (2ec <SPI_0_PORT_init+0xa8>)
     25e:	629a      	str	r2, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     260:	2150      	movs	r1, #80	; 0x50
     262:	5c5a      	ldrb	r2, [r3, r1]
     264:	2004      	movs	r0, #4
     266:	4382      	bics	r2, r0
     268:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     26a:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     26c:	2601      	movs	r6, #1
     26e:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     270:	2501      	movs	r5, #1
     272:	432a      	orrs	r2, r5
     274:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     276:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     278:	3918      	subs	r1, #24
     27a:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     27c:	300b      	adds	r0, #11
     27e:	4684      	mov	ip, r0
     280:	4382      	bics	r2, r0
	tmp |= PORT_PMUX_PMUXE(data);
     282:	2702      	movs	r7, #2
     284:	433a      	orrs	r2, r7
     286:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     288:	545a      	strb	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     28a:	2280      	movs	r2, #128	; 0x80
     28c:	02d2      	lsls	r2, r2, #11
     28e:	6162      	str	r2, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     290:	60a2      	str	r2, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     292:	2280      	movs	r2, #128	; 0x80
     294:	05d2      	lsls	r2, r2, #23
     296:	4690      	mov	r8, r2
     298:	629a      	str	r2, [r3, #40]	; 0x28
     29a:	4915      	ldr	r1, [pc, #84]	; (2f0 <SPI_0_PORT_init+0xac>)
     29c:	6299      	str	r1, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     29e:	2152      	movs	r1, #82	; 0x52
     2a0:	5c58      	ldrb	r0, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     2a2:	43b0      	bics	r0, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     2a4:	4328      	orrs	r0, r5
     2a6:	b2c0      	uxtb	r0, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     2a8:	5458      	strb	r0, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     2aa:	2039      	movs	r0, #57	; 0x39
     2ac:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     2ae:	4662      	mov	r2, ip
     2b0:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     2b2:	4339      	orrs	r1, r7
     2b4:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     2b6:	5419      	strb	r1, [r3, r0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     2b8:	2180      	movs	r1, #128	; 0x80
     2ba:	0309      	lsls	r1, r1, #12
     2bc:	6161      	str	r1, [r4, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     2be:	60a1      	str	r1, [r4, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     2c0:	4642      	mov	r2, r8
     2c2:	629a      	str	r2, [r3, #40]	; 0x28
     2c4:	4a0b      	ldr	r2, [pc, #44]	; (2f4 <SPI_0_PORT_init+0xb0>)
     2c6:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     2c8:	2153      	movs	r1, #83	; 0x53
     2ca:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     2cc:	43b2      	bics	r2, r6
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     2ce:	432a      	orrs	r2, r5
     2d0:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     2d2:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     2d4:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     2d6:	3944      	subs	r1, #68	; 0x44
     2d8:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     2da:	2120      	movs	r1, #32
     2dc:	430a      	orrs	r2, r1
     2de:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     2e0:	541a      	strb	r2, [r3, r0]
}
     2e2:	bc04      	pop	{r2}
     2e4:	4690      	mov	r8, r2
     2e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     2e8:	40020000 	.word	0x40020000
     2ec:	c0020001 	.word	0xc0020001
     2f0:	c0000004 	.word	0xc0000004
     2f4:	c0000008 	.word	0xc0000008

000002f8 <SPI_0_CLOCK_init>:
     2f8:	4b06      	ldr	r3, [pc, #24]	; (314 <SPI_0_CLOCK_init+0x1c>)
     2fa:	2140      	movs	r1, #64	; 0x40
     2fc:	22d0      	movs	r2, #208	; 0xd0
     2fe:	5099      	str	r1, [r3, r2]
     300:	3103      	adds	r1, #3
     302:	3a08      	subs	r2, #8
     304:	5099      	str	r1, [r3, r2]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM1;
     306:	4a04      	ldr	r2, [pc, #16]	; (318 <SPI_0_CLOCK_init+0x20>)
     308:	69d3      	ldr	r3, [r2, #28]
     30a:	393f      	subs	r1, #63	; 0x3f
     30c:	430b      	orrs	r3, r1
     30e:	61d3      	str	r3, [r2, #28]
}
     310:	4770      	bx	lr
     312:	46c0      	nop			; (mov r8, r8)
     314:	40001c00 	.word	0x40001c00
     318:	40000800 	.word	0x40000800

0000031c <SPI_0_init>:
{
     31c:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
     31e:	4b04      	ldr	r3, [pc, #16]	; (330 <SPI_0_init+0x14>)
     320:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SERCOM1);
     322:	4904      	ldr	r1, [pc, #16]	; (334 <SPI_0_init+0x18>)
     324:	4804      	ldr	r0, [pc, #16]	; (338 <SPI_0_init+0x1c>)
     326:	4b05      	ldr	r3, [pc, #20]	; (33c <SPI_0_init+0x20>)
     328:	4798      	blx	r3
	SPI_0_PORT_init();
     32a:	4b05      	ldr	r3, [pc, #20]	; (340 <SPI_0_init+0x24>)
     32c:	4798      	blx	r3
}
     32e:	bd10      	pop	{r4, pc}
     330:	000002f9 	.word	0x000002f9
     334:	42000800 	.word	0x42000800
     338:	200006d0 	.word	0x200006d0
     33c:	00000a69 	.word	0x00000a69
     340:	00000245 	.word	0x00000245

00000344 <WDT_0_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_WDT;
     344:	4a03      	ldr	r2, [pc, #12]	; (354 <WDT_0_CLOCK_init+0x10>)
     346:	6951      	ldr	r1, [r2, #20]
     348:	2380      	movs	r3, #128	; 0x80
     34a:	005b      	lsls	r3, r3, #1
     34c:	430b      	orrs	r3, r1
     34e:	6153      	str	r3, [r2, #20]

void WDT_0_CLOCK_init(void)
{
	hri_mclk_set_APBAMASK_WDT_bit(MCLK);
}
     350:	4770      	bx	lr
     352:	46c0      	nop			; (mov r8, r8)
     354:	40000800 	.word	0x40000800

00000358 <WDT_0_init>:

void WDT_0_init(void)
{
     358:	b510      	push	{r4, lr}
	WDT_0_CLOCK_init();
     35a:	4b06      	ldr	r3, [pc, #24]	; (374 <WDT_0_init+0x1c>)
     35c:	4798      	blx	r3
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
	ASSERT(wdt && hw);
     35e:	2248      	movs	r2, #72	; 0x48
     360:	4905      	ldr	r1, [pc, #20]	; (378 <WDT_0_init+0x20>)
     362:	2001      	movs	r0, #1
     364:	4b05      	ldr	r3, [pc, #20]	; (37c <WDT_0_init+0x24>)
     366:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
     368:	4805      	ldr	r0, [pc, #20]	; (380 <WDT_0_init+0x28>)
     36a:	4b06      	ldr	r3, [pc, #24]	; (384 <WDT_0_init+0x2c>)
     36c:	6003      	str	r3, [r0, #0]

	return _wdt_init(&wdt->dev);
     36e:	4b06      	ldr	r3, [pc, #24]	; (388 <WDT_0_init+0x30>)
     370:	4798      	blx	r3
	wdt_init(&WDT_0, WDT);
}
     372:	bd10      	pop	{r4, pc}
     374:	00000345 	.word	0x00000345
     378:	000021e0 	.word	0x000021e0
     37c:	00000c81 	.word	0x00000c81
     380:	200006b0 	.word	0x200006b0
     384:	40002000 	.word	0x40002000
     388:	00001aa5 	.word	0x00001aa5

0000038c <CAN_1_PORT_init>:

void CAN_1_PORT_init(void)
{
     38c:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     38e:	2382      	movs	r3, #130	; 0x82
     390:	05db      	lsls	r3, r3, #23
     392:	2259      	movs	r2, #89	; 0x59
     394:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     396:	2501      	movs	r5, #1
     398:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     39a:	2401      	movs	r4, #1
     39c:	4321      	orrs	r1, r4
     39e:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3a0:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3a2:	203c      	movs	r0, #60	; 0x3c
     3a4:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     3a6:	3a4a      	subs	r2, #74	; 0x4a
     3a8:	4011      	ands	r1, r2
	tmp |= PORT_PMUX_PMUXO(data);
     3aa:	2260      	movs	r2, #96	; 0x60
     3ac:	4311      	orrs	r1, r2
     3ae:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3b0:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     3b2:	2158      	movs	r1, #88	; 0x58
     3b4:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     3b6:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     3b8:	4322      	orrs	r2, r4
     3ba:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     3bc:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     3be:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     3c0:	3949      	subs	r1, #73	; 0x49
     3c2:	438a      	bics	r2, r1
	tmp |= PORT_PMUX_PMUXE(data);
     3c4:	2106      	movs	r1, #6
     3c6:	430a      	orrs	r2, r1
     3c8:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     3ca:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PA25, PINMUX_PA25G_CAN0_RX);

	gpio_set_pin_function(PA24, PINMUX_PA24G_CAN0_TX);
}
     3cc:	bd30      	pop	{r4, r5, pc}
	...

000003d0 <CAN_1_init>:
 * \brief CAN initialization function
 *
 * Enables CAN peripheral, clocks and initializes CAN driver
 */
void CAN_1_init(void)
{
     3d0:	b510      	push	{r4, lr}
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_CAN0;
     3d2:	4a08      	ldr	r2, [pc, #32]	; (3f4 <CAN_1_init+0x24>)
     3d4:	6911      	ldr	r1, [r2, #16]
     3d6:	2380      	movs	r3, #128	; 0x80
     3d8:	005b      	lsls	r3, r3, #1
     3da:	430b      	orrs	r3, r1
     3dc:	6113      	str	r3, [r2, #16]
     3de:	2140      	movs	r1, #64	; 0x40
     3e0:	23e8      	movs	r3, #232	; 0xe8
     3e2:	4a05      	ldr	r2, [pc, #20]	; (3f8 <CAN_1_init+0x28>)
     3e4:	50d1      	str	r1, [r2, r3]
	hri_mclk_set_AHBMASK_CAN0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, CAN0_GCLK_ID, CONF_GCLK_CAN0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	can_async_init(&CAN_1, CAN0);
     3e6:	4905      	ldr	r1, [pc, #20]	; (3fc <CAN_1_init+0x2c>)
     3e8:	4805      	ldr	r0, [pc, #20]	; (400 <CAN_1_init+0x30>)
     3ea:	4b06      	ldr	r3, [pc, #24]	; (404 <CAN_1_init+0x34>)
     3ec:	4798      	blx	r3
	CAN_1_PORT_init();
     3ee:	4b06      	ldr	r3, [pc, #24]	; (408 <CAN_1_init+0x38>)
     3f0:	4798      	blx	r3
}
     3f2:	bd10      	pop	{r4, pc}
     3f4:	40000800 	.word	0x40000800
     3f8:	40001c00 	.word	0x40001c00
     3fc:	42001c00 	.word	0x42001c00
     400:	20000688 	.word	0x20000688
     404:	00000895 	.word	0x00000895
     408:	0000038d 	.word	0x0000038d

0000040c <CAN_0_PORT_init>:

void CAN_0_PORT_init(void)
{
     40c:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     40e:	2382      	movs	r3, #130	; 0x82
     410:	05db      	lsls	r3, r3, #23
     412:	22cb      	movs	r2, #203	; 0xcb
     414:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     416:	2501      	movs	r5, #1
     418:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     41a:	2401      	movs	r4, #1
     41c:	4321      	orrs	r1, r4
     41e:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     420:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     422:	20b5      	movs	r0, #181	; 0xb5
     424:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     426:	3abc      	subs	r2, #188	; 0xbc
     428:	4011      	ands	r1, r2
	tmp |= PORT_PMUX_PMUXO(data);
     42a:	2260      	movs	r2, #96	; 0x60
     42c:	4311      	orrs	r1, r2
     42e:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     430:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     432:	21ca      	movs	r1, #202	; 0xca
     434:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     436:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     438:	4322      	orrs	r2, r4
     43a:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     43c:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     43e:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     440:	39bb      	subs	r1, #187	; 0xbb
     442:	438a      	bics	r2, r1
	tmp |= PORT_PMUX_PMUXE(data);
     444:	2106      	movs	r1, #6
     446:	430a      	orrs	r2, r1
     448:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     44a:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PB11, PINMUX_PB11G_CAN1_RX);

	gpio_set_pin_function(PB10, PINMUX_PB10G_CAN1_TX);
}
     44c:	bd30      	pop	{r4, r5, pc}
	...

00000450 <CAN_0_init>:
 * \brief CAN initialization function
 *
 * Enables CAN peripheral, clocks and initializes CAN driver
 */
void CAN_0_init(void)
{
     450:	b510      	push	{r4, lr}
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_CAN1;
     452:	4a08      	ldr	r2, [pc, #32]	; (474 <CAN_0_init+0x24>)
     454:	6911      	ldr	r1, [r2, #16]
     456:	2380      	movs	r3, #128	; 0x80
     458:	009b      	lsls	r3, r3, #2
     45a:	430b      	orrs	r3, r1
     45c:	6113      	str	r3, [r2, #16]
     45e:	2140      	movs	r1, #64	; 0x40
     460:	23ec      	movs	r3, #236	; 0xec
     462:	4a05      	ldr	r2, [pc, #20]	; (478 <CAN_0_init+0x28>)
     464:	50d1      	str	r1, [r2, r3]
	hri_mclk_set_AHBMASK_CAN1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, CAN1_GCLK_ID, CONF_GCLK_CAN1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	can_async_init(&CAN_0, CAN1);
     466:	4905      	ldr	r1, [pc, #20]	; (47c <CAN_0_init+0x2c>)
     468:	4805      	ldr	r0, [pc, #20]	; (480 <CAN_0_init+0x30>)
     46a:	4b06      	ldr	r3, [pc, #24]	; (484 <CAN_0_init+0x34>)
     46c:	4798      	blx	r3
	CAN_0_PORT_init();
     46e:	4b06      	ldr	r3, [pc, #24]	; (488 <CAN_0_init+0x38>)
     470:	4798      	blx	r3
}
     472:	bd10      	pop	{r4, pc}
     474:	40000800 	.word	0x40000800
     478:	40001c00 	.word	0x40001c00
     47c:	42002000 	.word	0x42002000
     480:	20000644 	.word	0x20000644
     484:	00000895 	.word	0x00000895
     488:	0000040d 	.word	0x0000040d

0000048c <system_init>:

void system_init(void)
{
     48c:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     48e:	4b13      	ldr	r3, [pc, #76]	; (4dc <system_init+0x50>)
     490:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     492:	23c0      	movs	r3, #192	; 0xc0
     494:	05db      	lsls	r3, r3, #23
     496:	2280      	movs	r2, #128	; 0x80
     498:	0212      	lsls	r2, r2, #8
     49a:	2198      	movs	r1, #152	; 0x98
     49c:	505a      	str	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     49e:	3910      	subs	r1, #16
     4a0:	505a      	str	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     4a2:	2382      	movs	r3, #130	; 0x82
     4a4:	05db      	lsls	r3, r3, #23
     4a6:	22a8      	movs	r2, #168	; 0xa8
     4a8:	490d      	ldr	r1, [pc, #52]	; (4e0 <system_init+0x54>)
     4aa:	5099      	str	r1, [r3, r2]
     4ac:	21c0      	movs	r1, #192	; 0xc0
     4ae:	0609      	lsls	r1, r1, #24
     4b0:	5099      	str	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     4b2:	21cf      	movs	r1, #207	; 0xcf
     4b4:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     4b6:	2001      	movs	r0, #1
     4b8:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     4ba:	545a      	strb	r2, [r3, r1]
	// Set pin direction to output
	gpio_set_pin_direction(LED_PIN, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED_PIN, GPIO_PIN_FUNCTION_OFF);

	FLASH_0_init();
     4bc:	4b09      	ldr	r3, [pc, #36]	; (4e4 <system_init+0x58>)
     4be:	4798      	blx	r3

	SPI_0_init();
     4c0:	4b09      	ldr	r3, [pc, #36]	; (4e8 <system_init+0x5c>)
     4c2:	4798      	blx	r3

	TIMER_0_init();
     4c4:	4b09      	ldr	r3, [pc, #36]	; (4ec <system_init+0x60>)
     4c6:	4798      	blx	r3
	TIMER_1_init();
     4c8:	4b09      	ldr	r3, [pc, #36]	; (4f0 <system_init+0x64>)
     4ca:	4798      	blx	r3
	WDT_0_init();
     4cc:	4b09      	ldr	r3, [pc, #36]	; (4f4 <system_init+0x68>)
     4ce:	4798      	blx	r3
	CAN_1_init();
     4d0:	4b09      	ldr	r3, [pc, #36]	; (4f8 <system_init+0x6c>)
     4d2:	4798      	blx	r3
	CAN_0_init();
     4d4:	4b09      	ldr	r3, [pc, #36]	; (4fc <system_init+0x70>)
     4d6:	4798      	blx	r3
}
     4d8:	bd10      	pop	{r4, pc}
     4da:	46c0      	nop			; (mov r8, r8)
     4dc:	000012f1 	.word	0x000012f1
     4e0:	40008000 	.word	0x40008000
     4e4:	00000225 	.word	0x00000225
     4e8:	0000031d 	.word	0x0000031d
     4ec:	00000195 	.word	0x00000195
     4f0:	000001d5 	.word	0x000001d5
     4f4:	00000359 	.word	0x00000359
     4f8:	000003d1 	.word	0x000003d1
     4fc:	00000451 	.word	0x00000451

00000500 <CAN1_tx_callback>:
uint32_t u32cnt = 0;

void CAN1_tx_callback(struct can_async_descriptor *const descr)
{
	(void)descr;
}
     500:	4770      	bx	lr
	...

00000504 <CAN1_rx_callback>:

void CAN1_rx_callback(struct can_async_descriptor *const descr)
{
     504:	b510      	push	{r4, lr}
     506:	b094      	sub	sp, #80	; 0x50

	struct can_message msg;
	uint8_t            data[64];
	msg.data = data;
     508:	ac10      	add	r4, sp, #64	; 0x40
     50a:	466b      	mov	r3, sp
     50c:	9312      	str	r3, [sp, #72]	; 0x48
	can_async_read(descr, &msg);
     50e:	0021      	movs	r1, r4
     510:	4b08      	ldr	r3, [pc, #32]	; (534 <CAN1_rx_callback+0x30>)
     512:	4798      	blx	r3
	
	if(CAN_FMT_STDID == msg.fmt)
     514:	7b63      	ldrb	r3, [r4, #13]
     516:	2b00      	cmp	r3, #0
     518:	d006      	beq.n	528 <CAN1_rx_callback+0x24>
	{
		u32cnt++;
		//SEGGER_RTT_printf(0,"CAN ID IS CAN_FMT_STDID \r\n");
		//SEGGER_RTT_printf(0,"CAN ID  = %08x \r\n", msg.id);
	}
	else if(CAN_FMT_EXTID == msg.fmt)
     51a:	2b01      	cmp	r3, #1
     51c:	d108      	bne.n	530 <CAN1_rx_callback+0x2c>
	{
		u32cnt++;
     51e:	4a06      	ldr	r2, [pc, #24]	; (538 <CAN1_rx_callback+0x34>)
     520:	6813      	ldr	r3, [r2, #0]
     522:	3301      	adds	r3, #1
     524:	6013      	str	r3, [r2, #0]
	//for (uint8_t i =0; i < msg.len; i++)
	//{
		//SEGGER_RTT_printf(0,"CAN1 data = %02x \r\n", msg.data[i]);	
	//}
	
	return;
     526:	e003      	b.n	530 <CAN1_rx_callback+0x2c>
		u32cnt++;
     528:	4a03      	ldr	r2, [pc, #12]	; (538 <CAN1_rx_callback+0x34>)
     52a:	6813      	ldr	r3, [r2, #0]
     52c:	3301      	adds	r3, #1
     52e:	6013      	str	r3, [r2, #0]
}
     530:	b014      	add	sp, #80	; 0x50
     532:	bd10      	pop	{r4, pc}
     534:	00000911 	.word	0x00000911
     538:	20000044 	.word	0x20000044

0000053c <CAN1_Init>:


void CAN1_Init(void)
{
     53c:	b5f0      	push	{r4, r5, r6, r7, lr}
     53e:	46ce      	mov	lr, r9
     540:	4647      	mov	r7, r8
     542:	b580      	push	{r7, lr}
     544:	b089      	sub	sp, #36	; 0x24
	struct can_message msg;
	struct can_filter  filter;
	uint8_t            send_data[4];
	send_data[0] = 0x00;
     546:	ab01      	add	r3, sp, #4
     548:	2600      	movs	r6, #0
     54a:	701e      	strb	r6, [r3, #0]
	send_data[1] = 0x01;
     54c:	2201      	movs	r2, #1
     54e:	4691      	mov	r9, r2
     550:	705a      	strb	r2, [r3, #1]
	send_data[2] = 0x02;
     552:	2202      	movs	r2, #2
     554:	709a      	strb	r2, [r3, #2]
	send_data[3] = 0x03;
     556:	3201      	adds	r2, #1
     558:	70da      	strb	r2, [r3, #3]

	msg.id   = 0x45A;
     55a:	ad04      	add	r5, sp, #16
     55c:	4a1a      	ldr	r2, [pc, #104]	; (5c8 <CAN1_Init+0x8c>)
     55e:	9204      	str	r2, [sp, #16]
	msg.type = CAN_TYPE_DATA;
     560:	712e      	strb	r6, [r5, #4]
	msg.data = send_data;
     562:	9306      	str	r3, [sp, #24]
	msg.len  = 4;
     564:	2304      	movs	r3, #4
     566:	732b      	strb	r3, [r5, #12]
	msg.fmt  = CAN_FMT_STDID;
     568:	736e      	strb	r6, [r5, #13]
	can_async_register_callback(&CAN_1, CAN_ASYNC_TX_CB, (FUNC_PTR)CAN1_tx_callback);
     56a:	4c18      	ldr	r4, [pc, #96]	; (5cc <CAN1_Init+0x90>)
     56c:	4a18      	ldr	r2, [pc, #96]	; (5d0 <CAN1_Init+0x94>)
     56e:	2101      	movs	r1, #1
     570:	0020      	movs	r0, r4
     572:	4f18      	ldr	r7, [pc, #96]	; (5d4 <CAN1_Init+0x98>)
     574:	47b8      	blx	r7
	can_async_enable(&CAN_1);
     576:	0020      	movs	r0, r4
     578:	4b17      	ldr	r3, [pc, #92]	; (5d8 <CAN1_Init+0x9c>)
     57a:	4798      	blx	r3

	/**
	 * CAN_1_tx_callback callback should be invoked after call
	 * can_async_write, and remote device should recieve message with ID=0x45A
	 */
	can_async_write(&CAN_1, &msg);
     57c:	0029      	movs	r1, r5
     57e:	0020      	movs	r0, r4
     580:	4b16      	ldr	r3, [pc, #88]	; (5dc <CAN1_Init+0xa0>)
     582:	4698      	mov	r8, r3
     584:	4798      	blx	r3

	msg.id  = 0x100000A5;
     586:	4b16      	ldr	r3, [pc, #88]	; (5e0 <CAN1_Init+0xa4>)
     588:	9304      	str	r3, [sp, #16]
	msg.fmt = CAN_FMT_EXTID;
     58a:	464b      	mov	r3, r9
     58c:	736b      	strb	r3, [r5, #13]
	/**
	 * remote device should recieve message with ID=0x100000A5
	 */
	can_async_write(&CAN_1, &msg);
     58e:	0029      	movs	r1, r5
     590:	0020      	movs	r0, r4
     592:	47c0      	blx	r8
	/**
	 * CAN_1_rx_callback callback should be invoked after call
	 * can_async_set_filter and remote device send CAN Message with the same
	 * content as the filter.
	 */
	can_async_register_callback(&CAN_1, CAN_ASYNC_RX_CB, (FUNC_PTR)CAN1_rx_callback);
     594:	4a13      	ldr	r2, [pc, #76]	; (5e4 <CAN1_Init+0xa8>)
     596:	2100      	movs	r1, #0
     598:	0020      	movs	r0, r4
     59a:	47b8      	blx	r7
	filter.id   = 0x469;
     59c:	4b12      	ldr	r3, [pc, #72]	; (5e8 <CAN1_Init+0xac>)
     59e:	9302      	str	r3, [sp, #8]
	filter.mask = 0;
     5a0:	9603      	str	r6, [sp, #12]
	can_async_set_filter(&CAN_1, 0, CAN_FMT_STDID, &filter);
     5a2:	ab02      	add	r3, sp, #8
     5a4:	2200      	movs	r2, #0
     5a6:	2100      	movs	r1, #0
     5a8:	0020      	movs	r0, r4
     5aa:	4d10      	ldr	r5, [pc, #64]	; (5ec <CAN1_Init+0xb0>)
     5ac:	47a8      	blx	r5

	filter.id   = 0x10000096;
     5ae:	4b10      	ldr	r3, [pc, #64]	; (5f0 <CAN1_Init+0xb4>)
     5b0:	9302      	str	r3, [sp, #8]
	filter.mask = 0;
     5b2:	9603      	str	r6, [sp, #12]
	can_async_set_filter(&CAN_1, 1, CAN_FMT_EXTID, &filter);
     5b4:	ab02      	add	r3, sp, #8
     5b6:	2201      	movs	r2, #1
     5b8:	2101      	movs	r1, #1
     5ba:	0020      	movs	r0, r4
     5bc:	47a8      	blx	r5
}
     5be:	b009      	add	sp, #36	; 0x24
     5c0:	bc0c      	pop	{r2, r3}
     5c2:	4690      	mov	r8, r2
     5c4:	4699      	mov	r9, r3
     5c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     5c8:	0000045a 	.word	0x0000045a
     5cc:	20000688 	.word	0x20000688
     5d0:	00000501 	.word	0x00000501
     5d4:	00000981 	.word	0x00000981
     5d8:	000008e9 	.word	0x000008e9
     5dc:	00000949 	.word	0x00000949
     5e0:	100000a5 	.word	0x100000a5
     5e4:	00000505 	.word	0x00000505
     5e8:	00000469 	.word	0x00000469
     5ec:	000009d1 	.word	0x000009d1
     5f0:	10000096 	.word	0x10000096

000005f4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
     5f4:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     5f6:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     5f8:	689a      	ldr	r2, [r3, #8]
     5fa:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     5fc:	689a      	ldr	r2, [r3, #8]
     5fe:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
     600:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     602:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
     604:	6803      	ldr	r3, [r0, #0]
     606:	3301      	adds	r3, #1
     608:	6003      	str	r3, [r0, #0]
}
     60a:	4770      	bx	lr

0000060c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     60c:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     60e:	6842      	ldr	r2, [r0, #4]
     610:	6881      	ldr	r1, [r0, #8]
     612:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     614:	6882      	ldr	r2, [r0, #8]
     616:	6841      	ldr	r1, [r0, #4]
     618:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     61a:	685a      	ldr	r2, [r3, #4]
     61c:	4290      	cmp	r0, r2
     61e:	d006      	beq.n	62e <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     620:	2200      	movs	r2, #0
     622:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
     624:	681a      	ldr	r2, [r3, #0]
     626:	3a01      	subs	r2, #1
     628:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     62a:	6818      	ldr	r0, [r3, #0]
}
     62c:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     62e:	6882      	ldr	r2, [r0, #8]
     630:	605a      	str	r2, [r3, #4]
     632:	e7f5      	b.n	620 <uxListRemove+0x14>

00000634 <ulSetInterruptMaskFromISR>:
}
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
     634:	f3ef 8010 	mrs	r0, PRIMASK
     638:	b672      	cpsid	i
     63a:	4770      	bx	lr

0000063c <vClearInterruptMaskFromISR>:
}
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( __attribute__( ( unused ) ) uint32_t ulMask )
{
	__asm volatile(
     63c:	f380 8810 	msr	PRIMASK, r0
     640:	4770      	bx	lr
	...

00000650 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
     650:	f3ef 8009 	mrs	r0, PSP
     654:	4b0e      	ldr	r3, [pc, #56]	; (690 <pxCurrentTCBConst>)
     656:	681a      	ldr	r2, [r3, #0]
     658:	3820      	subs	r0, #32
     65a:	6010      	str	r0, [r2, #0]
     65c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     65e:	4644      	mov	r4, r8
     660:	464d      	mov	r5, r9
     662:	4656      	mov	r6, sl
     664:	465f      	mov	r7, fp
     666:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
     668:	b508      	push	{r3, lr}
     66a:	b672      	cpsid	i
     66c:	f000 f8be 	bl	7ec <vTaskSwitchContext>
     670:	b662      	cpsie	i
     672:	bc0c      	pop	{r2, r3}
     674:	6811      	ldr	r1, [r2, #0]
     676:	6808      	ldr	r0, [r1, #0]
     678:	3010      	adds	r0, #16
     67a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     67c:	46a0      	mov	r8, r4
     67e:	46a9      	mov	r9, r5
     680:	46b2      	mov	sl, r6
     682:	46bb      	mov	fp, r7
     684:	f380 8809 	msr	PSP, r0
     688:	3820      	subs	r0, #32
     68a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
     68c:	4718      	bx	r3
     68e:	46c0      	nop			; (mov r8, r8)

00000690 <pxCurrentTCBConst>:
     690:	20000120 	.word	0x20000120

00000694 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
     694:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
     696:	4b07      	ldr	r3, [pc, #28]	; (6b4 <SysTick_Handler+0x20>)
     698:	4798      	blx	r3
     69a:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
     69c:	4b06      	ldr	r3, [pc, #24]	; (6b8 <SysTick_Handler+0x24>)
     69e:	4798      	blx	r3
     6a0:	2800      	cmp	r0, #0
     6a2:	d003      	beq.n	6ac <SysTick_Handler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
     6a4:	2280      	movs	r2, #128	; 0x80
     6a6:	0552      	lsls	r2, r2, #21
     6a8:	4b04      	ldr	r3, [pc, #16]	; (6bc <SysTick_Handler+0x28>)
     6aa:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
     6ac:	0020      	movs	r0, r4
     6ae:	4b04      	ldr	r3, [pc, #16]	; (6c0 <SysTick_Handler+0x2c>)
     6b0:	4798      	blx	r3
}
     6b2:	bd10      	pop	{r4, pc}
     6b4:	00000635 	.word	0x00000635
     6b8:	000006ed 	.word	0x000006ed
     6bc:	e000ed04 	.word	0xe000ed04
     6c0:	0000063d 	.word	0x0000063d

000006c4 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     6c4:	4b08      	ldr	r3, [pc, #32]	; (6e8 <prvResetNextTaskUnblockTime+0x24>)
     6c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     6c8:	681b      	ldr	r3, [r3, #0]
     6ca:	2b00      	cmp	r3, #0
     6cc:	d006      	beq.n	6dc <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     6ce:	4b06      	ldr	r3, [pc, #24]	; (6e8 <prvResetNextTaskUnblockTime+0x24>)
     6d0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     6d2:	68d2      	ldr	r2, [r2, #12]
     6d4:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     6d6:	6852      	ldr	r2, [r2, #4]
     6d8:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
     6da:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
     6dc:	2201      	movs	r2, #1
     6de:	4252      	negs	r2, r2
     6e0:	4b01      	ldr	r3, [pc, #4]	; (6e8 <prvResetNextTaskUnblockTime+0x24>)
     6e2:	62da      	str	r2, [r3, #44]	; 0x2c
     6e4:	e7f9      	b.n	6da <prvResetNextTaskUnblockTime+0x16>
     6e6:	46c0      	nop			; (mov r8, r8)
     6e8:	20000048 	.word	0x20000048

000006ec <xTaskIncrementTick>:
{
     6ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     6ee:	4b39      	ldr	r3, [pc, #228]	; (7d4 <xTaskIncrementTick+0xe8>)
     6f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     6f2:	2b00      	cmp	r3, #0
     6f4:	d162      	bne.n	7bc <xTaskIncrementTick+0xd0>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     6f6:	4b37      	ldr	r3, [pc, #220]	; (7d4 <xTaskIncrementTick+0xe8>)
     6f8:	6edd      	ldr	r5, [r3, #108]	; 0x6c
     6fa:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
     6fc:	66dd      	str	r5, [r3, #108]	; 0x6c
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     6fe:	2d00      	cmp	r5, #0
     700:	d111      	bne.n	726 <xTaskIncrementTick+0x3a>
			taskSWITCH_DELAYED_LISTS();
     702:	4b35      	ldr	r3, [pc, #212]	; (7d8 <xTaskIncrementTick+0xec>)
     704:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     706:	681b      	ldr	r3, [r3, #0]
     708:	2b00      	cmp	r3, #0
     70a:	d001      	beq.n	710 <xTaskIncrementTick+0x24>
     70c:	b672      	cpsid	i
     70e:	e7fe      	b.n	70e <xTaskIncrementTick+0x22>
     710:	4a31      	ldr	r2, [pc, #196]	; (7d8 <xTaskIncrementTick+0xec>)
     712:	6a91      	ldr	r1, [r2, #40]	; 0x28
     714:	4b2f      	ldr	r3, [pc, #188]	; (7d4 <xTaskIncrementTick+0xe8>)
     716:	6d18      	ldr	r0, [r3, #80]	; 0x50
     718:	6290      	str	r0, [r2, #40]	; 0x28
     71a:	6519      	str	r1, [r3, #80]	; 0x50
     71c:	6f9a      	ldr	r2, [r3, #120]	; 0x78
     71e:	3201      	adds	r2, #1
     720:	679a      	str	r2, [r3, #120]	; 0x78
     722:	4b2e      	ldr	r3, [pc, #184]	; (7dc <xTaskIncrementTick+0xf0>)
     724:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
     726:	4b2c      	ldr	r3, [pc, #176]	; (7d8 <xTaskIncrementTick+0xec>)
     728:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     72a:	429d      	cmp	r5, r3
     72c:	d23c      	bcs.n	7a8 <xTaskIncrementTick+0xbc>
BaseType_t xSwitchRequired = pdFALSE;
     72e:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     730:	4b28      	ldr	r3, [pc, #160]	; (7d4 <xTaskIncrementTick+0xe8>)
     732:	6d9b      	ldr	r3, [r3, #88]	; 0x58
     734:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     736:	0093      	lsls	r3, r2, #2
     738:	189b      	adds	r3, r3, r2
     73a:	009a      	lsls	r2, r3, #2
     73c:	4b26      	ldr	r3, [pc, #152]	; (7d8 <xTaskIncrementTick+0xec>)
     73e:	189b      	adds	r3, r3, r2
     740:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     742:	2b01      	cmp	r3, #1
     744:	d93f      	bls.n	7c6 <xTaskIncrementTick+0xda>
				xSwitchRequired = pdTRUE;
     746:	2401      	movs	r4, #1
     748:	e03d      	b.n	7c6 <xTaskIncrementTick+0xda>
							xSwitchRequired = pdTRUE;
     74a:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     74c:	4b22      	ldr	r3, [pc, #136]	; (7d8 <xTaskIncrementTick+0xec>)
     74e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     750:	681b      	ldr	r3, [r3, #0]
     752:	2b00      	cmp	r3, #0
     754:	d02a      	beq.n	7ac <xTaskIncrementTick+0xc0>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     756:	4b20      	ldr	r3, [pc, #128]	; (7d8 <xTaskIncrementTick+0xec>)
     758:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     75a:	68db      	ldr	r3, [r3, #12]
     75c:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     75e:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
     760:	429d      	cmp	r5, r3
     762:	d328      	bcc.n	7b6 <xTaskIncrementTick+0xca>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     764:	1d37      	adds	r7, r6, #4
     766:	0038      	movs	r0, r7
     768:	4b1d      	ldr	r3, [pc, #116]	; (7e0 <xTaskIncrementTick+0xf4>)
     76a:	4798      	blx	r3
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     76c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
     76e:	2b00      	cmp	r3, #0
     770:	d003      	beq.n	77a <xTaskIncrementTick+0x8e>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     772:	0030      	movs	r0, r6
     774:	3018      	adds	r0, #24
     776:	4b1a      	ldr	r3, [pc, #104]	; (7e0 <xTaskIncrementTick+0xf4>)
     778:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
     77a:	6af2      	ldr	r2, [r6, #44]	; 0x2c
     77c:	4b15      	ldr	r3, [pc, #84]	; (7d4 <xTaskIncrementTick+0xe8>)
     77e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
     780:	429a      	cmp	r2, r3
     782:	d901      	bls.n	788 <xTaskIncrementTick+0x9c>
     784:	4b13      	ldr	r3, [pc, #76]	; (7d4 <xTaskIncrementTick+0xe8>)
     786:	665a      	str	r2, [r3, #100]	; 0x64
     788:	0093      	lsls	r3, r2, #2
     78a:	189b      	adds	r3, r3, r2
     78c:	009a      	lsls	r2, r3, #2
     78e:	4812      	ldr	r0, [pc, #72]	; (7d8 <xTaskIncrementTick+0xec>)
     790:	3030      	adds	r0, #48	; 0x30
     792:	1880      	adds	r0, r0, r2
     794:	0039      	movs	r1, r7
     796:	4b13      	ldr	r3, [pc, #76]	; (7e4 <xTaskIncrementTick+0xf8>)
     798:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     79a:	6af2      	ldr	r2, [r6, #44]	; 0x2c
     79c:	4b0d      	ldr	r3, [pc, #52]	; (7d4 <xTaskIncrementTick+0xe8>)
     79e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
     7a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     7a2:	429a      	cmp	r2, r3
     7a4:	d2d1      	bcs.n	74a <xTaskIncrementTick+0x5e>
     7a6:	e7d1      	b.n	74c <xTaskIncrementTick+0x60>
     7a8:	2400      	movs	r4, #0
     7aa:	e7cf      	b.n	74c <xTaskIncrementTick+0x60>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7ac:	2201      	movs	r2, #1
     7ae:	4252      	negs	r2, r2
     7b0:	4b09      	ldr	r3, [pc, #36]	; (7d8 <xTaskIncrementTick+0xec>)
     7b2:	62da      	str	r2, [r3, #44]	; 0x2c
					break;
     7b4:	e7bc      	b.n	730 <xTaskIncrementTick+0x44>
						xNextTaskUnblockTime = xItemValue;
     7b6:	4a08      	ldr	r2, [pc, #32]	; (7d8 <xTaskIncrementTick+0xec>)
     7b8:	62d3      	str	r3, [r2, #44]	; 0x2c
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     7ba:	e7b9      	b.n	730 <xTaskIncrementTick+0x44>
		++uxPendedTicks;
     7bc:	4a05      	ldr	r2, [pc, #20]	; (7d4 <xTaskIncrementTick+0xe8>)
     7be:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
     7c0:	3301      	adds	r3, #1
     7c2:	67d3      	str	r3, [r2, #124]	; 0x7c
BaseType_t xSwitchRequired = pdFALSE;
     7c4:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
     7c6:	4b08      	ldr	r3, [pc, #32]	; (7e8 <xTaskIncrementTick+0xfc>)
     7c8:	681b      	ldr	r3, [r3, #0]
     7ca:	2b00      	cmp	r3, #0
     7cc:	d000      	beq.n	7d0 <xTaskIncrementTick+0xe4>
			xSwitchRequired = pdTRUE;
     7ce:	2401      	movs	r4, #1
}
     7d0:	0020      	movs	r0, r4
     7d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     7d4:	200000c8 	.word	0x200000c8
     7d8:	20000048 	.word	0x20000048
     7dc:	000006c5 	.word	0x000006c5
     7e0:	0000060d 	.word	0x0000060d
     7e4:	000005f5 	.word	0x000005f5
     7e8:	20000148 	.word	0x20000148

000007ec <vTaskSwitchContext>:
{
     7ec:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     7ee:	4b1d      	ldr	r3, [pc, #116]	; (864 <vTaskSwitchContext+0x78>)
     7f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     7f2:	2b00      	cmp	r3, #0
     7f4:	d110      	bne.n	818 <vTaskSwitchContext+0x2c>
		xYieldPending = pdFALSE;
     7f6:	2200      	movs	r2, #0
     7f8:	4b1b      	ldr	r3, [pc, #108]	; (868 <vTaskSwitchContext+0x7c>)
     7fa:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     7fc:	4b19      	ldr	r3, [pc, #100]	; (864 <vTaskSwitchContext+0x78>)
     7fe:	6e5b      	ldr	r3, [r3, #100]	; 0x64
     800:	009a      	lsls	r2, r3, #2
     802:	18d2      	adds	r2, r2, r3
     804:	0091      	lsls	r1, r2, #2
     806:	4a19      	ldr	r2, [pc, #100]	; (86c <vTaskSwitchContext+0x80>)
     808:	1852      	adds	r2, r2, r1
     80a:	6b12      	ldr	r2, [r2, #48]	; 0x30
     80c:	2a00      	cmp	r2, #0
     80e:	d109      	bne.n	824 <vTaskSwitchContext+0x38>
     810:	2b00      	cmp	r3, #0
     812:	d005      	beq.n	820 <vTaskSwitchContext+0x34>
     814:	3b01      	subs	r3, #1
     816:	e7f3      	b.n	800 <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
     818:	2201      	movs	r2, #1
     81a:	4b13      	ldr	r3, [pc, #76]	; (868 <vTaskSwitchContext+0x7c>)
     81c:	601a      	str	r2, [r3, #0]
}
     81e:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     820:	b672      	cpsid	i
     822:	e7fe      	b.n	822 <vTaskSwitchContext+0x36>
     824:	4a11      	ldr	r2, [pc, #68]	; (86c <vTaskSwitchContext+0x80>)
     826:	0099      	lsls	r1, r3, #2
     828:	18cc      	adds	r4, r1, r3
     82a:	00a0      	lsls	r0, r4, #2
     82c:	1810      	adds	r0, r2, r0
     82e:	6b44      	ldr	r4, [r0, #52]	; 0x34
     830:	6864      	ldr	r4, [r4, #4]
     832:	6344      	str	r4, [r0, #52]	; 0x34
     834:	3230      	adds	r2, #48	; 0x30
     836:	18c9      	adds	r1, r1, r3
     838:	0088      	lsls	r0, r1, #2
     83a:	3008      	adds	r0, #8
     83c:	1812      	adds	r2, r2, r0
     83e:	4294      	cmp	r4, r2
     840:	d00a      	beq.n	858 <vTaskSwitchContext+0x6c>
     842:	009a      	lsls	r2, r3, #2
     844:	18d2      	adds	r2, r2, r3
     846:	0091      	lsls	r1, r2, #2
     848:	4a08      	ldr	r2, [pc, #32]	; (86c <vTaskSwitchContext+0x80>)
     84a:	1852      	adds	r2, r2, r1
     84c:	6b52      	ldr	r2, [r2, #52]	; 0x34
     84e:	68d1      	ldr	r1, [r2, #12]
     850:	4a04      	ldr	r2, [pc, #16]	; (864 <vTaskSwitchContext+0x78>)
     852:	6591      	str	r1, [r2, #88]	; 0x58
     854:	6653      	str	r3, [r2, #100]	; 0x64
}
     856:	e7e2      	b.n	81e <vTaskSwitchContext+0x32>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     858:	6860      	ldr	r0, [r4, #4]
     85a:	0089      	lsls	r1, r1, #2
     85c:	4a03      	ldr	r2, [pc, #12]	; (86c <vTaskSwitchContext+0x80>)
     85e:	1852      	adds	r2, r2, r1
     860:	6350      	str	r0, [r2, #52]	; 0x34
     862:	e7ee      	b.n	842 <vTaskSwitchContext+0x56>
     864:	200000c8 	.word	0x200000c8
     868:	20000148 	.word	0x20000148
     86c:	20000048 	.word	0x20000048

00000870 <can_tx_done>:

/**
 * \internal Callback of CAN Message Write finished
 */
static void can_tx_done(struct _can_async_device *dev)
{
     870:	b510      	push	{r4, lr}
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);

	if (descr->cb.tx_done) {
     872:	69c3      	ldr	r3, [r0, #28]
     874:	2b00      	cmp	r3, #0
     876:	d000      	beq.n	87a <can_tx_done+0xa>
		descr->cb.tx_done(descr);
     878:	4798      	blx	r3
	}
}
     87a:	bd10      	pop	{r4, pc}

0000087c <can_rx_done>:

/**
 * \internal Callback of CAN Message Read finished
 */
static void can_rx_done(struct _can_async_device *dev)
{
     87c:	b510      	push	{r4, lr}
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);

	if (descr->cb.rx_done) {
     87e:	6a03      	ldr	r3, [r0, #32]
     880:	2b00      	cmp	r3, #0
     882:	d000      	beq.n	886 <can_rx_done+0xa>
		descr->cb.rx_done(descr);
     884:	4798      	blx	r3
	}
}
     886:	bd10      	pop	{r4, pc}

00000888 <can_irq_handler>:

/**
 * \internal Callback of CAN Interrupt
 */
static void can_irq_handler(struct _can_async_device *dev, enum can_async_interrupt_type type)
{
     888:	b510      	push	{r4, lr}
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);

	if (descr->cb.irq_handler) {
     88a:	6a43      	ldr	r3, [r0, #36]	; 0x24
     88c:	2b00      	cmp	r3, #0
     88e:	d000      	beq.n	892 <can_irq_handler+0xa>
		descr->cb.irq_handler(descr, type);
     890:	4798      	blx	r3
	}
}
     892:	bd10      	pop	{r4, pc}

00000894 <can_async_init>:
{
     894:	b570      	push	{r4, r5, r6, lr}
     896:	0004      	movs	r4, r0
     898:	000d      	movs	r5, r1
	ASSERT(descr && hw);
     89a:	2800      	cmp	r0, #0
     89c:	d015      	beq.n	8ca <can_async_init+0x36>
     89e:	2900      	cmp	r1, #0
     8a0:	d011      	beq.n	8c6 <can_async_init+0x32>
     8a2:	2001      	movs	r0, #1
     8a4:	2241      	movs	r2, #65	; 0x41
     8a6:	490a      	ldr	r1, [pc, #40]	; (8d0 <can_async_init+0x3c>)
     8a8:	4b0a      	ldr	r3, [pc, #40]	; (8d4 <can_async_init+0x40>)
     8aa:	4798      	blx	r3
	rc = _can_async_init(&descr->dev, hw);
     8ac:	0029      	movs	r1, r5
     8ae:	0020      	movs	r0, r4
     8b0:	4b09      	ldr	r3, [pc, #36]	; (8d8 <can_async_init+0x44>)
     8b2:	4798      	blx	r3
	if (rc) {
     8b4:	2800      	cmp	r0, #0
     8b6:	d105      	bne.n	8c4 <can_async_init+0x30>
	descr->dev.cb.tx_done     = can_tx_done;
     8b8:	4b08      	ldr	r3, [pc, #32]	; (8dc <can_async_init+0x48>)
     8ba:	6063      	str	r3, [r4, #4]
	descr->dev.cb.rx_done     = can_rx_done;
     8bc:	4b08      	ldr	r3, [pc, #32]	; (8e0 <can_async_init+0x4c>)
     8be:	60a3      	str	r3, [r4, #8]
	descr->dev.cb.irq_handler = can_irq_handler;
     8c0:	4b08      	ldr	r3, [pc, #32]	; (8e4 <can_async_init+0x50>)
     8c2:	60e3      	str	r3, [r4, #12]
}
     8c4:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
     8c6:	2000      	movs	r0, #0
     8c8:	e7ec      	b.n	8a4 <can_async_init+0x10>
     8ca:	2000      	movs	r0, #0
     8cc:	e7ea      	b.n	8a4 <can_async_init+0x10>
     8ce:	46c0      	nop			; (mov r8, r8)
     8d0:	000021fc 	.word	0x000021fc
     8d4:	00000c81 	.word	0x00000c81
     8d8:	00000ce9 	.word	0x00000ce9
     8dc:	00000871 	.word	0x00000871
     8e0:	0000087d 	.word	0x0000087d
     8e4:	00000889 	.word	0x00000889

000008e8 <can_async_enable>:
{
     8e8:	b510      	push	{r4, lr}
     8ea:	0004      	movs	r4, r0
	ASSERT(descr);
     8ec:	1e43      	subs	r3, r0, #1
     8ee:	4198      	sbcs	r0, r3
     8f0:	b2c0      	uxtb	r0, r0
     8f2:	225c      	movs	r2, #92	; 0x5c
     8f4:	4903      	ldr	r1, [pc, #12]	; (904 <can_async_enable+0x1c>)
     8f6:	4b04      	ldr	r3, [pc, #16]	; (908 <can_async_enable+0x20>)
     8f8:	4798      	blx	r3
	return _can_async_enable(&descr->dev);
     8fa:	0020      	movs	r0, r4
     8fc:	4b03      	ldr	r3, [pc, #12]	; (90c <can_async_enable+0x24>)
     8fe:	4798      	blx	r3
}
     900:	bd10      	pop	{r4, pc}
     902:	46c0      	nop			; (mov r8, r8)
     904:	000021fc 	.word	0x000021fc
     908:	00000c81 	.word	0x00000c81
     90c:	00000ed1 	.word	0x00000ed1

00000910 <can_async_read>:
{
     910:	b570      	push	{r4, r5, r6, lr}
     912:	0004      	movs	r4, r0
     914:	000d      	movs	r5, r1
	ASSERT(descr && msg);
     916:	2800      	cmp	r0, #0
     918:	d00d      	beq.n	936 <can_async_read+0x26>
     91a:	2900      	cmp	r1, #0
     91c:	d009      	beq.n	932 <can_async_read+0x22>
     91e:	2001      	movs	r0, #1
     920:	226e      	movs	r2, #110	; 0x6e
     922:	4906      	ldr	r1, [pc, #24]	; (93c <can_async_read+0x2c>)
     924:	4b06      	ldr	r3, [pc, #24]	; (940 <can_async_read+0x30>)
     926:	4798      	blx	r3
	return _can_async_read(&descr->dev, msg);
     928:	0029      	movs	r1, r5
     92a:	0020      	movs	r0, r4
     92c:	4b05      	ldr	r3, [pc, #20]	; (944 <can_async_read+0x34>)
     92e:	4798      	blx	r3
}
     930:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && msg);
     932:	2000      	movs	r0, #0
     934:	e7f4      	b.n	920 <can_async_read+0x10>
     936:	2000      	movs	r0, #0
     938:	e7f2      	b.n	920 <can_async_read+0x10>
     93a:	46c0      	nop			; (mov r8, r8)
     93c:	000021fc 	.word	0x000021fc
     940:	00000c81 	.word	0x00000c81
     944:	00000ee1 	.word	0x00000ee1

00000948 <can_async_write>:
{
     948:	b570      	push	{r4, r5, r6, lr}
     94a:	0004      	movs	r4, r0
     94c:	000d      	movs	r5, r1
	ASSERT(descr && msg);
     94e:	2800      	cmp	r0, #0
     950:	d00d      	beq.n	96e <can_async_write+0x26>
     952:	2900      	cmp	r1, #0
     954:	d009      	beq.n	96a <can_async_write+0x22>
     956:	2001      	movs	r0, #1
     958:	2277      	movs	r2, #119	; 0x77
     95a:	4906      	ldr	r1, [pc, #24]	; (974 <can_async_write+0x2c>)
     95c:	4b06      	ldr	r3, [pc, #24]	; (978 <can_async_write+0x30>)
     95e:	4798      	blx	r3
	return _can_async_write(&descr->dev, msg);
     960:	0029      	movs	r1, r5
     962:	0020      	movs	r0, r4
     964:	4b05      	ldr	r3, [pc, #20]	; (97c <can_async_write+0x34>)
     966:	4798      	blx	r3
}
     968:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && msg);
     96a:	2000      	movs	r0, #0
     96c:	e7f4      	b.n	958 <can_async_write+0x10>
     96e:	2000      	movs	r0, #0
     970:	e7f2      	b.n	958 <can_async_write+0x10>
     972:	46c0      	nop			; (mov r8, r8)
     974:	000021fc 	.word	0x000021fc
     978:	00000c81 	.word	0x00000c81
     97c:	00000fbd 	.word	0x00000fbd

00000980 <can_async_register_callback>:
{
     980:	b570      	push	{r4, r5, r6, lr}
     982:	0006      	movs	r6, r0
     984:	000d      	movs	r5, r1
     986:	0014      	movs	r4, r2
	ASSERT(descr);
     988:	1e43      	subs	r3, r0, #1
     98a:	4198      	sbcs	r0, r3
     98c:	b2c0      	uxtb	r0, r0
     98e:	2281      	movs	r2, #129	; 0x81
     990:	490c      	ldr	r1, [pc, #48]	; (9c4 <can_async_register_callback+0x44>)
     992:	4b0d      	ldr	r3, [pc, #52]	; (9c8 <can_async_register_callback+0x48>)
     994:	4798      	blx	r3
	switch (type) {
     996:	2d01      	cmp	r5, #1
     998:	d010      	beq.n	9bc <can_async_register_callback+0x3c>
     99a:	2d00      	cmp	r5, #0
     99c:	d004      	beq.n	9a8 <can_async_register_callback+0x28>
     99e:	2d02      	cmp	r5, #2
     9a0:	d00e      	beq.n	9c0 <can_async_register_callback+0x40>
		return ERR_INVALID_ARG;
     9a2:	200d      	movs	r0, #13
     9a4:	4240      	negs	r0, r0
     9a6:	e008      	b.n	9ba <can_async_register_callback+0x3a>
		descr->cb.rx_done = (cb != NULL) ? (can_cb_t)cb : NULL;
     9a8:	6234      	str	r4, [r6, #32]
	_can_async_set_irq_state(&descr->dev, type, NULL != cb);
     9aa:	1e62      	subs	r2, r4, #1
     9ac:	4194      	sbcs	r4, r2
     9ae:	b2e2      	uxtb	r2, r4
     9b0:	0029      	movs	r1, r5
     9b2:	0030      	movs	r0, r6
     9b4:	4b05      	ldr	r3, [pc, #20]	; (9cc <can_async_register_callback+0x4c>)
     9b6:	4798      	blx	r3
	return ERR_NONE;
     9b8:	2000      	movs	r0, #0
}
     9ba:	bd70      	pop	{r4, r5, r6, pc}
		descr->cb.tx_done = (cb != NULL) ? (can_cb_t)cb : NULL;
     9bc:	61f4      	str	r4, [r6, #28]
		break;
     9be:	e7f4      	b.n	9aa <can_async_register_callback+0x2a>
		    = (cb != NULL) ? (void (*)(struct can_async_descriptor *const, enum can_async_interrupt_type))cb : NULL;
     9c0:	6274      	str	r4, [r6, #36]	; 0x24
		break;
     9c2:	e7f2      	b.n	9aa <can_async_register_callback+0x2a>
     9c4:	000021fc 	.word	0x000021fc
     9c8:	00000c81 	.word	0x00000c81
     9cc:	00001131 	.word	0x00001131

000009d0 <can_async_set_filter>:
{
     9d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     9d2:	0004      	movs	r4, r0
     9d4:	000d      	movs	r5, r1
     9d6:	0016      	movs	r6, r2
     9d8:	001f      	movs	r7, r3
	ASSERT(descr);
     9da:	1e43      	subs	r3, r0, #1
     9dc:	4198      	sbcs	r0, r3
     9de:	b2c0      	uxtb	r0, r0
     9e0:	22b8      	movs	r2, #184	; 0xb8
     9e2:	4905      	ldr	r1, [pc, #20]	; (9f8 <can_async_set_filter+0x28>)
     9e4:	4b05      	ldr	r3, [pc, #20]	; (9fc <can_async_set_filter+0x2c>)
     9e6:	4798      	blx	r3
	return _can_async_set_filter(&descr->dev, index, fmt, filter);
     9e8:	003b      	movs	r3, r7
     9ea:	0032      	movs	r2, r6
     9ec:	0029      	movs	r1, r5
     9ee:	0020      	movs	r0, r4
     9f0:	4c03      	ldr	r4, [pc, #12]	; (a00 <can_async_set_filter+0x30>)
     9f2:	47a0      	blx	r4
}
     9f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     9f6:	46c0      	nop			; (mov r8, r8)
     9f8:	000021fc 	.word	0x000021fc
     9fc:	00000c81 	.word	0x00000c81
     a00:	00001185 	.word	0x00001185

00000a04 <flash_ready>:
 * \internal Ready for a new flash command
 *
 * \param[in] device The pointer to flash device structure
 */
static void flash_ready(struct _flash_device *device)
{
     a04:	b510      	push	{r4, lr}
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_ready) {
     a06:	6943      	ldr	r3, [r0, #20]
     a08:	2b00      	cmp	r3, #0
     a0a:	d000      	beq.n	a0e <flash_ready+0xa>
		descr->callbacks.cb_ready(descr);
     a0c:	4798      	blx	r3
	}
}
     a0e:	bd10      	pop	{r4, pc}

00000a10 <flash_error>:
 * \internal Error occurs in flash command
 *
 * \param[in] device The pointer to flash device structure
 */
static void flash_error(struct _flash_device *device)
{
     a10:	b510      	push	{r4, lr}
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_error) {
     a12:	6983      	ldr	r3, [r0, #24]
     a14:	2b00      	cmp	r3, #0
     a16:	d000      	beq.n	a1a <flash_error+0xa>
		descr->callbacks.cb_error(descr);
     a18:	4798      	blx	r3
	}
}
     a1a:	bd10      	pop	{r4, pc}

00000a1c <flash_init>:
{
     a1c:	b570      	push	{r4, r5, r6, lr}
     a1e:	0004      	movs	r4, r0
     a20:	000d      	movs	r5, r1
	ASSERT(flash && hw);
     a22:	2800      	cmp	r0, #0
     a24:	d013      	beq.n	a4e <flash_init+0x32>
     a26:	2900      	cmp	r1, #0
     a28:	d00f      	beq.n	a4a <flash_init+0x2e>
     a2a:	2001      	movs	r0, #1
     a2c:	2238      	movs	r2, #56	; 0x38
     a2e:	4909      	ldr	r1, [pc, #36]	; (a54 <flash_init+0x38>)
     a30:	4b09      	ldr	r3, [pc, #36]	; (a58 <flash_init+0x3c>)
     a32:	4798      	blx	r3
	rc = _flash_init(&flash->dev, hw);
     a34:	0029      	movs	r1, r5
     a36:	0020      	movs	r0, r4
     a38:	4b08      	ldr	r3, [pc, #32]	; (a5c <flash_init+0x40>)
     a3a:	4798      	blx	r3
	if (rc) {
     a3c:	2800      	cmp	r0, #0
     a3e:	d103      	bne.n	a48 <flash_init+0x2c>
	flash->dev.flash_cb.ready_cb = flash_ready;
     a40:	4b07      	ldr	r3, [pc, #28]	; (a60 <flash_init+0x44>)
     a42:	6023      	str	r3, [r4, #0]
	flash->dev.flash_cb.error_cb = flash_error;
     a44:	4b07      	ldr	r3, [pc, #28]	; (a64 <flash_init+0x48>)
     a46:	6063      	str	r3, [r4, #4]
}
     a48:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(flash && hw);
     a4a:	2000      	movs	r0, #0
     a4c:	e7ee      	b.n	a2c <flash_init+0x10>
     a4e:	2000      	movs	r0, #0
     a50:	e7ec      	b.n	a2c <flash_init+0x10>
     a52:	46c0      	nop			; (mov r8, r8)
     a54:	00002218 	.word	0x00002218
     a58:	00000c81 	.word	0x00000c81
     a5c:	00001419 	.word	0x00001419
     a60:	00000a05 	.word	0x00000a05
     a64:	00000a11 	.word	0x00000a11

00000a68 <spi_m_sync_init>:
	ASSERT(spi);
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
     a68:	b570      	push	{r4, r5, r6, lr}
     a6a:	0004      	movs	r4, r0
     a6c:	000d      	movs	r5, r1
	int32_t rc = 0;
	ASSERT(spi && hw);
     a6e:	2800      	cmp	r0, #0
     a70:	d017      	beq.n	aa2 <spi_m_sync_init+0x3a>
     a72:	2900      	cmp	r1, #0
     a74:	d013      	beq.n	a9e <spi_m_sync_init+0x36>
     a76:	2001      	movs	r0, #1
     a78:	2240      	movs	r2, #64	; 0x40
     a7a:	490b      	ldr	r1, [pc, #44]	; (aa8 <spi_m_sync_init+0x40>)
     a7c:	4b0b      	ldr	r3, [pc, #44]	; (aac <spi_m_sync_init+0x44>)
     a7e:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
     a80:	6065      	str	r5, [r4, #4]
	rc            = _spi_m_sync_init(&spi->dev, hw);
     a82:	1d20      	adds	r0, r4, #4
     a84:	0029      	movs	r1, r5
     a86:	4b0a      	ldr	r3, [pc, #40]	; (ab0 <spi_m_sync_init+0x48>)
     a88:	4798      	blx	r3

	if (rc < 0) {
     a8a:	2800      	cmp	r0, #0
     a8c:	db06      	blt.n	a9c <spi_m_sync_init+0x34>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
     a8e:	4b09      	ldr	r3, [pc, #36]	; (ab4 <spi_m_sync_init+0x4c>)
     a90:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
     a92:	4b09      	ldr	r3, [pc, #36]	; (ab8 <spi_m_sync_init+0x50>)
     a94:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
     a96:	4b09      	ldr	r3, [pc, #36]	; (abc <spi_m_sync_init+0x54>)
     a98:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
     a9a:	2000      	movs	r0, #0
}
     a9c:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(spi && hw);
     a9e:	2000      	movs	r0, #0
     aa0:	e7ea      	b.n	a78 <spi_m_sync_init+0x10>
     aa2:	2000      	movs	r0, #0
     aa4:	e7e8      	b.n	a78 <spi_m_sync_init+0x10>
     aa6:	46c0      	nop			; (mov r8, r8)
     aa8:	00002230 	.word	0x00002230
     aac:	00000c81 	.word	0x00000c81
     ab0:	00001515 	.word	0x00001515
     ab4:	ffff8000 	.word	0xffff8000
     ab8:	00000b45 	.word	0x00000b45
     abc:	00000b09 	.word	0x00000b09

00000ac0 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
     ac0:	b530      	push	{r4, r5, lr}
     ac2:	b087      	sub	sp, #28
     ac4:	0004      	movs	r4, r0
     ac6:	000d      	movs	r5, r1
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
     ac8:	2800      	cmp	r0, #0
     aca:	d015      	beq.n	af8 <spi_m_sync_transfer+0x38>
     acc:	2900      	cmp	r1, #0
     ace:	d011      	beq.n	af4 <spi_m_sync_transfer+0x34>
     ad0:	2001      	movs	r0, #1
     ad2:	22b3      	movs	r2, #179	; 0xb3
     ad4:	4909      	ldr	r1, [pc, #36]	; (afc <spi_m_sync_transfer+0x3c>)
     ad6:	4b0a      	ldr	r3, [pc, #40]	; (b00 <spi_m_sync_transfer+0x40>)
     ad8:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
     ada:	682b      	ldr	r3, [r5, #0]
     adc:	9303      	str	r3, [sp, #12]
	msg.rxbuf = p_xfer->rxbuf;
     ade:	686b      	ldr	r3, [r5, #4]
     ae0:	9304      	str	r3, [sp, #16]
	msg.size  = p_xfer->size;
     ae2:	68ab      	ldr	r3, [r5, #8]
     ae4:	9301      	str	r3, [sp, #4]
     ae6:	9305      	str	r3, [sp, #20]
	return _spi_m_sync_trans(&spi->dev, &msg);
     ae8:	1d20      	adds	r0, r4, #4
     aea:	a903      	add	r1, sp, #12
     aec:	4b05      	ldr	r3, [pc, #20]	; (b04 <spi_m_sync_transfer+0x44>)
     aee:	4798      	blx	r3
}
     af0:	b007      	add	sp, #28
     af2:	bd30      	pop	{r4, r5, pc}
	ASSERT(spi && p_xfer);
     af4:	2000      	movs	r0, #0
     af6:	e7ec      	b.n	ad2 <spi_m_sync_transfer+0x12>
     af8:	2000      	movs	r0, #0
     afa:	e7ea      	b.n	ad2 <spi_m_sync_transfer+0x12>
     afc:	00002230 	.word	0x00002230
     b00:	00000c81 	.word	0x00000c81
     b04:	00001711 	.word	0x00001711

00000b08 <_spi_m_sync_io_write>:
{
     b08:	b570      	push	{r4, r5, r6, lr}
     b0a:	b084      	sub	sp, #16
     b0c:	0004      	movs	r4, r0
     b0e:	000e      	movs	r6, r1
     b10:	0015      	movs	r5, r2
	ASSERT(io);
     b12:	1e43      	subs	r3, r0, #1
     b14:	4198      	sbcs	r0, r3
     b16:	b2c0      	uxtb	r0, r0
     b18:	22a3      	movs	r2, #163	; 0xa3
     b1a:	4907      	ldr	r1, [pc, #28]	; (b38 <_spi_m_sync_io_write+0x30>)
     b1c:	4b07      	ldr	r3, [pc, #28]	; (b3c <_spi_m_sync_io_write+0x34>)
     b1e:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
     b20:	0020      	movs	r0, r4
     b22:	380c      	subs	r0, #12
	xfer.rxbuf = 0;
     b24:	2300      	movs	r3, #0
     b26:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
     b28:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
     b2a:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
     b2c:	a901      	add	r1, sp, #4
     b2e:	4b04      	ldr	r3, [pc, #16]	; (b40 <_spi_m_sync_io_write+0x38>)
     b30:	4798      	blx	r3
}
     b32:	b004      	add	sp, #16
     b34:	bd70      	pop	{r4, r5, r6, pc}
     b36:	46c0      	nop			; (mov r8, r8)
     b38:	00002230 	.word	0x00002230
     b3c:	00000c81 	.word	0x00000c81
     b40:	00000ac1 	.word	0x00000ac1

00000b44 <_spi_m_sync_io_read>:
{
     b44:	b570      	push	{r4, r5, r6, lr}
     b46:	b084      	sub	sp, #16
     b48:	0004      	movs	r4, r0
     b4a:	000e      	movs	r6, r1
     b4c:	0015      	movs	r5, r2
	ASSERT(io);
     b4e:	1e43      	subs	r3, r0, #1
     b50:	4198      	sbcs	r0, r3
     b52:	b2c0      	uxtb	r0, r0
     b54:	2287      	movs	r2, #135	; 0x87
     b56:	4907      	ldr	r1, [pc, #28]	; (b74 <_spi_m_sync_io_read+0x30>)
     b58:	4b07      	ldr	r3, [pc, #28]	; (b78 <_spi_m_sync_io_read+0x34>)
     b5a:	4798      	blx	r3
	struct spi_m_sync_descriptor *spi = CONTAINER_OF(io, struct spi_m_sync_descriptor, io);
     b5c:	0020      	movs	r0, r4
     b5e:	380c      	subs	r0, #12
	xfer.rxbuf = buf;
     b60:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
     b62:	2300      	movs	r3, #0
     b64:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
     b66:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
     b68:	a901      	add	r1, sp, #4
     b6a:	4b04      	ldr	r3, [pc, #16]	; (b7c <_spi_m_sync_io_read+0x38>)
     b6c:	4798      	blx	r3
}
     b6e:	b004      	add	sp, #16
     b70:	bd70      	pop	{r4, r5, r6, pc}
     b72:	46c0      	nop			; (mov r8, r8)
     b74:	00002230 	.word	0x00002230
     b78:	00000c81 	.word	0x00000c81
     b7c:	00000ac1 	.word	0x00000ac1

00000b80 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
     b80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
     b82:	6806      	ldr	r6, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
     b84:	2e00      	cmp	r6, #0
     b86:	d002      	beq.n	b8e <timer_add_timer_task+0xe>
     b88:	0033      	movs	r3, r6
     b8a:	2500      	movs	r5, #0
     b8c:	e00c      	b.n	ba8 <timer_add_timer_task+0x28>
		list_insert_as_head(list, new_task);
     b8e:	4b10      	ldr	r3, [pc, #64]	; (bd0 <timer_add_timer_task+0x50>)
     b90:	4798      	blx	r3
		return;
     b92:	e018      	b.n	bc6 <timer_add_timer_task+0x46>
		uint32_t time_left;

		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
     b94:	689f      	ldr	r7, [r3, #8]
     b96:	46bc      	mov	ip, r7
     b98:	4464      	add	r4, ip
     b9a:	1aa4      	subs	r4, r4, r2
     b9c:	3401      	adds	r4, #1
		}
		if (time_left >= new_task->interval)
     b9e:	688f      	ldr	r7, [r1, #8]
     ba0:	42bc      	cmp	r4, r7
     ba2:	d20b      	bcs.n	bbc <timer_add_timer_task+0x3c>
			break;
		prev = it;
     ba4:	001d      	movs	r5, r3
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
     ba6:	681b      	ldr	r3, [r3, #0]
     ba8:	2b00      	cmp	r3, #0
     baa:	d007      	beq.n	bbc <timer_add_timer_task+0x3c>
		if (it->time_label <= time) {
     bac:	685c      	ldr	r4, [r3, #4]
     bae:	4294      	cmp	r4, r2
     bb0:	d8f0      	bhi.n	b94 <timer_add_timer_task+0x14>
			time_left = it->interval - (time - it->time_label);
     bb2:	1aa4      	subs	r4, r4, r2
     bb4:	689f      	ldr	r7, [r3, #8]
     bb6:	46bc      	mov	ip, r7
     bb8:	4464      	add	r4, ip
     bba:	e7f0      	b.n	b9e <timer_add_timer_task+0x1e>
	}

	if (it == head) {
     bbc:	42b3      	cmp	r3, r6
     bbe:	d003      	beq.n	bc8 <timer_add_timer_task+0x48>
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
     bc0:	0028      	movs	r0, r5
     bc2:	4b04      	ldr	r3, [pc, #16]	; (bd4 <timer_add_timer_task+0x54>)
     bc4:	4798      	blx	r3
	}
}
     bc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
     bc8:	4b01      	ldr	r3, [pc, #4]	; (bd0 <timer_add_timer_task+0x50>)
     bca:	4798      	blx	r3
     bcc:	e7fb      	b.n	bc6 <timer_add_timer_task+0x46>
     bce:	46c0      	nop			; (mov r8, r8)
     bd0:	00000ca1 	.word	0x00000ca1
     bd4:	00000ccd 	.word	0x00000ccd

00000bd8 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
     bd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     bda:	0005      	movs	r5, r0
     bdc:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
     bde:	6903      	ldr	r3, [r0, #16]
     be0:	1c5e      	adds	r6, r3, #1
     be2:	6106      	str	r6, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
     be4:	7e03      	ldrb	r3, [r0, #24]
     be6:	07db      	lsls	r3, r3, #31
     be8:	d402      	bmi.n	bf0 <timer_process_counted+0x18>
     bea:	7e03      	ldrb	r3, [r0, #24]
     bec:	079b      	lsls	r3, r3, #30
     bee:	d50a      	bpl.n	c06 <timer_process_counted+0x2e>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
     bf0:	7e2b      	ldrb	r3, [r5, #24]
     bf2:	2202      	movs	r2, #2
     bf4:	4313      	orrs	r3, r2
     bf6:	b2db      	uxtb	r3, r3
     bf8:	762b      	strb	r3, [r5, #24]
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
	}
}
     bfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     bfc:	696f      	ldr	r7, [r5, #20]
		tmp->cb(tmp);
     bfe:	68e3      	ldr	r3, [r4, #12]
     c00:	0020      	movs	r0, r4
     c02:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
     c04:	003c      	movs	r4, r7
	while (it && ((time - it->time_label) >= it->interval)) {
     c06:	2c00      	cmp	r4, #0
     c08:	d0f7      	beq.n	bfa <timer_process_counted+0x22>
     c0a:	6863      	ldr	r3, [r4, #4]
     c0c:	1af3      	subs	r3, r6, r3
     c0e:	68a2      	ldr	r2, [r4, #8]
     c10:	4293      	cmp	r3, r2
     c12:	d3f2      	bcc.n	bfa <timer_process_counted+0x22>
		list_remove_head(&timer->tasks);
     c14:	002f      	movs	r7, r5
     c16:	3714      	adds	r7, #20
     c18:	0038      	movs	r0, r7
     c1a:	4b06      	ldr	r3, [pc, #24]	; (c34 <timer_process_counted+0x5c>)
     c1c:	4798      	blx	r3
		if (TIMER_TASK_REPEAT == tmp->mode) {
     c1e:	7c23      	ldrb	r3, [r4, #16]
     c20:	2b01      	cmp	r3, #1
     c22:	d1eb      	bne.n	bfc <timer_process_counted+0x24>
			tmp->time_label = time;
     c24:	6066      	str	r6, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
     c26:	0032      	movs	r2, r6
     c28:	0021      	movs	r1, r4
     c2a:	0038      	movs	r0, r7
     c2c:	4b02      	ldr	r3, [pc, #8]	; (c38 <timer_process_counted+0x60>)
     c2e:	4798      	blx	r3
     c30:	e7e4      	b.n	bfc <timer_process_counted+0x24>
     c32:	46c0      	nop			; (mov r8, r8)
     c34:	00000cd5 	.word	0x00000cd5
     c38:	00000b81 	.word	0x00000b81

00000c3c <timer_init>:
{
     c3c:	b570      	push	{r4, r5, r6, lr}
     c3e:	0004      	movs	r4, r0
     c40:	000d      	movs	r5, r1
	ASSERT(descr && hw);
     c42:	2800      	cmp	r0, #0
     c44:	d012      	beq.n	c6c <timer_init+0x30>
     c46:	2900      	cmp	r1, #0
     c48:	d00e      	beq.n	c68 <timer_init+0x2c>
     c4a:	2001      	movs	r0, #1
     c4c:	223b      	movs	r2, #59	; 0x3b
     c4e:	4908      	ldr	r1, [pc, #32]	; (c70 <timer_init+0x34>)
     c50:	4b08      	ldr	r3, [pc, #32]	; (c74 <timer_init+0x38>)
     c52:	4798      	blx	r3
	_timer_init(&descr->device, hw);
     c54:	0029      	movs	r1, r5
     c56:	0020      	movs	r0, r4
     c58:	4b07      	ldr	r3, [pc, #28]	; (c78 <timer_init+0x3c>)
     c5a:	4798      	blx	r3
	descr->time                           = 0;
     c5c:	2300      	movs	r3, #0
     c5e:	6123      	str	r3, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
     c60:	4b06      	ldr	r3, [pc, #24]	; (c7c <timer_init+0x40>)
     c62:	6023      	str	r3, [r4, #0]
}
     c64:	2000      	movs	r0, #0
     c66:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
     c68:	2000      	movs	r0, #0
     c6a:	e7ef      	b.n	c4c <timer_init+0x10>
     c6c:	2000      	movs	r0, #0
     c6e:	e7ed      	b.n	c4c <timer_init+0x10>
     c70:	0000224c 	.word	0x0000224c
     c74:	00000c81 	.word	0x00000c81
     c78:	000018c1 	.word	0x000018c1
     c7c:	00000bd9 	.word	0x00000bd9

00000c80 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
     c80:	2800      	cmp	r0, #0
     c82:	d100      	bne.n	c86 <assert+0x6>
		__asm("BKPT #0");
     c84:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
     c86:	4770      	bx	lr

00000c88 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
     c88:	6803      	ldr	r3, [r0, #0]
     c8a:	2b00      	cmp	r3, #0
     c8c:	d003      	beq.n	c96 <is_list_element+0xe>
		if (it == element) {
     c8e:	428b      	cmp	r3, r1
     c90:	d003      	beq.n	c9a <is_list_element+0x12>
	for (it = list->head; it; it = it->next) {
     c92:	681b      	ldr	r3, [r3, #0]
     c94:	e7f9      	b.n	c8a <is_list_element+0x2>
			return true;
		}
	}

	return false;
     c96:	2000      	movs	r0, #0
}
     c98:	4770      	bx	lr
			return true;
     c9a:	2001      	movs	r0, #1
     c9c:	e7fc      	b.n	c98 <is_list_element+0x10>
	...

00000ca0 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
     ca0:	b570      	push	{r4, r5, r6, lr}
     ca2:	0004      	movs	r4, r0
     ca4:	000d      	movs	r5, r1
	ASSERT(!is_list_element(list, element));
     ca6:	4b06      	ldr	r3, [pc, #24]	; (cc0 <list_insert_as_head+0x20>)
     ca8:	4798      	blx	r3
     caa:	2301      	movs	r3, #1
     cac:	4058      	eors	r0, r3
     cae:	b2c0      	uxtb	r0, r0
     cb0:	2239      	movs	r2, #57	; 0x39
     cb2:	4904      	ldr	r1, [pc, #16]	; (cc4 <list_insert_as_head+0x24>)
     cb4:	4b04      	ldr	r3, [pc, #16]	; (cc8 <list_insert_as_head+0x28>)
     cb6:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
     cb8:	6823      	ldr	r3, [r4, #0]
     cba:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
     cbc:	6025      	str	r5, [r4, #0]
}
     cbe:	bd70      	pop	{r4, r5, r6, pc}
     cc0:	00000c89 	.word	0x00000c89
     cc4:	00002264 	.word	0x00002264
     cc8:	00000c81 	.word	0x00000c81

00000ccc <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
     ccc:	6803      	ldr	r3, [r0, #0]
     cce:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
     cd0:	6001      	str	r1, [r0, #0]
}
     cd2:	4770      	bx	lr

00000cd4 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
     cd4:	6803      	ldr	r3, [r0, #0]
     cd6:	2b00      	cmp	r3, #0
     cd8:	d003      	beq.n	ce2 <list_remove_head+0xe>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
     cda:	681a      	ldr	r2, [r3, #0]
     cdc:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
     cde:	0018      	movs	r0, r3
	}

	return NULL;
}
     ce0:	4770      	bx	lr
	return NULL;
     ce2:	2000      	movs	r0, #0
     ce4:	e7fc      	b.n	ce0 <list_remove_head+0xc>
	...

00000ce8 <_can_async_init>:

/**
 * \brief Initialize CAN.
 */
int32_t _can_async_init(struct _can_async_device *const dev, void *const hw)
{
     ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
	dev->hw = hw;
     cea:	6001      	str	r1, [r0, #0]
}

static inline void hri_can_set_CCCR_INIT_bit(const void *const hw)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= CAN_CCCR_INIT;
     cec:	698b      	ldr	r3, [r1, #24]
     cee:	2201      	movs	r2, #1
     cf0:	4313      	orrs	r3, r2
     cf2:	618b      	str	r3, [r1, #24]
	hri_can_set_CCCR_INIT_bit(dev->hw);
	while (hri_can_get_CCCR_INIT_bit(dev->hw) == 0)
     cf4:	6803      	ldr	r3, [r0, #0]
}

static inline bool hri_can_get_CCCR_INIT_bit(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Can *)hw)->CCCR.reg;
     cf6:	699a      	ldr	r2, [r3, #24]
     cf8:	07d2      	lsls	r2, r2, #31
     cfa:	d5fb      	bpl.n	cf4 <_can_async_init+0xc>
}

static inline void hri_can_set_CCCR_CCE_bit(const void *const hw)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= CAN_CCCR_CCE;
     cfc:	699a      	ldr	r2, [r3, #24]
     cfe:	2402      	movs	r4, #2
     d00:	4322      	orrs	r2, r4
     d02:	619a      	str	r2, [r3, #24]
		;
	hri_can_set_CCCR_CCE_bit(dev->hw);

#ifdef CONF_CAN0_ENABLED
	if (hw == CAN0) {
     d04:	4b64      	ldr	r3, [pc, #400]	; (e98 <_can_async_init+0x1b0>)
     d06:	4299      	cmp	r1, r3
     d08:	d012      	beq.n	d30 <_can_async_init+0x48>
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
	}
#endif

#ifdef CONF_CAN1_ENABLED
	if (hw == CAN1) {
     d0a:	4b64      	ldr	r3, [pc, #400]	; (e9c <_can_async_init+0x1b4>)
     d0c:	4299      	cmp	r1, r3
     d0e:	d069      	beq.n	de4 <_can_async_init+0xfc>
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
	}
#endif

	/* Disable CCE to prevent Configuration Change */
	hri_can_clear_CCCR_CCE_bit(dev->hw);
     d10:	6802      	ldr	r2, [r0, #0]
}

static inline void hri_can_clear_CCCR_CCE_bit(const void *const hw)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_CCE;
     d12:	6993      	ldr	r3, [r2, #24]
     d14:	2102      	movs	r1, #2
     d16:	438b      	bics	r3, r1
     d18:	6193      	str	r3, [r2, #24]
	hri_can_clear_CCCR_INIT_bit(dev->hw);
     d1a:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_INIT;
     d1c:	6993      	ldr	r3, [r2, #24]
     d1e:	3901      	subs	r1, #1
     d20:	438b      	bics	r3, r1
     d22:	6193      	str	r3, [r2, #24]
	while (hri_can_get_CCCR_INIT_bit(dev->hw)) {
     d24:	6803      	ldr	r3, [r0, #0]
	tmp = ((Can *)hw)->CCCR.reg;
     d26:	699b      	ldr	r3, [r3, #24]
     d28:	07db      	lsls	r3, r3, #31
     d2a:	d4fb      	bmi.n	d24 <_can_async_init+0x3c>
	};

	return ERR_NONE;
}
     d2c:	2000      	movs	r0, #0
     d2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		_can0_dev    = dev;
     d30:	4b5b      	ldr	r3, [pc, #364]	; (ea0 <_can_async_init+0x1b8>)
     d32:	001a      	movs	r2, r3
     d34:	c201      	stmia	r2!, {r0}
		dev->context = (void *)&_can0_context;
     d36:	4c5b      	ldr	r4, [pc, #364]	; (ea4 <_can_async_init+0x1bc>)
     d38:	6184      	str	r4, [r0, #24]
		hri_can_set_CCCR_reg(dev->hw, CONF_CAN0_CCCR_REG);
     d3a:	6804      	ldr	r4, [r0, #0]
}

static inline void hri_can_set_CCCR_reg(const void *const hw, hri_can_cccr_reg_t mask)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= mask;
     d3c:	69a5      	ldr	r5, [r4, #24]
     d3e:	61a5      	str	r5, [r4, #24]
		hri_can_write_MRCFG_reg(dev->hw, CONF_CAN0_MRCFG_REG);
     d40:	6804      	ldr	r4, [r0, #0]
	((Can *)hw)->MRCFG.reg = data;
     d42:	2600      	movs	r6, #0
     d44:	60a6      	str	r6, [r4, #8]
		hri_can_write_NBTP_reg(dev->hw, CONF_CAN0_BTP_REG);
     d46:	6804      	ldr	r4, [r0, #0]
}

static inline void hri_can_write_NBTP_reg(const void *const hw, hri_can_nbtp_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->NBTP.reg = data;
     d48:	4d57      	ldr	r5, [pc, #348]	; (ea8 <_can_async_init+0x1c0>)
     d4a:	61e5      	str	r5, [r4, #28]
		hri_can_write_DBTP_reg(dev->hw, CONF_CAN0_DBTP_REG);
     d4c:	6804      	ldr	r4, [r0, #0]
	((Can *)hw)->DBTP.reg = data;
     d4e:	4d57      	ldr	r5, [pc, #348]	; (eac <_can_async_init+0x1c4>)
     d50:	60e5      	str	r5, [r4, #12]
		hri_can_write_RXF0C_reg(dev->hw, CONF_CAN0_RXF0C_REG | CAN_RXF0C_F0SA((uint32_t)can0_rx_fifo));
     d52:	4c57      	ldr	r4, [pc, #348]	; (eb0 <_can_async_init+0x1c8>)
     d54:	0424      	lsls	r4, r4, #16
     d56:	0c24      	lsrs	r4, r4, #16
     d58:	4d56      	ldr	r5, [pc, #344]	; (eb4 <_can_async_init+0x1cc>)
     d5a:	432c      	orrs	r4, r5
}

static inline void hri_can_write_RXF0C_reg(const void *const hw, hri_can_rxf0c_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->RXF0C.reg = data;
     d5c:	25a0      	movs	r5, #160	; 0xa0
     d5e:	6807      	ldr	r7, [r0, #0]
     d60:	517c      	str	r4, [r7, r5]
}

static inline void hri_can_write_RXESC_reg(const void *const hw, hri_can_rxesc_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->RXESC.reg = data;
     d62:	3d99      	subs	r5, #153	; 0x99
     d64:	24bc      	movs	r4, #188	; 0xbc
     d66:	6807      	ldr	r7, [r0, #0]
     d68:	513d      	str	r5, [r7, r4]
}

static inline void hri_can_write_TXESC_reg(const void *const hw, hri_can_txesc_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->TXESC.reg = data;
     d6a:	340c      	adds	r4, #12
     d6c:	6805      	ldr	r5, [r0, #0]
     d6e:	512e      	str	r6, [r5, r4]
		hri_can_write_TXBC_reg(dev->hw, CONF_CAN0_TXBC_REG | CAN_TXBC_TBSA((uint32_t)can0_tx_fifo));
     d70:	4c51      	ldr	r4, [pc, #324]	; (eb8 <_can_async_init+0x1d0>)
     d72:	0424      	lsls	r4, r4, #16
     d74:	0c24      	lsrs	r4, r4, #16
     d76:	2580      	movs	r5, #128	; 0x80
     d78:	04ad      	lsls	r5, r5, #18
     d7a:	432c      	orrs	r4, r5
	((Can *)hw)->TXBC.reg = data;
     d7c:	25c0      	movs	r5, #192	; 0xc0
     d7e:	6806      	ldr	r6, [r0, #0]
     d80:	5174      	str	r4, [r6, r5]
		hri_can_write_TXEFC_reg(dev->hw, CONF_CAN0_TXEFC_REG | CAN_TXEFC_EFSA((uint32_t)can0_tx_event_fifo));
     d82:	0412      	lsls	r2, r2, #16
     d84:	0c12      	lsrs	r2, r2, #16
     d86:	2480      	movs	r4, #128	; 0x80
     d88:	02a4      	lsls	r4, r4, #10
     d8a:	4322      	orrs	r2, r4
}

static inline void hri_can_write_TXEFC_reg(const void *const hw, hri_can_txefc_reg_t data)
{
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->TXEFC.reg = data;
     d8c:	3530      	adds	r5, #48	; 0x30
     d8e:	6806      	ldr	r6, [r0, #0]
     d90:	5172      	str	r2, [r6, r5]
	((Can *)hw)->GFC.reg = data;
     d92:	3d70      	subs	r5, #112	; 0x70
     d94:	2228      	movs	r2, #40	; 0x28
     d96:	6806      	ldr	r6, [r0, #0]
     d98:	5172      	str	r2, [r6, r5]
		hri_can_write_SIDFC_reg(dev->hw, CONF_CAN0_SIDFC_REG | CAN_SIDFC_FLSSA((uint32_t)can0_rx_std_filter));
     d9a:	001a      	movs	r2, r3
     d9c:	3214      	adds	r2, #20
     d9e:	0412      	lsls	r2, r2, #16
     da0:	0c12      	lsrs	r2, r2, #16
     da2:	4322      	orrs	r2, r4
	((Can *)hw)->SIDFC.reg = data;
     da4:	2484      	movs	r4, #132	; 0x84
     da6:	6806      	ldr	r6, [r0, #0]
     da8:	5132      	str	r2, [r6, r4]
		hri_can_write_XIDFC_reg(dev->hw, CONF_CAN0_XIDFC_REG | CAN_XIDFC_FLESA((uint32_t)can0_rx_ext_filter));
     daa:	331c      	adds	r3, #28
     dac:	041b      	lsls	r3, r3, #16
     dae:	0c1b      	lsrs	r3, r3, #16
     db0:	22a0      	movs	r2, #160	; 0xa0
     db2:	0312      	lsls	r2, r2, #12
     db4:	4313      	orrs	r3, r2
	((Can *)hw)->XIDFC.reg = data;
     db6:	2288      	movs	r2, #136	; 0x88
     db8:	6804      	ldr	r4, [r0, #0]
     dba:	50a3      	str	r3, [r4, r2]
	((Can *)hw)->XIDAM.reg = data;
     dbc:	4a3f      	ldr	r2, [pc, #252]	; (ebc <_can_async_init+0x1d4>)
     dbe:	2390      	movs	r3, #144	; 0x90
     dc0:	6804      	ldr	r4, [r0, #0]
     dc2:	50e2      	str	r2, [r4, r3]
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     dc4:	4b3e      	ldr	r3, [pc, #248]	; (ec0 <_can_async_init+0x1d8>)
     dc6:	2280      	movs	r2, #128	; 0x80
     dc8:	0212      	lsls	r2, r2, #8
     dca:	515a      	str	r2, [r3, r5]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     dcc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     dd0:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     dd4:	24c0      	movs	r4, #192	; 0xc0
     dd6:	0064      	lsls	r4, r4, #1
     dd8:	511a      	str	r2, [r3, r4]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     dda:	601a      	str	r2, [r3, #0]
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
     ddc:	6803      	ldr	r3, [r0, #0]
	((Can *)hw)->ILE.reg = data;
     dde:	2201      	movs	r2, #1
     de0:	65da      	str	r2, [r3, #92]	; 0x5c
     de2:	e792      	b.n	d0a <_can_async_init+0x22>
		_can1_dev    = dev;
     de4:	4b2e      	ldr	r3, [pc, #184]	; (ea0 <_can_async_init+0x1b8>)
     de6:	66d8      	str	r0, [r3, #108]	; 0x6c
		dev->context = (void *)&_can1_context;
     de8:	4a2e      	ldr	r2, [pc, #184]	; (ea4 <_can_async_init+0x1bc>)
     dea:	3214      	adds	r2, #20
     dec:	6182      	str	r2, [r0, #24]
		hri_can_set_CCCR_reg(dev->hw, CONF_CAN1_CCCR_REG);
     dee:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->CCCR.reg |= mask;
     df0:	6991      	ldr	r1, [r2, #24]
     df2:	6191      	str	r1, [r2, #24]
		hri_can_write_MRCFG_reg(dev->hw, CONF_CAN1_MRCFG_REG);
     df4:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->MRCFG.reg = data;
     df6:	2100      	movs	r1, #0
     df8:	6091      	str	r1, [r2, #8]
		hri_can_write_NBTP_reg(dev->hw, CONF_CAN1_BTP_REG);
     dfa:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->NBTP.reg = data;
     dfc:	4c2a      	ldr	r4, [pc, #168]	; (ea8 <_can_async_init+0x1c0>)
     dfe:	61d4      	str	r4, [r2, #28]
		hri_can_write_DBTP_reg(dev->hw, CONF_CAN1_DBTP_REG);
     e00:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->DBTP.reg = data;
     e02:	4c2a      	ldr	r4, [pc, #168]	; (eac <_can_async_init+0x1c4>)
     e04:	60d4      	str	r4, [r2, #12]
		hri_can_write_RXF0C_reg(dev->hw, CONF_CAN1_RXF0C_REG | CAN_RXF0C_F0SA((uint32_t)can1_rx_fifo));
     e06:	4a2f      	ldr	r2, [pc, #188]	; (ec4 <_can_async_init+0x1dc>)
     e08:	0412      	lsls	r2, r2, #16
     e0a:	0c12      	lsrs	r2, r2, #16
     e0c:	4c29      	ldr	r4, [pc, #164]	; (eb4 <_can_async_init+0x1cc>)
     e0e:	4322      	orrs	r2, r4
	((Can *)hw)->RXF0C.reg = data;
     e10:	24a0      	movs	r4, #160	; 0xa0
     e12:	6805      	ldr	r5, [r0, #0]
     e14:	512a      	str	r2, [r5, r4]
	((Can *)hw)->RXESC.reg = data;
     e16:	22bc      	movs	r2, #188	; 0xbc
     e18:	6804      	ldr	r4, [r0, #0]
     e1a:	50a1      	str	r1, [r4, r2]
	((Can *)hw)->TXESC.reg = data;
     e1c:	320c      	adds	r2, #12
     e1e:	6804      	ldr	r4, [r0, #0]
     e20:	50a1      	str	r1, [r4, r2]
		hri_can_write_TXBC_reg(dev->hw, CONF_CAN1_TXBC_REG | CAN_TXBC_TBSA((uint32_t)can1_tx_fifo));
     e22:	4a29      	ldr	r2, [pc, #164]	; (ec8 <_can_async_init+0x1e0>)
     e24:	0412      	lsls	r2, r2, #16
     e26:	0c12      	lsrs	r2, r2, #16
     e28:	2180      	movs	r1, #128	; 0x80
     e2a:	0489      	lsls	r1, r1, #18
     e2c:	430a      	orrs	r2, r1
	((Can *)hw)->TXBC.reg = data;
     e2e:	21c0      	movs	r1, #192	; 0xc0
     e30:	6804      	ldr	r4, [r0, #0]
     e32:	5062      	str	r2, [r4, r1]
		hri_can_write_TXEFC_reg(dev->hw, CONF_CAN1_TXEFC_REG | CAN_TXEFC_EFSA((uint32_t)can1_tx_event_fifo));
     e34:	3370      	adds	r3, #112	; 0x70
     e36:	041b      	lsls	r3, r3, #16
     e38:	0c1b      	lsrs	r3, r3, #16
     e3a:	2280      	movs	r2, #128	; 0x80
     e3c:	0292      	lsls	r2, r2, #10
     e3e:	4313      	orrs	r3, r2
	((Can *)hw)->TXEFC.reg = data;
     e40:	3130      	adds	r1, #48	; 0x30
     e42:	6804      	ldr	r4, [r0, #0]
     e44:	5063      	str	r3, [r4, r1]
	((Can *)hw)->GFC.reg = data;
     e46:	2480      	movs	r4, #128	; 0x80
     e48:	2328      	movs	r3, #40	; 0x28
     e4a:	6801      	ldr	r1, [r0, #0]
     e4c:	510b      	str	r3, [r1, r4]
		hri_can_write_SIDFC_reg(dev->hw, CONF_CAN1_SIDFC_REG | CAN_SIDFC_FLSSA((uint32_t)can1_rx_std_filter));
     e4e:	4b1f      	ldr	r3, [pc, #124]	; (ecc <_can_async_init+0x1e4>)
     e50:	0419      	lsls	r1, r3, #16
     e52:	0c09      	lsrs	r1, r1, #16
     e54:	430a      	orrs	r2, r1
	((Can *)hw)->SIDFC.reg = data;
     e56:	2184      	movs	r1, #132	; 0x84
     e58:	6805      	ldr	r5, [r0, #0]
     e5a:	506a      	str	r2, [r5, r1]
		hri_can_write_XIDFC_reg(dev->hw, CONF_CAN1_XIDFC_REG | CAN_XIDFC_FLESA((uint32_t)can1_rx_ext_filter));
     e5c:	3308      	adds	r3, #8
     e5e:	041b      	lsls	r3, r3, #16
     e60:	0c1b      	lsrs	r3, r3, #16
     e62:	22a0      	movs	r2, #160	; 0xa0
     e64:	0312      	lsls	r2, r2, #12
     e66:	4313      	orrs	r3, r2
	((Can *)hw)->XIDFC.reg = data;
     e68:	2288      	movs	r2, #136	; 0x88
     e6a:	6801      	ldr	r1, [r0, #0]
     e6c:	508b      	str	r3, [r1, r2]
	((Can *)hw)->XIDAM.reg = data;
     e6e:	4a13      	ldr	r2, [pc, #76]	; (ebc <_can_async_init+0x1d4>)
     e70:	2390      	movs	r3, #144	; 0x90
     e72:	6801      	ldr	r1, [r0, #0]
     e74:	50ca      	str	r2, [r1, r3]
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     e76:	4b12      	ldr	r3, [pc, #72]	; (ec0 <_can_async_init+0x1d8>)
     e78:	2280      	movs	r2, #128	; 0x80
     e7a:	0252      	lsls	r2, r2, #9
     e7c:	511a      	str	r2, [r3, r4]
  __ASM volatile ("dsb 0xF":::"memory");
     e7e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     e82:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     e86:	21c0      	movs	r1, #192	; 0xc0
     e88:	0049      	lsls	r1, r1, #1
     e8a:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     e8c:	601a      	str	r2, [r3, #0]
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
     e8e:	6803      	ldr	r3, [r0, #0]
	((Can *)hw)->ILE.reg = data;
     e90:	2201      	movs	r2, #1
     e92:	65da      	str	r2, [r3, #92]	; 0x5c
     e94:	e73c      	b.n	d10 <_can_async_init+0x28>
     e96:	46c0      	nop			; (mov r8, r8)
     e98:	42001c00 	.word	0x42001c00
     e9c:	42002000 	.word	0x42002000
     ea0:	2000014c 	.word	0x2000014c
     ea4:	20000000 	.word	0x20000000
     ea8:	02000203 	.word	0x02000203
     eac:	00000231 	.word	0x00000231
     eb0:	20000704 	.word	0x20000704
     eb4:	80100000 	.word	0x80100000
     eb8:	20000ca4 	.word	0x20000ca4
     ebc:	1fffffff 	.word	0x1fffffff
     ec0:	e000e100 	.word	0xe000e100
     ec4:	20000ba4 	.word	0x20000ba4
     ec8:	20000b84 	.word	0x20000b84
     ecc:	200001cc 	.word	0x200001cc

00000ed0 <_can_async_enable>:
/**
 * \brief Enable CAN
 */
int32_t _can_async_enable(struct _can_async_device *const dev)
{
	hri_can_clear_CCCR_INIT_bit(dev->hw);
     ed0:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_INIT;
     ed2:	6993      	ldr	r3, [r2, #24]
     ed4:	2101      	movs	r1, #1
     ed6:	438b      	bics	r3, r1
     ed8:	6193      	str	r3, [r2, #24]
	return ERR_NONE;
}
     eda:	2000      	movs	r0, #0
     edc:	4770      	bx	lr
	...

00000ee0 <_can_async_read>:

/**
 * \brief Read a CAN message
 */
int32_t _can_async_read(struct _can_async_device *const dev, struct can_message *msg)
{
     ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
     ee2:	46ce      	mov	lr, r9
     ee4:	4647      	mov	r7, r8
     ee6:	b580      	push	{r7, lr}
     ee8:	b085      	sub	sp, #20
     eea:	4680      	mov	r8, r0
	struct _can_rx_fifo_entry *f = NULL;
	hri_can_rxf0s_reg_t        get_index;

	if (!hri_can_read_RXF0S_F0FL_bf(dev->hw)) {
     eec:	6802      	ldr	r2, [r0, #0]
	return (((Can *)hw)->RXF0S.reg & CAN_RXF0S_F0FL_Msk) >> CAN_RXF0S_F0FL_Pos;
     eee:	23a4      	movs	r3, #164	; 0xa4
     ef0:	58d3      	ldr	r3, [r2, r3]
     ef2:	065b      	lsls	r3, r3, #25
     ef4:	d04f      	beq.n	f96 <_can_async_read+0xb6>
	return (((Can *)hw)->RXF0S.reg & CAN_RXF0S_F0GI_Msk) >> CAN_RXF0S_F0GI_Pos;
     ef6:	23a4      	movs	r3, #164	; 0xa4
     ef8:	58d4      	ldr	r4, [r2, r3]
     efa:	0a24      	lsrs	r4, r4, #8
     efc:	3b65      	subs	r3, #101	; 0x65
     efe:	401c      	ands	r4, r3
     f00:	46a1      	mov	r9, r4
	}

	get_index = hri_can_read_RXF0S_F0GI_bf(dev->hw);

#ifdef CONF_CAN0_ENABLED
	if (dev->hw == CAN0) {
     f02:	4b28      	ldr	r3, [pc, #160]	; (fa4 <_can_async_read+0xc4>)
     f04:	429a      	cmp	r2, r3
     f06:	d031      	beq.n	f6c <_can_async_read+0x8c>
	struct _can_rx_fifo_entry *f = NULL;
     f08:	2300      	movs	r3, #0
		f = (struct _can_rx_fifo_entry *)(can0_rx_fifo + get_index * CONF_CAN0_F0DS);
	}
#endif
#ifdef CONF_CAN1_ENABLED
	if (dev->hw == CAN1) {
     f0a:	4827      	ldr	r0, [pc, #156]	; (fa8 <_can_async_read+0xc8>)
     f0c:	4282      	cmp	r2, r0
     f0e:	d033      	beq.n	f78 <_can_async_read+0x98>
		f = (struct _can_rx_fifo_entry *)(can1_rx_fifo + get_index * CONF_CAN1_F0DS);
	}
#endif

	if (f == NULL) {
     f10:	2b00      	cmp	r3, #0
     f12:	d043      	beq.n	f9c <_can_async_read+0xbc>
		return ERR_NO_RESOURCE;
	}

	if (f->R0.bit.XTD == 1) {
     f14:	681a      	ldr	r2, [r3, #0]
     f16:	0052      	lsls	r2, r2, #1
     f18:	d433      	bmi.n	f82 <_can_async_read+0xa2>
		msg->fmt = CAN_FMT_EXTID;
		msg->id  = f->R0.bit.ID;
	} else {
		msg->fmt = CAN_FMT_STDID;
     f1a:	2200      	movs	r2, #0
     f1c:	734a      	strb	r2, [r1, #13]
		/* A standard identifier is stored into ID[28:18] */
		msg->id = f->R0.bit.ID >> 18;
     f1e:	681a      	ldr	r2, [r3, #0]
     f20:	00d2      	lsls	r2, r2, #3
     f22:	0d52      	lsrs	r2, r2, #21
     f24:	600a      	str	r2, [r1, #0]
	}

	if (f->R0.bit.RTR == 1) {
     f26:	681a      	ldr	r2, [r3, #0]
     f28:	0092      	lsls	r2, r2, #2
     f2a:	d431      	bmi.n	f90 <_can_async_read+0xb0>
		msg->type = CAN_TYPE_REMOTE;
	}

	const uint8_t dlc2len[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 32, 48, 64};
     f2c:	466a      	mov	r2, sp
     f2e:	481f      	ldr	r0, [pc, #124]	; (fac <_can_async_read+0xcc>)
     f30:	466e      	mov	r6, sp
     f32:	c8b0      	ldmia	r0!, {r4, r5, r7}
     f34:	c6b0      	stmia	r6!, {r4, r5, r7}
     f36:	6800      	ldr	r0, [r0, #0]
     f38:	6030      	str	r0, [r6, #0]
	msg->len                = dlc2len[f->R1.bit.DLC];
     f3a:	6858      	ldr	r0, [r3, #4]
     f3c:	0300      	lsls	r0, r0, #12
     f3e:	0f00      	lsrs	r0, r0, #28
     f40:	5c12      	ldrb	r2, [r2, r0]
     f42:	730a      	strb	r2, [r1, #12]

	memcpy(msg->data, f->data, msg->len);
     f44:	6888      	ldr	r0, [r1, #8]
     f46:	3308      	adds	r3, #8
     f48:	0019      	movs	r1, r3
     f4a:	4b19      	ldr	r3, [pc, #100]	; (fb0 <_can_async_read+0xd0>)
     f4c:	4798      	blx	r3

	hri_can_write_RXF0A_F0AI_bf(dev->hw, get_index);
     f4e:	4643      	mov	r3, r8
     f50:	6819      	ldr	r1, [r3, #0]
	tmp = ((Can *)hw)->RXF0A.reg;
     f52:	22a8      	movs	r2, #168	; 0xa8
     f54:	588b      	ldr	r3, [r1, r2]
	tmp &= ~CAN_RXF0A_F0AI_Msk;
     f56:	203f      	movs	r0, #63	; 0x3f
     f58:	4383      	bics	r3, r0
	tmp |= CAN_RXF0A_F0AI(data);
     f5a:	464c      	mov	r4, r9
     f5c:	431c      	orrs	r4, r3
	((Can *)hw)->RXF0A.reg = tmp;
     f5e:	508c      	str	r4, [r1, r2]

	return ERR_NONE;
     f60:	2000      	movs	r0, #0
}
     f62:	b005      	add	sp, #20
     f64:	bc0c      	pop	{r2, r3}
     f66:	4690      	mov	r8, r2
     f68:	4699      	mov	r9, r3
     f6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		f = (struct _can_rx_fifo_entry *)(can0_rx_fifo + get_index * CONF_CAN0_F0DS);
     f6c:	00e0      	lsls	r0, r4, #3
     f6e:	4448      	add	r0, r9
     f70:	00c3      	lsls	r3, r0, #3
     f72:	4810      	ldr	r0, [pc, #64]	; (fb4 <_can_async_read+0xd4>)
     f74:	181b      	adds	r3, r3, r0
     f76:	e7c8      	b.n	f0a <_can_async_read+0x2a>
		f = (struct _can_rx_fifo_entry *)(can1_rx_fifo + get_index * CONF_CAN1_F0DS);
     f78:	464b      	mov	r3, r9
     f7a:	011b      	lsls	r3, r3, #4
     f7c:	4a0e      	ldr	r2, [pc, #56]	; (fb8 <_can_async_read+0xd8>)
     f7e:	189b      	adds	r3, r3, r2
     f80:	e7c6      	b.n	f10 <_can_async_read+0x30>
		msg->fmt = CAN_FMT_EXTID;
     f82:	2201      	movs	r2, #1
     f84:	734a      	strb	r2, [r1, #13]
		msg->id  = f->R0.bit.ID;
     f86:	681a      	ldr	r2, [r3, #0]
     f88:	00d2      	lsls	r2, r2, #3
     f8a:	08d2      	lsrs	r2, r2, #3
     f8c:	600a      	str	r2, [r1, #0]
     f8e:	e7ca      	b.n	f26 <_can_async_read+0x46>
		msg->type = CAN_TYPE_REMOTE;
     f90:	2201      	movs	r2, #1
     f92:	710a      	strb	r2, [r1, #4]
     f94:	e7ca      	b.n	f2c <_can_async_read+0x4c>
		return ERR_NOT_FOUND;
     f96:	200a      	movs	r0, #10
     f98:	4240      	negs	r0, r0
     f9a:	e7e2      	b.n	f62 <_can_async_read+0x82>
		return ERR_NO_RESOURCE;
     f9c:	201c      	movs	r0, #28
     f9e:	4240      	negs	r0, r0
     fa0:	e7df      	b.n	f62 <_can_async_read+0x82>
     fa2:	46c0      	nop			; (mov r8, r8)
     fa4:	42001c00 	.word	0x42001c00
     fa8:	42002000 	.word	0x42002000
     fac:	00002284 	.word	0x00002284
     fb0:	000021bd 	.word	0x000021bd
     fb4:	20000704 	.word	0x20000704
     fb8:	20000ba4 	.word	0x20000ba4

00000fbc <_can_async_write>:

/**
 * \brief Write a CAN message
 */
int32_t _can_async_write(struct _can_async_device *const dev, struct can_message *msg)
{
     fbc:	b570      	push	{r4, r5, r6, lr}
     fbe:	0005      	movs	r5, r0
	struct _can_tx_fifo_entry *f = NULL;
	hri_can_txfqs_reg_t        put_index;

	if (hri_can_get_TXFQS_TFQF_bit(dev->hw)) {
     fc0:	6803      	ldr	r3, [r0, #0]
	return (((Can *)hw)->TXFQS.reg & CAN_TXFQS_TFQF) >> CAN_TXFQS_TFQF_Pos;
     fc2:	22c4      	movs	r2, #196	; 0xc4
     fc4:	589a      	ldr	r2, [r3, r2]
     fc6:	0292      	lsls	r2, r2, #10
     fc8:	d500      	bpl.n	fcc <_can_async_write+0x10>
     fca:	e09a      	b.n	1102 <_can_async_write+0x146>
	return (((Can *)hw)->TXFQS.reg & CAN_TXFQS_TFQPI_Msk) >> CAN_TXFQS_TFQPI_Pos;
     fcc:	22c4      	movs	r2, #196	; 0xc4
     fce:	5898      	ldr	r0, [r3, r2]
     fd0:	0c00      	lsrs	r0, r0, #16
     fd2:	3aa5      	subs	r2, #165	; 0xa5
     fd4:	4002      	ands	r2, r0
	}

	put_index = hri_can_read_TXFQS_TFQPI_bf(dev->hw);

#ifdef CONF_CAN0_ENABLED
	if (dev->hw == CAN0) {
     fd6:	484e      	ldr	r0, [pc, #312]	; (1110 <_can_async_write+0x154>)
     fd8:	4283      	cmp	r3, r0
     fda:	d03d      	beq.n	1058 <_can_async_write+0x9c>
	struct _can_tx_fifo_entry *f = NULL;
     fdc:	2000      	movs	r0, #0
		f = (struct _can_tx_fifo_entry *)(can0_tx_fifo + put_index * CONF_CAN0_TBDS);
	}
#endif
#ifdef CONF_CAN1_ENABLED
	if (dev->hw == CAN1) {
     fde:	4c4d      	ldr	r4, [pc, #308]	; (1114 <_can_async_write+0x158>)
     fe0:	42a3      	cmp	r3, r4
     fe2:	d03d      	beq.n	1060 <_can_async_write+0xa4>
		f = (struct _can_tx_fifo_entry *)(can1_tx_fifo + put_index * CONF_CAN1_TBDS);
	}
#endif
	if (f == NULL) {
     fe4:	2800      	cmp	r0, #0
     fe6:	d100      	bne.n	fea <_can_async_write+0x2e>
     fe8:	e08e      	b.n	1108 <_can_async_write+0x14c>
		return ERR_NO_RESOURCE;
	}

	if (msg->fmt == CAN_FMT_EXTID) {
     fea:	7b4b      	ldrb	r3, [r1, #13]
     fec:	2b01      	cmp	r3, #1
     fee:	d03b      	beq.n	1068 <_can_async_write+0xac>
		f->T0.val     = msg->id;
		f->T0.bit.XTD = 1;
	} else {
		/* A standard identifier is stored into ID[28:18] */
		f->T0.val = msg->id << 18;
     ff0:	680b      	ldr	r3, [r1, #0]
     ff2:	049b      	lsls	r3, r3, #18
     ff4:	6003      	str	r3, [r0, #0]
	}

	if (msg->len <= 8) {
     ff6:	7b0a      	ldrb	r2, [r1, #12]
     ff8:	2a08      	cmp	r2, #8
     ffa:	d83d      	bhi.n	1078 <_can_async_write+0xbc>
		f->T1.bit.DLC = msg->len;
     ffc:	6844      	ldr	r4, [r0, #4]
     ffe:	230f      	movs	r3, #15
    1000:	4013      	ands	r3, r2
    1002:	041b      	lsls	r3, r3, #16
    1004:	4a44      	ldr	r2, [pc, #272]	; (1118 <_can_async_write+0x15c>)
    1006:	4014      	ands	r4, r2
    1008:	4323      	orrs	r3, r4
    100a:	6043      	str	r3, [r0, #4]
		f->T1.bit.DLC = 0xE;
	} else if (msg->len <= 64) {
		f->T1.bit.DLC = 0xF;
	}

	f->T1.bit.FDF = hri_can_get_CCCR_FDOE_bit(dev->hw);
    100c:	682b      	ldr	r3, [r5, #0]
	tmp = ((Can *)hw)->CCCR.reg;
    100e:	699b      	ldr	r3, [r3, #24]
	tmp = (tmp & CAN_CCCR_FDOE) >> CAN_CCCR_FDOE_Pos;
    1010:	0a1b      	lsrs	r3, r3, #8
    1012:	2401      	movs	r4, #1
    1014:	6842      	ldr	r2, [r0, #4]
    1016:	4023      	ands	r3, r4
    1018:	055b      	lsls	r3, r3, #21
    101a:	4e40      	ldr	r6, [pc, #256]	; (111c <_can_async_write+0x160>)
    101c:	4032      	ands	r2, r6
    101e:	4313      	orrs	r3, r2
    1020:	6043      	str	r3, [r0, #4]
	f->T1.bit.BRS = hri_can_get_CCCR_BRSE_bit(dev->hw);
    1022:	682b      	ldr	r3, [r5, #0]
	tmp = ((Can *)hw)->CCCR.reg;
    1024:	699b      	ldr	r3, [r3, #24]
	tmp = (tmp & CAN_CCCR_BRSE) >> CAN_CCCR_BRSE_Pos;
    1026:	0a5b      	lsrs	r3, r3, #9
    1028:	6842      	ldr	r2, [r0, #4]
    102a:	4023      	ands	r3, r4
    102c:	051b      	lsls	r3, r3, #20
    102e:	4e3c      	ldr	r6, [pc, #240]	; (1120 <_can_async_write+0x164>)
    1030:	4032      	ands	r2, r6
    1032:	4313      	orrs	r3, r2
    1034:	6043      	str	r3, [r0, #4]

	memcpy(f->data, msg->data, msg->len);
    1036:	3008      	adds	r0, #8
    1038:	688b      	ldr	r3, [r1, #8]
    103a:	7b0a      	ldrb	r2, [r1, #12]
    103c:	0019      	movs	r1, r3
    103e:	4b39      	ldr	r3, [pc, #228]	; (1124 <_can_async_write+0x168>)
    1040:	4798      	blx	r3

	hri_can_write_TXBAR_reg(dev->hw, 1 << hri_can_read_TXFQS_TFQPI_bf(dev->hw));
    1042:	6829      	ldr	r1, [r5, #0]
	return (((Can *)hw)->TXFQS.reg & CAN_TXFQS_TFQPI_Msk) >> CAN_TXFQS_TFQPI_Pos;
    1044:	23c4      	movs	r3, #196	; 0xc4
    1046:	58ca      	ldr	r2, [r1, r3]
    1048:	0c12      	lsrs	r2, r2, #16
    104a:	3ba5      	subs	r3, #165	; 0xa5
    104c:	4013      	ands	r3, r2
    104e:	409c      	lsls	r4, r3
	((Can *)hw)->TXBAR.reg = data;
    1050:	23d0      	movs	r3, #208	; 0xd0
    1052:	50cc      	str	r4, [r1, r3]
	return ERR_NONE;
    1054:	2000      	movs	r0, #0
}
    1056:	bd70      	pop	{r4, r5, r6, pc}
		f = (struct _can_tx_fifo_entry *)(can0_tx_fifo + put_index * CONF_CAN0_TBDS);
    1058:	0114      	lsls	r4, r2, #4
    105a:	4e33      	ldr	r6, [pc, #204]	; (1128 <_can_async_write+0x16c>)
    105c:	19a0      	adds	r0, r4, r6
    105e:	e7be      	b.n	fde <_can_async_write+0x22>
		f = (struct _can_tx_fifo_entry *)(can1_tx_fifo + put_index * CONF_CAN1_TBDS);
    1060:	0112      	lsls	r2, r2, #4
    1062:	4832      	ldr	r0, [pc, #200]	; (112c <_can_async_write+0x170>)
    1064:	1810      	adds	r0, r2, r0
    1066:	e7bd      	b.n	fe4 <_can_async_write+0x28>
		f->T0.val     = msg->id;
    1068:	680b      	ldr	r3, [r1, #0]
    106a:	6003      	str	r3, [r0, #0]
		f->T0.bit.XTD = 1;
    106c:	6802      	ldr	r2, [r0, #0]
    106e:	2380      	movs	r3, #128	; 0x80
    1070:	05db      	lsls	r3, r3, #23
    1072:	4313      	orrs	r3, r2
    1074:	6003      	str	r3, [r0, #0]
    1076:	e7be      	b.n	ff6 <_can_async_write+0x3a>
	} else if (msg->len <= 12) {
    1078:	2a0c      	cmp	r2, #12
    107a:	d807      	bhi.n	108c <_can_async_write+0xd0>
		f->T1.bit.DLC = 0x9;
    107c:	6842      	ldr	r2, [r0, #4]
    107e:	4b26      	ldr	r3, [pc, #152]	; (1118 <_can_async_write+0x15c>)
    1080:	401a      	ands	r2, r3
    1082:	2390      	movs	r3, #144	; 0x90
    1084:	031b      	lsls	r3, r3, #12
    1086:	4313      	orrs	r3, r2
    1088:	6043      	str	r3, [r0, #4]
    108a:	e7bf      	b.n	100c <_can_async_write+0x50>
	} else if (msg->len <= 16) {
    108c:	2a10      	cmp	r2, #16
    108e:	d807      	bhi.n	10a0 <_can_async_write+0xe4>
		f->T1.bit.DLC = 0xA;
    1090:	6842      	ldr	r2, [r0, #4]
    1092:	4b21      	ldr	r3, [pc, #132]	; (1118 <_can_async_write+0x15c>)
    1094:	401a      	ands	r2, r3
    1096:	23a0      	movs	r3, #160	; 0xa0
    1098:	031b      	lsls	r3, r3, #12
    109a:	4313      	orrs	r3, r2
    109c:	6043      	str	r3, [r0, #4]
    109e:	e7b5      	b.n	100c <_can_async_write+0x50>
	} else if (msg->len <= 20) {
    10a0:	2a14      	cmp	r2, #20
    10a2:	d807      	bhi.n	10b4 <_can_async_write+0xf8>
		f->T1.bit.DLC = 0xB;
    10a4:	6842      	ldr	r2, [r0, #4]
    10a6:	4b1c      	ldr	r3, [pc, #112]	; (1118 <_can_async_write+0x15c>)
    10a8:	401a      	ands	r2, r3
    10aa:	23b0      	movs	r3, #176	; 0xb0
    10ac:	031b      	lsls	r3, r3, #12
    10ae:	4313      	orrs	r3, r2
    10b0:	6043      	str	r3, [r0, #4]
    10b2:	e7ab      	b.n	100c <_can_async_write+0x50>
	} else if (msg->len <= 24) {
    10b4:	2a18      	cmp	r2, #24
    10b6:	d807      	bhi.n	10c8 <_can_async_write+0x10c>
		f->T1.bit.DLC = 0xC;
    10b8:	6842      	ldr	r2, [r0, #4]
    10ba:	4b17      	ldr	r3, [pc, #92]	; (1118 <_can_async_write+0x15c>)
    10bc:	401a      	ands	r2, r3
    10be:	23c0      	movs	r3, #192	; 0xc0
    10c0:	031b      	lsls	r3, r3, #12
    10c2:	4313      	orrs	r3, r2
    10c4:	6043      	str	r3, [r0, #4]
    10c6:	e7a1      	b.n	100c <_can_async_write+0x50>
	} else if (msg->len <= 32) {
    10c8:	2a20      	cmp	r2, #32
    10ca:	d807      	bhi.n	10dc <_can_async_write+0x120>
		f->T1.bit.DLC = 0xD;
    10cc:	6842      	ldr	r2, [r0, #4]
    10ce:	4b12      	ldr	r3, [pc, #72]	; (1118 <_can_async_write+0x15c>)
    10d0:	401a      	ands	r2, r3
    10d2:	23d0      	movs	r3, #208	; 0xd0
    10d4:	031b      	lsls	r3, r3, #12
    10d6:	4313      	orrs	r3, r2
    10d8:	6043      	str	r3, [r0, #4]
    10da:	e797      	b.n	100c <_can_async_write+0x50>
	} else if (msg->len <= 48) {
    10dc:	2a30      	cmp	r2, #48	; 0x30
    10de:	d807      	bhi.n	10f0 <_can_async_write+0x134>
		f->T1.bit.DLC = 0xE;
    10e0:	6842      	ldr	r2, [r0, #4]
    10e2:	4b0d      	ldr	r3, [pc, #52]	; (1118 <_can_async_write+0x15c>)
    10e4:	401a      	ands	r2, r3
    10e6:	23e0      	movs	r3, #224	; 0xe0
    10e8:	031b      	lsls	r3, r3, #12
    10ea:	4313      	orrs	r3, r2
    10ec:	6043      	str	r3, [r0, #4]
    10ee:	e78d      	b.n	100c <_can_async_write+0x50>
	} else if (msg->len <= 64) {
    10f0:	2a40      	cmp	r2, #64	; 0x40
    10f2:	d900      	bls.n	10f6 <_can_async_write+0x13a>
    10f4:	e78a      	b.n	100c <_can_async_write+0x50>
		f->T1.bit.DLC = 0xF;
    10f6:	6842      	ldr	r2, [r0, #4]
    10f8:	23f0      	movs	r3, #240	; 0xf0
    10fa:	031b      	lsls	r3, r3, #12
    10fc:	4313      	orrs	r3, r2
    10fe:	6043      	str	r3, [r0, #4]
    1100:	e784      	b.n	100c <_can_async_write+0x50>
		return ERR_NO_RESOURCE;
    1102:	201c      	movs	r0, #28
    1104:	4240      	negs	r0, r0
    1106:	e7a6      	b.n	1056 <_can_async_write+0x9a>
		return ERR_NO_RESOURCE;
    1108:	201c      	movs	r0, #28
    110a:	4240      	negs	r0, r0
    110c:	e7a3      	b.n	1056 <_can_async_write+0x9a>
    110e:	46c0      	nop			; (mov r8, r8)
    1110:	42001c00 	.word	0x42001c00
    1114:	42002000 	.word	0x42002000
    1118:	fff0ffff 	.word	0xfff0ffff
    111c:	ffdfffff 	.word	0xffdfffff
    1120:	ffefffff 	.word	0xffefffff
    1124:	000021bd 	.word	0x000021bd
    1128:	20000ca4 	.word	0x20000ca4
    112c:	20000b84 	.word	0x20000b84

00001130 <_can_async_set_irq_state>:

/**
 * \brief Set CAN Interrupt State
 */
void _can_async_set_irq_state(struct _can_async_device *const dev, enum can_async_callback_type type, bool state)
{
    1130:	b510      	push	{r4, lr}
	uint32_t ie;

	if (type == CAN_ASYNC_RX_CB) {
    1132:	2900      	cmp	r1, #0
    1134:	d00b      	beq.n	114e <_can_async_set_irq_state+0x1e>
		hri_can_write_IE_RF0NE_bit(dev->hw, state);
	} else if (type == CAN_ASYNC_TX_CB) {
    1136:	2901      	cmp	r1, #1
    1138:	d010      	beq.n	115c <_can_async_set_irq_state+0x2c>
		hri_can_write_IE_TCE_bit(dev->hw, state);
		hri_can_write_TXBTIE_reg(dev->hw, CAN_TXBTIE_MASK);
	} else if (type == CAN_ASYNC_IRQ_CB) {
    113a:	2902      	cmp	r1, #2
    113c:	d10d      	bne.n	115a <_can_async_set_irq_state+0x2a>
		ie = hri_can_get_IE_reg(dev->hw, CAN_IE_RF0NE | CAN_IE_TCE);
    113e:	6801      	ldr	r1, [r0, #0]
	tmp = ((Can *)hw)->IE.reg;
    1140:	6d4b      	ldr	r3, [r1, #84]	; 0x54
	tmp &= mask;
    1142:	4a0d      	ldr	r2, [pc, #52]	; (1178 <_can_async_set_irq_state+0x48>)
    1144:	401a      	ands	r2, r3
		hri_can_write_IE_reg(dev->hw, ie | CONF_CAN0_IE_REG);
    1146:	4b0d      	ldr	r3, [pc, #52]	; (117c <_can_async_set_irq_state+0x4c>)
    1148:	4313      	orrs	r3, r2
	((Can *)hw)->IE.reg = data;
    114a:	654b      	str	r3, [r1, #84]	; 0x54
	}

	return;
    114c:	e005      	b.n	115a <_can_async_set_irq_state+0x2a>
		hri_can_write_IE_RF0NE_bit(dev->hw, state);
    114e:	6801      	ldr	r1, [r0, #0]
	tmp = ((Can *)hw)->IE.reg;
    1150:	6d4b      	ldr	r3, [r1, #84]	; 0x54
	tmp &= ~CAN_IE_RF0NE;
    1152:	2001      	movs	r0, #1
    1154:	4383      	bics	r3, r0
	tmp |= value << CAN_IE_RF0NE_Pos;
    1156:	431a      	orrs	r2, r3
	((Can *)hw)->IE.reg = tmp;
    1158:	654a      	str	r2, [r1, #84]	; 0x54
}
    115a:	bd10      	pop	{r4, pc}
		hri_can_write_IE_TCE_bit(dev->hw, state);
    115c:	6801      	ldr	r1, [r0, #0]
	tmp = ((Can *)hw)->IE.reg;
    115e:	6d4b      	ldr	r3, [r1, #84]	; 0x54
	tmp &= ~CAN_IE_TCE;
    1160:	4c07      	ldr	r4, [pc, #28]	; (1180 <_can_async_set_irq_state+0x50>)
    1162:	4023      	ands	r3, r4
	tmp |= value << CAN_IE_TCE_Pos;
    1164:	0252      	lsls	r2, r2, #9
    1166:	431a      	orrs	r2, r3
	((Can *)hw)->IE.reg = tmp;
    1168:	654a      	str	r2, [r1, #84]	; 0x54
		hri_can_write_TXBTIE_reg(dev->hw, CAN_TXBTIE_MASK);
    116a:	6802      	ldr	r2, [r0, #0]
	((Can *)hw)->TXBTIE.reg = data;
    116c:	2101      	movs	r1, #1
    116e:	4249      	negs	r1, r1
    1170:	23e0      	movs	r3, #224	; 0xe0
    1172:	50d1      	str	r1, [r2, r3]
    1174:	e7f1      	b.n	115a <_can_async_set_irq_state+0x2a>
    1176:	46c0      	nop			; (mov r8, r8)
    1178:	00000201 	.word	0x00000201
    117c:	03800008 	.word	0x03800008
    1180:	fffffdff 	.word	0xfffffdff

00001184 <_can_async_set_filter>:
/**
 * \brief Set CAN to the specified mode
 */
int32_t _can_async_set_filter(struct _can_async_device *const dev, uint8_t index, enum can_format fmt,
                              struct can_filter *filter)
{
    1184:	b530      	push	{r4, r5, lr}
	struct _can_standard_message_filter_element *sf;
	struct _can_extended_message_filter_element *ef;

	sf = &((struct _can_context *)dev->context)->rx_std_filter[index];
    1186:	6984      	ldr	r4, [r0, #24]
    1188:	0088      	lsls	r0, r1, #2
    118a:	68e5      	ldr	r5, [r4, #12]
    118c:	46ac      	mov	ip, r5
    118e:	4460      	add	r0, ip
	ef = &((struct _can_context *)dev->context)->rx_ext_filter[index];
    1190:	6924      	ldr	r4, [r4, #16]
    1192:	00c9      	lsls	r1, r1, #3
    1194:	1861      	adds	r1, r4, r1

	if (fmt == CAN_FMT_STDID) {
    1196:	2a00      	cmp	r2, #0
    1198:	d11d      	bne.n	11d6 <_can_async_set_filter+0x52>
		if (filter == NULL) {
    119a:	2b00      	cmp	r3, #0
    119c:	d019      	beq.n	11d2 <_can_async_set_filter+0x4e>
			sf->S0.val = 0;
			return ERR_NONE;
		}
		sf->S0.val       = filter->mask;
    119e:	685a      	ldr	r2, [r3, #4]
    11a0:	6002      	str	r2, [r0, #0]
		sf->S0.bit.SFID1 = filter->id;
    11a2:	681b      	ldr	r3, [r3, #0]
    11a4:	6802      	ldr	r2, [r0, #0]
    11a6:	055b      	lsls	r3, r3, #21
    11a8:	095b      	lsrs	r3, r3, #5
    11aa:	4917      	ldr	r1, [pc, #92]	; (1208 <_can_async_set_filter+0x84>)
    11ac:	400a      	ands	r2, r1
    11ae:	4313      	orrs	r3, r2
    11b0:	6003      	str	r3, [r0, #0]
		sf->S0.bit.SFT   = _CAN_SFT_CLASSIC;
    11b2:	6803      	ldr	r3, [r0, #0]
    11b4:	009b      	lsls	r3, r3, #2
    11b6:	089b      	lsrs	r3, r3, #2
    11b8:	2280      	movs	r2, #128	; 0x80
    11ba:	0612      	lsls	r2, r2, #24
    11bc:	431a      	orrs	r2, r3
    11be:	6002      	str	r2, [r0, #0]
		sf->S0.bit.SFEC  = _CAN_SFEC_STF0M;
    11c0:	6802      	ldr	r2, [r0, #0]
    11c2:	4b12      	ldr	r3, [pc, #72]	; (120c <_can_async_set_filter+0x88>)
    11c4:	401a      	ands	r2, r3
    11c6:	2380      	movs	r3, #128	; 0x80
    11c8:	051b      	lsls	r3, r3, #20
    11ca:	4313      	orrs	r3, r2
    11cc:	6003      	str	r3, [r0, #0]
		ef->F1.val      = filter->mask;
		ef->F1.bit.EFT  = _CAN_EFT_CLASSIC;
	}

	return ERR_NONE;
}
    11ce:	2000      	movs	r0, #0
    11d0:	bd30      	pop	{r4, r5, pc}
			sf->S0.val = 0;
    11d2:	6003      	str	r3, [r0, #0]
			return ERR_NONE;
    11d4:	e7fb      	b.n	11ce <_can_async_set_filter+0x4a>
	} else if (fmt == CAN_FMT_EXTID) {
    11d6:	2a01      	cmp	r2, #1
    11d8:	d1f9      	bne.n	11ce <_can_async_set_filter+0x4a>
		if (filter == NULL) {
    11da:	2b00      	cmp	r3, #0
    11dc:	d012      	beq.n	1204 <_can_async_set_filter+0x80>
		ef->F0.val      = filter->id;
    11de:	681a      	ldr	r2, [r3, #0]
    11e0:	600a      	str	r2, [r1, #0]
		ef->F0.bit.EFEC = _CAN_EFEC_STF0M;
    11e2:	680a      	ldr	r2, [r1, #0]
    11e4:	00d2      	lsls	r2, r2, #3
    11e6:	08d2      	lsrs	r2, r2, #3
    11e8:	2080      	movs	r0, #128	; 0x80
    11ea:	0580      	lsls	r0, r0, #22
    11ec:	4310      	orrs	r0, r2
    11ee:	6008      	str	r0, [r1, #0]
		ef->F1.val      = filter->mask;
    11f0:	685b      	ldr	r3, [r3, #4]
    11f2:	604b      	str	r3, [r1, #4]
		ef->F1.bit.EFT  = _CAN_EFT_CLASSIC;
    11f4:	684b      	ldr	r3, [r1, #4]
    11f6:	009b      	lsls	r3, r3, #2
    11f8:	089b      	lsrs	r3, r3, #2
    11fa:	2280      	movs	r2, #128	; 0x80
    11fc:	0612      	lsls	r2, r2, #24
    11fe:	431a      	orrs	r2, r3
    1200:	604a      	str	r2, [r1, #4]
    1202:	e7e4      	b.n	11ce <_can_async_set_filter+0x4a>
			ef->F0.val = 0;
    1204:	600b      	str	r3, [r1, #0]
			return ERR_NONE;
    1206:	e7e2      	b.n	11ce <_can_async_set_filter+0x4a>
    1208:	f800ffff 	.word	0xf800ffff
    120c:	c7ffffff 	.word	0xc7ffffff

00001210 <CAN0_Handler>:

/*
 * \brief CAN interrupt handler
 */
void CAN0_Handler(void)
{
    1210:	b570      	push	{r4, r5, r6, lr}
	struct _can_async_device *dev = _can0_dev;
    1212:	4b1a      	ldr	r3, [pc, #104]	; (127c <CAN0_Handler+0x6c>)
    1214:	681d      	ldr	r5, [r3, #0]
	uint32_t                  ir;
	ir = hri_can_read_IR_reg(dev->hw);
    1216:	682b      	ldr	r3, [r5, #0]
	return ((Can *)hw)->IR.reg;
    1218:	6d1c      	ldr	r4, [r3, #80]	; 0x50

	if (ir & CAN_IR_RF0N) {
    121a:	07e3      	lsls	r3, r4, #31
    121c:	d414      	bmi.n	1248 <CAN0_Handler+0x38>
		dev->cb.rx_done(dev);
	}

	if (ir & CAN_IR_TC) {
    121e:	05a3      	lsls	r3, r4, #22
    1220:	d416      	bmi.n	1250 <CAN0_Handler+0x40>
		dev->cb.tx_done(dev);
	}

	if (ir & CAN_IR_BO) {
    1222:	01a3      	lsls	r3, r4, #6
    1224:	d418      	bmi.n	1258 <CAN0_Handler+0x48>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
	}

	if (ir & CAN_IR_EW) {
    1226:	01e3      	lsls	r3, r4, #7
    1228:	d41b      	bmi.n	1262 <CAN0_Handler+0x52>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
	}

	if (ir & CAN_IR_EP) {
    122a:	0223      	lsls	r3, r4, #8
    122c:	d507      	bpl.n	123e <CAN0_Handler+0x2e>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
    122e:	68eb      	ldr	r3, [r5, #12]
    1230:	682a      	ldr	r2, [r5, #0]
	return (((Can *)hw)->PSR.reg & CAN_PSR_EP) >> CAN_PSR_EP_Pos;
    1232:	6c52      	ldr	r2, [r2, #68]	; 0x44
    1234:	0692      	lsls	r2, r2, #26
    1236:	d519      	bpl.n	126c <CAN0_Handler+0x5c>
    1238:	2102      	movs	r1, #2
    123a:	0028      	movs	r0, r5
    123c:	4798      	blx	r3
	}

	if (ir & CAN_IR_RF0L) {
    123e:	0723      	lsls	r3, r4, #28
    1240:	d416      	bmi.n	1270 <CAN0_Handler+0x60>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
	}

	hri_can_write_IR_reg(dev->hw, ir);
    1242:	682b      	ldr	r3, [r5, #0]
	((Can *)hw)->IR.reg = data;
    1244:	651c      	str	r4, [r3, #80]	; 0x50
}
    1246:	bd70      	pop	{r4, r5, r6, pc}
		dev->cb.rx_done(dev);
    1248:	0028      	movs	r0, r5
    124a:	68ab      	ldr	r3, [r5, #8]
    124c:	4798      	blx	r3
    124e:	e7e6      	b.n	121e <CAN0_Handler+0xe>
		dev->cb.tx_done(dev);
    1250:	0028      	movs	r0, r5
    1252:	686b      	ldr	r3, [r5, #4]
    1254:	4798      	blx	r3
    1256:	e7e4      	b.n	1222 <CAN0_Handler+0x12>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
    1258:	2103      	movs	r1, #3
    125a:	0028      	movs	r0, r5
    125c:	68eb      	ldr	r3, [r5, #12]
    125e:	4798      	blx	r3
    1260:	e7e1      	b.n	1226 <CAN0_Handler+0x16>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
    1262:	2100      	movs	r1, #0
    1264:	0028      	movs	r0, r5
    1266:	68eb      	ldr	r3, [r5, #12]
    1268:	4798      	blx	r3
    126a:	e7de      	b.n	122a <CAN0_Handler+0x1a>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
    126c:	2101      	movs	r1, #1
    126e:	e7e4      	b.n	123a <CAN0_Handler+0x2a>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
    1270:	2104      	movs	r1, #4
    1272:	0028      	movs	r0, r5
    1274:	68eb      	ldr	r3, [r5, #12]
    1276:	4798      	blx	r3
    1278:	e7e3      	b.n	1242 <CAN0_Handler+0x32>
    127a:	46c0      	nop			; (mov r8, r8)
    127c:	2000014c 	.word	0x2000014c

00001280 <CAN1_Handler>:

/*
 * \brief CAN interrupt handler
 */
void CAN1_Handler(void)
{
    1280:	b570      	push	{r4, r5, r6, lr}
	struct _can_async_device *dev = _can1_dev;
    1282:	4b1a      	ldr	r3, [pc, #104]	; (12ec <CAN1_Handler+0x6c>)
    1284:	6edd      	ldr	r5, [r3, #108]	; 0x6c
	uint32_t                  ir;
	ir = hri_can_read_IR_reg(dev->hw);
    1286:	682b      	ldr	r3, [r5, #0]
	return ((Can *)hw)->IR.reg;
    1288:	6d1c      	ldr	r4, [r3, #80]	; 0x50

	if (ir & CAN_IR_RF0N) {
    128a:	07e3      	lsls	r3, r4, #31
    128c:	d414      	bmi.n	12b8 <CAN1_Handler+0x38>
		dev->cb.rx_done(dev);
	}

	if (ir & CAN_IR_TC) {
    128e:	05a3      	lsls	r3, r4, #22
    1290:	d416      	bmi.n	12c0 <CAN1_Handler+0x40>
		dev->cb.tx_done(dev);
	}

	if (ir & CAN_IR_BO) {
    1292:	01a3      	lsls	r3, r4, #6
    1294:	d418      	bmi.n	12c8 <CAN1_Handler+0x48>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
	}

	if (ir & CAN_IR_EW) {
    1296:	01e3      	lsls	r3, r4, #7
    1298:	d41b      	bmi.n	12d2 <CAN1_Handler+0x52>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
	}

	if (ir & CAN_IR_EP) {
    129a:	0223      	lsls	r3, r4, #8
    129c:	d507      	bpl.n	12ae <CAN1_Handler+0x2e>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
    129e:	68eb      	ldr	r3, [r5, #12]
    12a0:	682a      	ldr	r2, [r5, #0]
	return (((Can *)hw)->PSR.reg & CAN_PSR_EP) >> CAN_PSR_EP_Pos;
    12a2:	6c52      	ldr	r2, [r2, #68]	; 0x44
    12a4:	0692      	lsls	r2, r2, #26
    12a6:	d519      	bpl.n	12dc <CAN1_Handler+0x5c>
    12a8:	2102      	movs	r1, #2
    12aa:	0028      	movs	r0, r5
    12ac:	4798      	blx	r3
	}

	if (ir & CAN_IR_RF0L) {
    12ae:	0723      	lsls	r3, r4, #28
    12b0:	d416      	bmi.n	12e0 <CAN1_Handler+0x60>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
	}

	hri_can_write_IR_reg(dev->hw, ir);
    12b2:	682b      	ldr	r3, [r5, #0]
	((Can *)hw)->IR.reg = data;
    12b4:	651c      	str	r4, [r3, #80]	; 0x50
}
    12b6:	bd70      	pop	{r4, r5, r6, pc}
		dev->cb.rx_done(dev);
    12b8:	0028      	movs	r0, r5
    12ba:	68ab      	ldr	r3, [r5, #8]
    12bc:	4798      	blx	r3
    12be:	e7e6      	b.n	128e <CAN1_Handler+0xe>
		dev->cb.tx_done(dev);
    12c0:	0028      	movs	r0, r5
    12c2:	686b      	ldr	r3, [r5, #4]
    12c4:	4798      	blx	r3
    12c6:	e7e4      	b.n	1292 <CAN1_Handler+0x12>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
    12c8:	2103      	movs	r1, #3
    12ca:	0028      	movs	r0, r5
    12cc:	68eb      	ldr	r3, [r5, #12]
    12ce:	4798      	blx	r3
    12d0:	e7e1      	b.n	1296 <CAN1_Handler+0x16>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
    12d2:	2100      	movs	r1, #0
    12d4:	0028      	movs	r0, r5
    12d6:	68eb      	ldr	r3, [r5, #12]
    12d8:	4798      	blx	r3
    12da:	e7de      	b.n	129a <CAN1_Handler+0x1a>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
    12dc:	2101      	movs	r1, #1
    12de:	e7e4      	b.n	12aa <CAN1_Handler+0x2a>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
    12e0:	2104      	movs	r1, #4
    12e2:	0028      	movs	r0, r5
    12e4:	68eb      	ldr	r3, [r5, #12]
    12e6:	4798      	blx	r3
    12e8:	e7e3      	b.n	12b2 <CAN1_Handler+0x32>
    12ea:	46c0      	nop			; (mov r8, r8)
    12ec:	2000014c 	.word	0x2000014c

000012f0 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    12f0:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
    12f2:	4b08      	ldr	r3, [pc, #32]	; (1314 <_init_chip+0x24>)
    12f4:	685a      	ldr	r2, [r3, #4]
    12f6:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    12f8:	4b07      	ldr	r3, [pc, #28]	; (1318 <_init_chip+0x28>)
    12fa:	4798      	blx	r3
	_oscctrl_init_sources();
    12fc:	4b07      	ldr	r3, [pc, #28]	; (131c <_init_chip+0x2c>)
    12fe:	4798      	blx	r3
	_mclk_init();
    1300:	4b07      	ldr	r3, [pc, #28]	; (1320 <_init_chip+0x30>)
    1302:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
    1304:	4b07      	ldr	r3, [pc, #28]	; (1324 <_init_chip+0x34>)
    1306:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    1308:	20ff      	movs	r0, #255	; 0xff
    130a:	4b07      	ldr	r3, [pc, #28]	; (1328 <_init_chip+0x38>)
    130c:	4798      	blx	r3

	_div_init();
    130e:	4b07      	ldr	r3, [pc, #28]	; (132c <_init_chip+0x3c>)
    1310:	4798      	blx	r3
#endif

#if (CONF_PORT_EVCTRL_PORT_0 | CONF_PORT_EVCTRL_PORT_1 | CONF_PORT_EVCTRL_PORT_2 | CONF_PORT_EVCTRL_PORT_3)
	_port_event_init();
#endif
}
    1312:	bd10      	pop	{r4, pc}
    1314:	41004000 	.word	0x41004000
    1318:	000014a9 	.word	0x000014a9
    131c:	000014c5 	.word	0x000014c5
    1320:	0000140d 	.word	0x0000140d
    1324:	00001501 	.word	0x00001501
    1328:	000013e9 	.word	0x000013e9
    132c:	00001331 	.word	0x00001331

00001330 <_div_init>:

static inline void hri_divas_write_CTRLA_DLZ_bit(const void *const hw, bool value)
{
	uint8_t tmp;
	DIVAS_CRITICAL_SECTION_ENTER();
	tmp = ((Divas *)hw)->CTRLA.reg;
    1330:	2290      	movs	r2, #144	; 0x90
    1332:	05d2      	lsls	r2, r2, #23
    1334:	7813      	ldrb	r3, [r2, #0]
	tmp &= ~DIVAS_CTRLA_DLZ;
    1336:	2102      	movs	r1, #2
    1338:	438b      	bics	r3, r1
	tmp |= value << DIVAS_CTRLA_DLZ_Pos;
	((Divas *)hw)->CTRLA.reg = tmp;
    133a:	7013      	strb	r3, [r2, #0]
 * \brief Initialize hardware for division operation
 */
void _div_init(void)
{
	hri_divas_write_CTRLA_DLZ_bit(DIVAS, CONF_DIVAS_DLZ);
}
    133c:	4770      	bx	lr

0000133e <__aeabi_idiv>:

/**
 * \brief Do signed division
 */
int32_t __aeabi_idiv(int32_t numerator, int32_t denominator)
{
    133e:	b510      	push	{r4, lr}
    1340:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    1342:	f3ef 8310 	mrs	r3, PRIMASK
	int32_t res;
	_DIVAS_CRITICAL_ENTER();
    1346:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
    1348:	b672      	cpsid	i
	DIVAS->CTRLA.bit.SIGNED = s;
    134a:	2390      	movs	r3, #144	; 0x90
    134c:	05db      	lsls	r3, r3, #23
    134e:	781a      	ldrb	r2, [r3, #0]
    1350:	2401      	movs	r4, #1
    1352:	4322      	orrs	r2, r4
    1354:	701a      	strb	r2, [r3, #0]
	DIVAS->DIVIDEND.reg     = n;
    1356:	6098      	str	r0, [r3, #8]
	DIVAS->DIVISOR.reg      = d;
    1358:	60d9      	str	r1, [r3, #12]
	while (DIVAS->STATUS.bit.BUSY) {
    135a:	2390      	movs	r3, #144	; 0x90
    135c:	05db      	lsls	r3, r3, #23
    135e:	791b      	ldrb	r3, [r3, #4]
    1360:	07db      	lsls	r3, r3, #31
    1362:	d4fa      	bmi.n	135a <__aeabi_idiv+0x1c>
	_divas_div(1, numerator, denominator);
	res = _divas_result32();
    1364:	2390      	movs	r3, #144	; 0x90
    1366:	05db      	lsls	r3, r3, #23
    1368:	6918      	ldr	r0, [r3, #16]
	_DIVAS_CRITICAL_LEAVE();
    136a:	9b01      	ldr	r3, [sp, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    136c:	f383 8810 	msr	PRIMASK, r3
	return res;
}
    1370:	b002      	add	sp, #8
    1372:	bd10      	pop	{r4, pc}

00001374 <__aeabi_uidiv>:

/**
 * \brief Do unsigned division
 */
uint32_t __aeabi_uidiv(uint32_t numerator, uint32_t denominator)
{
    1374:	b510      	push	{r4, lr}
    1376:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    1378:	f3ef 8310 	mrs	r3, PRIMASK
	uint32_t res;
	_DIVAS_CRITICAL_ENTER();
    137c:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
    137e:	b672      	cpsid	i
	DIVAS->CTRLA.bit.SIGNED = s;
    1380:	2390      	movs	r3, #144	; 0x90
    1382:	05db      	lsls	r3, r3, #23
    1384:	781a      	ldrb	r2, [r3, #0]
    1386:	2401      	movs	r4, #1
    1388:	43a2      	bics	r2, r4
    138a:	701a      	strb	r2, [r3, #0]
	DIVAS->DIVIDEND.reg     = n;
    138c:	6098      	str	r0, [r3, #8]
	DIVAS->DIVISOR.reg      = d;
    138e:	60d9      	str	r1, [r3, #12]
	while (DIVAS->STATUS.bit.BUSY) {
    1390:	2390      	movs	r3, #144	; 0x90
    1392:	05db      	lsls	r3, r3, #23
    1394:	791b      	ldrb	r3, [r3, #4]
    1396:	07db      	lsls	r3, r3, #31
    1398:	d4fa      	bmi.n	1390 <__aeabi_uidiv+0x1c>
	_divas_div(0, numerator, denominator);
	res = _divas_result32();
    139a:	2390      	movs	r3, #144	; 0x90
    139c:	05db      	lsls	r3, r3, #23
    139e:	6918      	ldr	r0, [r3, #16]
	_DIVAS_CRITICAL_LEAVE();
    13a0:	9b01      	ldr	r3, [sp, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    13a2:	f383 8810 	msr	PRIMASK, r3
	return res;
}
    13a6:	b002      	add	sp, #8
    13a8:	bd10      	pop	{r4, pc}
	...

000013ac <__aeabi_uidivmod>:

/**
 * \brief Do unsigned division, return result and remainder
 */
uint64_t __aeabi_uidivmod(unsigned numerator, unsigned denominator)
{
    13ac:	b510      	push	{r4, lr}
    13ae:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
    13b0:	f3ef 8310 	mrs	r3, PRIMASK
	uint64_t res;
	_DIVAS_CRITICAL_ENTER();
    13b4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
    13b6:	b672      	cpsid	i
	DIVAS->CTRLA.bit.SIGNED = s;
    13b8:	2390      	movs	r3, #144	; 0x90
    13ba:	05db      	lsls	r3, r3, #23
    13bc:	781a      	ldrb	r2, [r3, #0]
    13be:	2401      	movs	r4, #1
    13c0:	43a2      	bics	r2, r4
    13c2:	701a      	strb	r2, [r3, #0]
	DIVAS->DIVIDEND.reg     = n;
    13c4:	6098      	str	r0, [r3, #8]
	DIVAS->DIVISOR.reg      = d;
    13c6:	60d9      	str	r1, [r3, #12]
	while (DIVAS->STATUS.bit.BUSY) {
    13c8:	2390      	movs	r3, #144	; 0x90
    13ca:	05db      	lsls	r3, r3, #23
    13cc:	791b      	ldrb	r3, [r3, #4]
    13ce:	07db      	lsls	r3, r3, #31
    13d0:	d4fa      	bmi.n	13c8 <__aeabi_uidivmod+0x1c>
	_divas_div(0, numerator, denominator);
	res = _divas_result64();
    13d2:	4b04      	ldr	r3, [pc, #16]	; (13e4 <__aeabi_uidivmod+0x38>)
    13d4:	6818      	ldr	r0, [r3, #0]
    13d6:	6859      	ldr	r1, [r3, #4]
	_DIVAS_CRITICAL_LEAVE();
    13d8:	9b01      	ldr	r3, [sp, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
    13da:	f383 8810 	msr	PRIMASK, r3
	return res;
}
    13de:	b002      	add	sp, #8
    13e0:	bd10      	pop	{r4, pc}
    13e2:	46c0      	nop			; (mov r8, r8)
    13e4:	48000010 	.word	0x48000010

000013e8 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    13e8:	07c3      	lsls	r3, r0, #31
    13ea:	d507      	bpl.n	13fc <_gclk_init_generators_by_fref+0x14>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    13ec:	4a04      	ldr	r2, [pc, #16]	; (1400 <_gclk_init_generators_by_fref+0x18>)
    13ee:	4b05      	ldr	r3, [pc, #20]	; (1404 <_gclk_init_generators_by_fref+0x1c>)
    13f0:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    13f2:	4b04      	ldr	r3, [pc, #16]	; (1404 <_gclk_init_generators_by_fref+0x1c>)
    13f4:	685a      	ldr	r2, [r3, #4]
    13f6:	4b04      	ldr	r3, [pc, #16]	; (1408 <_gclk_init_generators_by_fref+0x20>)
    13f8:	421a      	tst	r2, r3
    13fa:	d1fa      	bne.n	13f2 <_gclk_init_generators_by_fref+0xa>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SOURCE);
	}
#endif
}
    13fc:	4770      	bx	lr
    13fe:	46c0      	nop			; (mov r8, r8)
    1400:	00010106 	.word	0x00010106
    1404:	40001c00 	.word	0x40001c00
    1408:	000007fd 	.word	0x000007fd

0000140c <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    140c:	2201      	movs	r2, #1
    140e:	4b01      	ldr	r3, [pc, #4]	; (1414 <_mclk_init+0x8>)
    1410:	711a      	strb	r2, [r3, #4]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_CPUDIV(CONF_MCLK_CPUDIV));
}
    1412:	4770      	bx	lr
    1414:	40000800 	.word	0x40000800

00001418 <_flash_init>:

/**
 * \brief Initialize NVM
 */
int32_t _flash_init(struct _flash_device *const device, void *const hw)
{
    1418:	b570      	push	{r4, r5, r6, lr}
    141a:	0005      	movs	r5, r0
    141c:	000c      	movs	r4, r1
	ASSERT(device && (hw == NVMCTRL));
    141e:	2800      	cmp	r0, #0
    1420:	d01c      	beq.n	145c <_flash_init+0x44>
    1422:	4b10      	ldr	r3, [pc, #64]	; (1464 <_flash_init+0x4c>)
    1424:	4299      	cmp	r1, r3
    1426:	d01b      	beq.n	1460 <_flash_init+0x48>
    1428:	2000      	movs	r0, #0
    142a:	2246      	movs	r2, #70	; 0x46
    142c:	490e      	ldr	r1, [pc, #56]	; (1468 <_flash_init+0x50>)
    142e:	4b0f      	ldr	r3, [pc, #60]	; (146c <_flash_init+0x54>)
    1430:	4798      	blx	r3
	uint32_t ctrlb;

	device->hw = hw;
    1432:	612c      	str	r4, [r5, #16]
}

static inline hri_nvmctrl_ctrlb_reg_t hri_nvmctrl_get_CTRLB_reg(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Nvmctrl *)hw)->CTRLB.reg;
    1434:	6862      	ldr	r2, [r4, #4]
	tmp &= mask;
    1436:	239e      	movs	r3, #158	; 0x9e
    1438:	4013      	ands	r3, r2
}

static inline void hri_nvmctrl_write_CTRLB_reg(const void *const hw, hri_nvmctrl_ctrlb_reg_t data)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg = data;
    143a:	6063      	str	r3, [r4, #4]
	ctrlb      = _nvm.ctrlb & ~(NVMCTRL_CTRLB_RWS_Msk | NVMCTRL_CTRLB_MANW);
	ctrlb |= hri_nvmctrl_get_CTRLB_reg(device->hw, NVMCTRL_CTRLB_RWS_Msk | NVMCTRL_CTRLB_MANW);
	hri_nvmctrl_write_CTRLB_reg(device->hw, ctrlb);

	_nvm_dev = device;
    143c:	4b0c      	ldr	r3, [pc, #48]	; (1470 <_flash_init+0x58>)
    143e:	601d      	str	r5, [r3, #0]
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1440:	4b0c      	ldr	r3, [pc, #48]	; (1474 <_flash_init+0x5c>)
    1442:	2240      	movs	r2, #64	; 0x40
    1444:	2180      	movs	r1, #128	; 0x80
    1446:	505a      	str	r2, [r3, r1]
  __ASM volatile ("dsb 0xF":::"memory");
    1448:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    144c:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1450:	3101      	adds	r1, #1
    1452:	31ff      	adds	r1, #255	; 0xff
    1454:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1456:	601a      	str	r2, [r3, #0]
	NVIC_DisableIRQ(NVMCTRL_IRQn);
	NVIC_ClearPendingIRQ(NVMCTRL_IRQn);
	NVIC_EnableIRQ(NVMCTRL_IRQn);
	return ERR_NONE;
}
    1458:	2000      	movs	r0, #0
    145a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(device && (hw == NVMCTRL));
    145c:	2000      	movs	r0, #0
    145e:	e7e4      	b.n	142a <_flash_init+0x12>
    1460:	2001      	movs	r0, #1
    1462:	e7e2      	b.n	142a <_flash_init+0x12>
    1464:	41004000 	.word	0x41004000
    1468:	00002294 	.word	0x00002294
    146c:	00000c81 	.word	0x00000c81
    1470:	20000224 	.word	0x20000224
    1474:	e000e100 	.word	0xe000e100

00001478 <NVMCTRL_Handler>:

/**
 * \internal NVM interrupt handler
 */
void NVMCTRL_Handler(void)
{
    1478:	b510      	push	{r4, lr}
	void *const hw = _nvm_dev->hw;
    147a:	4b0a      	ldr	r3, [pc, #40]	; (14a4 <NVMCTRL_Handler+0x2c>)
    147c:	6818      	ldr	r0, [r3, #0]
    147e:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_READY) >> NVMCTRL_INTFLAG_READY_Pos;
    1480:	7d1a      	ldrb	r2, [r3, #20]

	if (hri_nvmctrl_get_interrupt_READY_bit(hw)) {
    1482:	07d2      	lsls	r2, r2, #31
    1484:	d504      	bpl.n	1490 <NVMCTRL_Handler+0x18>
		if (NULL != _nvm_dev->flash_cb.ready_cb) {
    1486:	6803      	ldr	r3, [r0, #0]
    1488:	2b00      	cmp	r3, #0
    148a:	d000      	beq.n	148e <NVMCTRL_Handler+0x16>
			_nvm_dev->flash_cb.ready_cb(_nvm_dev);
    148c:	4798      	blx	r3
		hri_nvmctrl_clear_interrupt_ERROR_bit(hw);
		if (NULL != _nvm_dev->flash_cb.error_cb) {
			_nvm_dev->flash_cb.error_cb(_nvm_dev);
		}
	}
}
    148e:	bd10      	pop	{r4, pc}
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_ERROR) >> NVMCTRL_INTFLAG_ERROR_Pos;
    1490:	7d1a      	ldrb	r2, [r3, #20]
	} else if (hri_nvmctrl_get_interrupt_ERROR_bit(hw)) {
    1492:	0792      	lsls	r2, r2, #30
    1494:	d5fb      	bpl.n	148e <NVMCTRL_Handler+0x16>
	((Nvmctrl *)hw)->INTFLAG.reg = NVMCTRL_INTFLAG_ERROR;
    1496:	2202      	movs	r2, #2
    1498:	751a      	strb	r2, [r3, #20]
		if (NULL != _nvm_dev->flash_cb.error_cb) {
    149a:	6843      	ldr	r3, [r0, #4]
    149c:	2b00      	cmp	r3, #0
    149e:	d0f6      	beq.n	148e <NVMCTRL_Handler+0x16>
			_nvm_dev->flash_cb.error_cb(_nvm_dev);
    14a0:	4798      	blx	r3
}
    14a2:	e7f4      	b.n	148e <NVMCTRL_Handler+0x16>
    14a4:	20000224 	.word	0x20000224

000014a8 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    14a8:	4a05      	ldr	r2, [pc, #20]	; (14c0 <_osc32kctrl_init_sources+0x18>)
    14aa:	69d3      	ldr	r3, [r2, #28]
	tmp = (tmp & OSC32KCTRL_OSCULP32K_CALIB_Msk) >> OSC32KCTRL_OSCULP32K_CALIB_Pos;
    14ac:	0a1b      	lsrs	r3, r3, #8
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSC32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSC32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    14ae:	021b      	lsls	r3, r3, #8
    14b0:	21f8      	movs	r1, #248	; 0xf8
    14b2:	0149      	lsls	r1, r1, #5
    14b4:	400b      	ands	r3, r1
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    14b6:	61d3      	str	r3, [r2, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    14b8:	2301      	movs	r3, #1
    14ba:	6113      	str	r3, [r2, #16]
		;
#endif
#endif
	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    14bc:	4770      	bx	lr
    14be:	46c0      	nop			; (mov r8, r8)
    14c0:	40001400 	.word	0x40001400

000014c4 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_OSC48MCTRL_reg(const void *const hw, hri_oscctrl_osc48mctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MCTRL.reg = data;
    14c4:	4b0d      	ldr	r3, [pc, #52]	; (14fc <_oscctrl_init_sources+0x38>)
    14c6:	2202      	movs	r2, #2
    14c8:	751a      	strb	r2, [r3, #20]
}

static inline void hri_oscctrl_write_OSC48MDIV_reg(const void *const hw, hri_oscctrl_osc48mdiv_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MDIV.reg = data;
    14ca:	3209      	adds	r2, #9
    14cc:	755a      	strb	r2, [r3, #21]
	while (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & reg) {
    14ce:	4b0b      	ldr	r3, [pc, #44]	; (14fc <_oscctrl_init_sources+0x38>)
    14d0:	699b      	ldr	r3, [r3, #24]
    14d2:	075b      	lsls	r3, r3, #29
    14d4:	d4fb      	bmi.n	14ce <_oscctrl_init_sources+0xa>
	return (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV)
    14d6:	4b09      	ldr	r3, [pc, #36]	; (14fc <_oscctrl_init_sources+0x38>)
    14d8:	699b      	ldr	r3, [r3, #24]
#if CONF_OSC48M_CONFIG == 1
	hri_oscctrl_write_OSC48MCTRL_reg(hw,
	                                 (CONF_OSC48M_RUNSTDBY << OSCCTRL_OSC48MCTRL_RUNSTDBY_Pos)
	                                     | (CONF_OSC48M_ENABLE << OSCCTRL_OSC48MCTRL_ENABLE_Pos));
	hri_oscctrl_write_OSC48MDIV_reg(hw, OSCCTRL_OSC48MDIV_DIV(CONF_OSC48M_DIV));
	while (hri_oscctrl_get_OSC48MSYNCBUSY_OSC48MDIV_bit(hw))
    14da:	075b      	lsls	r3, r3, #29
    14dc:	d4fb      	bmi.n	14d6 <_oscctrl_init_sources+0x12>
}

static inline void hri_oscctrl_write_OSC48MSTUP_reg(const void *const hw, hri_oscctrl_osc48mstup_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MSTUP.reg = data;
    14de:	2207      	movs	r2, #7
    14e0:	4b06      	ldr	r3, [pc, #24]	; (14fc <_oscctrl_init_sources+0x38>)
    14e2:	759a      	strb	r2, [r3, #22]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_OSC48MRDY) >> OSCCTRL_STATUS_OSC48MRDY_Pos;
    14e4:	4b05      	ldr	r3, [pc, #20]	; (14fc <_oscctrl_init_sources+0x38>)
    14e6:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC48M_CONFIG == 1
#if CONF_OSC48M_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_OSC48MRDY_bit(hw))
    14e8:	06db      	lsls	r3, r3, #27
    14ea:	d5fb      	bpl.n	14e4 <_oscctrl_init_sources+0x20>
	((Oscctrl *)hw)->OSC48MCTRL.reg |= OSCCTRL_OSC48MCTRL_ONDEMAND;
    14ec:	4a03      	ldr	r2, [pc, #12]	; (14fc <_oscctrl_init_sources+0x38>)
    14ee:	7d13      	ldrb	r3, [r2, #20]
    14f0:	2180      	movs	r1, #128	; 0x80
    14f2:	4249      	negs	r1, r1
    14f4:	430b      	orrs	r3, r1
    14f6:	b2db      	uxtb	r3, r3
    14f8:	7513      	strb	r3, [r2, #20]
#if CONF_OSC48M_ONDEMAND == 1
	hri_oscctrl_set_OSC48MCTRL_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
    14fa:	4770      	bx	lr
    14fc:	40001000 	.word	0x40001000

00001500 <_oscctrl_init_referenced_generators>:
#if CONF_DPLL_ONDEMAND == 1
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
    1500:	4770      	bx	lr
	...

00001504 <_sercom_get_hardware_index>:
{
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
    1504:	4b02      	ldr	r3, [pc, #8]	; (1510 <_sercom_get_hardware_index+0xc>)
    1506:	469c      	mov	ip, r3
    1508:	4460      	add	r0, ip
    150a:	0a80      	lsrs	r0, r0, #10
    150c:	b2c0      	uxtb	r0, r0
}
    150e:	4770      	bx	lr
    1510:	bdfffc00 	.word	0xbdfffc00

00001514 <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
    1514:	b570      	push	{r4, r5, r6, lr}
    1516:	0006      	movs	r6, r0
    1518:	000c      	movs	r4, r1
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
    151a:	0008      	movs	r0, r1
    151c:	4b71      	ldr	r3, [pc, #452]	; (16e4 <_spi_m_sync_init+0x1d0>)
    151e:	4798      	blx	r3
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    1520:	2300      	movs	r3, #0
    1522:	2b00      	cmp	r3, #0
    1524:	d100      	bne.n	1528 <_spi_m_sync_init+0x14>
    1526:	e084      	b.n	1632 <_spi_m_sync_init+0x11e>
	return NULL;
    1528:	2500      	movs	r5, #0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
    152a:	2e00      	cmp	r6, #0
    152c:	d100      	bne.n	1530 <_spi_m_sync_init+0x1c>
    152e:	e08d      	b.n	164c <_spi_m_sync_init+0x138>
    1530:	2c00      	cmp	r4, #0
    1532:	d100      	bne.n	1536 <_spi_m_sync_init+0x22>
    1534:	e088      	b.n	1648 <_spi_m_sync_init+0x134>
    1536:	2001      	movs	r0, #1
    1538:	4a6b      	ldr	r2, [pc, #428]	; (16e8 <_spi_m_sync_init+0x1d4>)
    153a:	496c      	ldr	r1, [pc, #432]	; (16ec <_spi_m_sync_init+0x1d8>)
    153c:	4b6c      	ldr	r3, [pc, #432]	; (16f0 <_spi_m_sync_init+0x1dc>)
    153e:	4798      	blx	r3

	if (regs == NULL) {
    1540:	2d00      	cmp	r5, #0
    1542:	d100      	bne.n	1546 <_spi_m_sync_init+0x32>
    1544:	e0cb      	b.n	16de <_spi_m_sync_init+0x1ca>
	};
}

static inline bool hri_sercomspi_is_syncing(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    1546:	69e3      	ldr	r3, [r4, #28]
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
    1548:	07db      	lsls	r3, r3, #31
    154a:	d421      	bmi.n	1590 <_spi_m_sync_init+0x7c>
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
    154c:	782a      	ldrb	r2, [r5, #0]
    154e:	786b      	ldrb	r3, [r5, #1]
    1550:	021b      	lsls	r3, r3, #8
    1552:	4313      	orrs	r3, r2
    1554:	78aa      	ldrb	r2, [r5, #2]
    1556:	0412      	lsls	r2, r2, #16
    1558:	4313      	orrs	r3, r2
    155a:	78ea      	ldrb	r2, [r5, #3]
    155c:	0612      	lsls	r2, r2, #24
    155e:	431a      	orrs	r2, r3
    1560:	231c      	movs	r3, #28
    1562:	401a      	ands	r2, r3
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    1564:	69e3      	ldr	r3, [r4, #28]
    1566:	079b      	lsls	r3, r3, #30
    1568:	d1fc      	bne.n	1564 <_spi_m_sync_init+0x50>
static inline hri_sercomspi_ctrla_reg_t hri_sercomspi_get_CTRLA_reg(const void *const         hw,
                                                                    hri_sercomspi_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    156a:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
    156c:	079b      	lsls	r3, r3, #30
    156e:	d509      	bpl.n	1584 <_spi_m_sync_init+0x70>
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    1570:	6823      	ldr	r3, [r4, #0]
    1572:	2102      	movs	r1, #2
    1574:	438b      	bics	r3, r1
    1576:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    1578:	69e3      	ldr	r3, [r4, #28]
    157a:	079b      	lsls	r3, r3, #30
    157c:	d1fc      	bne.n	1578 <_spi_m_sync_init+0x64>
    157e:	69e3      	ldr	r3, [r4, #28]
    1580:	079b      	lsls	r3, r3, #30
    1582:	d4fc      	bmi.n	157e <_spi_m_sync_init+0x6a>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
    1584:	2301      	movs	r3, #1
    1586:	4313      	orrs	r3, r2
}

static inline void hri_sercomspi_write_CTRLA_reg(const void *const hw, hri_sercomspi_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    1588:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    158a:	69e3      	ldr	r3, [r4, #28]
    158c:	079b      	lsls	r3, r3, #30
    158e:	d1fc      	bne.n	158a <_spi_m_sync_init+0x76>
    1590:	69e3      	ldr	r3, [r4, #28]
    1592:	07db      	lsls	r3, r3, #31
    1594:	d4fc      	bmi.n	1590 <_spi_m_sync_init+0x7c>
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
    1596:	6034      	str	r4, [r6, #0]

	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
    1598:	782b      	ldrb	r3, [r5, #0]
    159a:	786a      	ldrb	r2, [r5, #1]
    159c:	0212      	lsls	r2, r2, #8
    159e:	431a      	orrs	r2, r3
    15a0:	78ab      	ldrb	r3, [r5, #2]
    15a2:	041b      	lsls	r3, r3, #16
    15a4:	431a      	orrs	r2, r3
    15a6:	78eb      	ldrb	r3, [r5, #3]
    15a8:	061b      	lsls	r3, r3, #24
    15aa:	4313      	orrs	r3, r2
    15ac:	221c      	movs	r2, #28
    15ae:	4013      	ands	r3, r2
    15b0:	2b08      	cmp	r3, #8
    15b2:	d04d      	beq.n	1650 <_spi_m_sync_init+0x13c>
	ASSERT(hw && regs);
    15b4:	2c00      	cmp	r4, #0
    15b6:	d100      	bne.n	15ba <_spi_m_sync_init+0xa6>
    15b8:	e08d      	b.n	16d6 <_spi_m_sync_init+0x1c2>
    15ba:	2d00      	cmp	r5, #0
    15bc:	d100      	bne.n	15c0 <_spi_m_sync_init+0xac>
    15be:	e088      	b.n	16d2 <_spi_m_sync_init+0x1be>
    15c0:	2001      	movs	r0, #1
    15c2:	4a4c      	ldr	r2, [pc, #304]	; (16f4 <_spi_m_sync_init+0x1e0>)
    15c4:	4949      	ldr	r1, [pc, #292]	; (16ec <_spi_m_sync_init+0x1d8>)
    15c6:	4b4a      	ldr	r3, [pc, #296]	; (16f0 <_spi_m_sync_init+0x1dc>)
    15c8:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    15ca:	782b      	ldrb	r3, [r5, #0]
    15cc:	786a      	ldrb	r2, [r5, #1]
    15ce:	0212      	lsls	r2, r2, #8
    15d0:	431a      	orrs	r2, r3
    15d2:	78ab      	ldrb	r3, [r5, #2]
    15d4:	041b      	lsls	r3, r3, #16
    15d6:	431a      	orrs	r2, r3
    15d8:	78eb      	ldrb	r3, [r5, #3]
    15da:	061b      	lsls	r3, r3, #24
    15dc:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    15de:	4a46      	ldr	r2, [pc, #280]	; (16f8 <_spi_m_sync_init+0x1e4>)
    15e0:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    15e2:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    15e4:	69e3      	ldr	r3, [r4, #28]
    15e6:	079b      	lsls	r3, r3, #30
    15e8:	d1fc      	bne.n	15e4 <_spi_m_sync_init+0xd0>
	    (regs->ctrlb
    15ea:	792b      	ldrb	r3, [r5, #4]
    15ec:	796a      	ldrb	r2, [r5, #5]
    15ee:	0212      	lsls	r2, r2, #8
    15f0:	431a      	orrs	r2, r3
    15f2:	79ab      	ldrb	r3, [r5, #6]
    15f4:	041b      	lsls	r3, r3, #16
    15f6:	431a      	orrs	r2, r3
    15f8:	79eb      	ldrb	r3, [r5, #7]
    15fa:	061b      	lsls	r3, r3, #24
    15fc:	4313      	orrs	r3, r2
	        | (SERCOM_SPI_CTRLB_RXEN));
    15fe:	4a3f      	ldr	r2, [pc, #252]	; (16fc <_spi_m_sync_init+0x1e8>)
    1600:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(
    1602:	2280      	movs	r2, #128	; 0x80
    1604:	0292      	lsls	r2, r2, #10
    1606:	4313      	orrs	r3, r2
}

static inline void hri_sercomspi_write_CTRLB_reg(const void *const hw, hri_sercomspi_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    1608:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    160a:	69e3      	ldr	r3, [r4, #28]
    160c:	075b      	lsls	r3, r3, #29
    160e:	d1fc      	bne.n	160a <_spi_m_sync_init+0xf6>
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
    1610:	7b2b      	ldrb	r3, [r5, #12]
}

static inline void hri_sercomspi_write_BAUD_reg(const void *const hw, hri_sercomspi_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.BAUD.reg = data;
    1612:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    1614:	7b6a      	ldrb	r2, [r5, #13]
}

static inline void hri_sercomspi_write_DBGCTRL_reg(const void *const hw, hri_sercomspi_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    1616:	2330      	movs	r3, #48	; 0x30
    1618:	54e2      	strb	r2, [r4, r3]
	} else {
		_spi_load_regs_master(hw, regs);
	}

	/* Load character size from default hardware configuration */
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    161a:	792b      	ldrb	r3, [r5, #4]
    161c:	075b      	lsls	r3, r3, #29
    161e:	d15c      	bne.n	16da <_spi_m_sync_init+0x1c6>
    1620:	2301      	movs	r3, #1
    1622:	7133      	strb	r3, [r6, #4]

	dev->dummy_byte = regs->dummy_byte;
    1624:	7baa      	ldrb	r2, [r5, #14]
    1626:	7beb      	ldrb	r3, [r5, #15]
    1628:	021b      	lsls	r3, r3, #8
    162a:	4313      	orrs	r3, r2
    162c:	80f3      	strh	r3, [r6, #6]

	return ERR_NONE;
    162e:	2000      	movs	r0, #0
}
    1630:	bd70      	pop	{r4, r5, r6, pc}
		if (sercomspi_regs[i].n == n) {
    1632:	2801      	cmp	r0, #1
    1634:	d002      	beq.n	163c <_spi_m_sync_init+0x128>
	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
    1636:	3301      	adds	r3, #1
    1638:	b2db      	uxtb	r3, r3
    163a:	e772      	b.n	1522 <_spi_m_sync_init+0xe>
			return &sercomspi_regs[i];
    163c:	011d      	lsls	r5, r3, #4
    163e:	18ea      	adds	r2, r5, r3
    1640:	4d2f      	ldr	r5, [pc, #188]	; (1700 <_spi_m_sync_init+0x1ec>)
    1642:	353c      	adds	r5, #60	; 0x3c
    1644:	18ad      	adds	r5, r5, r2
    1646:	e770      	b.n	152a <_spi_m_sync_init+0x16>
	ASSERT(dev && hw);
    1648:	2000      	movs	r0, #0
    164a:	e775      	b.n	1538 <_spi_m_sync_init+0x24>
    164c:	2000      	movs	r0, #0
    164e:	e773      	b.n	1538 <_spi_m_sync_init+0x24>
	ASSERT(hw && regs);
    1650:	2c00      	cmp	r4, #0
    1652:	d03c      	beq.n	16ce <_spi_m_sync_init+0x1ba>
    1654:	2d00      	cmp	r5, #0
    1656:	d038      	beq.n	16ca <_spi_m_sync_init+0x1b6>
    1658:	2001      	movs	r0, #1
    165a:	4a2a      	ldr	r2, [pc, #168]	; (1704 <_spi_m_sync_init+0x1f0>)
    165c:	4923      	ldr	r1, [pc, #140]	; (16ec <_spi_m_sync_init+0x1d8>)
    165e:	4b24      	ldr	r3, [pc, #144]	; (16f0 <_spi_m_sync_init+0x1dc>)
    1660:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
    1662:	782b      	ldrb	r3, [r5, #0]
    1664:	786a      	ldrb	r2, [r5, #1]
    1666:	0212      	lsls	r2, r2, #8
    1668:	431a      	orrs	r2, r3
    166a:	78ab      	ldrb	r3, [r5, #2]
    166c:	041b      	lsls	r3, r3, #16
    166e:	431a      	orrs	r2, r3
    1670:	78eb      	ldrb	r3, [r5, #3]
    1672:	061b      	lsls	r3, r3, #24
    1674:	4313      	orrs	r3, r2
	hri_sercomspi_write_CTRLA_reg(
    1676:	4a20      	ldr	r2, [pc, #128]	; (16f8 <_spi_m_sync_init+0x1e4>)
    1678:	4013      	ands	r3, r2
	((Sercom *)hw)->SPI.CTRLA.reg = data;
    167a:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    167c:	69e3      	ldr	r3, [r4, #28]
    167e:	079b      	lsls	r3, r3, #30
    1680:	d1fc      	bne.n	167c <_spi_m_sync_init+0x168>
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
    1682:	792b      	ldrb	r3, [r5, #4]
    1684:	796a      	ldrb	r2, [r5, #5]
    1686:	0212      	lsls	r2, r2, #8
    1688:	431a      	orrs	r2, r3
    168a:	79ab      	ldrb	r3, [r5, #6]
    168c:	041b      	lsls	r3, r3, #16
    168e:	431a      	orrs	r2, r3
    1690:	79eb      	ldrb	r3, [r5, #7]
    1692:	061b      	lsls	r3, r3, #24
    1694:	4313      	orrs	r3, r2
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
    1696:	4a1c      	ldr	r2, [pc, #112]	; (1708 <_spi_m_sync_init+0x1f4>)
    1698:	4013      	ands	r3, r2
	hri_sercomspi_write_CTRLB_reg(hw,
    169a:	4a1c      	ldr	r2, [pc, #112]	; (170c <_spi_m_sync_init+0x1f8>)
    169c:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.CTRLB.reg = data;
    169e:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    16a0:	69e3      	ldr	r3, [r4, #28]
    16a2:	075b      	lsls	r3, r3, #29
    16a4:	d1fc      	bne.n	16a0 <_spi_m_sync_init+0x18c>
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
    16a6:	7a2b      	ldrb	r3, [r5, #8]
    16a8:	7a6a      	ldrb	r2, [r5, #9]
    16aa:	0212      	lsls	r2, r2, #8
    16ac:	431a      	orrs	r2, r3
    16ae:	7aab      	ldrb	r3, [r5, #10]
    16b0:	041b      	lsls	r3, r3, #16
    16b2:	431a      	orrs	r2, r3
    16b4:	7aeb      	ldrb	r3, [r5, #11]
    16b6:	061b      	lsls	r3, r3, #24
    16b8:	4313      	orrs	r3, r2
	((Sercom *)hw)->SPI.ADDR.reg = data;
    16ba:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
    16bc:	7b6a      	ldrb	r2, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
    16be:	2330      	movs	r3, #48	; 0x30
    16c0:	54e2      	strb	r2, [r4, r3]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
    16c2:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
    16c4:	2b00      	cmp	r3, #0
    16c6:	d1fc      	bne.n	16c2 <_spi_m_sync_init+0x1ae>
    16c8:	e7a7      	b.n	161a <_spi_m_sync_init+0x106>
	ASSERT(hw && regs);
    16ca:	2000      	movs	r0, #0
    16cc:	e7c5      	b.n	165a <_spi_m_sync_init+0x146>
    16ce:	2000      	movs	r0, #0
    16d0:	e7c3      	b.n	165a <_spi_m_sync_init+0x146>
	ASSERT(hw && regs);
    16d2:	2000      	movs	r0, #0
    16d4:	e775      	b.n	15c2 <_spi_m_sync_init+0xae>
    16d6:	2000      	movs	r0, #0
    16d8:	e773      	b.n	15c2 <_spi_m_sync_init+0xae>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
    16da:	2302      	movs	r3, #2
    16dc:	e7a1      	b.n	1622 <_spi_m_sync_init+0x10e>
		return ERR_INVALID_ARG;
    16de:	200d      	movs	r0, #13
    16e0:	4240      	negs	r0, r0
    16e2:	e7a5      	b.n	1630 <_spi_m_sync_init+0x11c>
    16e4:	00001505 	.word	0x00001505
    16e8:	00000925 	.word	0x00000925
    16ec:	00002304 	.word	0x00002304
    16f0:	00000c81 	.word	0x00000c81
    16f4:	000008ef 	.word	0x000008ef
    16f8:	fffffefc 	.word	0xfffffefc
    16fc:	fffd1dbf 	.word	0xfffd1dbf
    1700:	000022b4 	.word	0x000022b4
    1704:	00000903 	.word	0x00000903
    1708:	fffdddbf 	.word	0xfffdddbf
    170c:	00020240 	.word	0x00020240

00001710 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
    1710:	b5f0      	push	{r4, r5, r6, r7, lr}
    1712:	46ce      	mov	lr, r9
    1714:	4647      	mov	r7, r8
    1716:	b580      	push	{r7, lr}
    1718:	b089      	sub	sp, #36	; 0x24
    171a:	4681      	mov	r9, r0
    171c:	000d      	movs	r5, r1
	void *                 hw   = dev->prvt;
    171e:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
    1720:	680b      	ldr	r3, [r1, #0]
    1722:	9303      	str	r3, [sp, #12]
    1724:	684b      	ldr	r3, [r1, #4]
    1726:	9304      	str	r3, [sp, #16]
    1728:	2300      	movs	r3, #0
    172a:	9305      	str	r3, [sp, #20]
    172c:	9306      	str	r3, [sp, #24]
    172e:	7906      	ldrb	r6, [r0, #4]

	ASSERT(dev && hw);
    1730:	2800      	cmp	r0, #0
    1732:	d014      	beq.n	175e <_spi_m_sync_trans+0x4e>
    1734:	2c00      	cmp	r4, #0
    1736:	d010      	beq.n	175a <_spi_m_sync_trans+0x4a>
    1738:	2001      	movs	r0, #1
    173a:	4a37      	ldr	r2, [pc, #220]	; (1818 <_spi_m_sync_trans+0x108>)
    173c:	4937      	ldr	r1, [pc, #220]	; (181c <_spi_m_sync_trans+0x10c>)
    173e:	4b38      	ldr	r3, [pc, #224]	; (1820 <_spi_m_sync_trans+0x110>)
    1740:	4798      	blx	r3
    1742:	69e3      	ldr	r3, [r4, #28]

	/* If settings are not applied (pending), we can not go on */
	if (hri_sercomspi_is_syncing(
    1744:	075b      	lsls	r3, r3, #29
    1746:	d164      	bne.n	1812 <_spi_m_sync_trans+0x102>
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
    1748:	69e3      	ldr	r3, [r4, #28]
    174a:	079b      	lsls	r3, r3, #30
    174c:	d1fc      	bne.n	1748 <_spi_m_sync_trans+0x38>
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
    174e:	6823      	ldr	r3, [r4, #0]
	        hw, (SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE | SERCOM_SPI_SYNCBUSY_CTRLB))) {
		return ERR_BUSY;
	}

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_sercomspi_get_CTRLA_ENABLE_bit(hw)) {
    1750:	079b      	lsls	r3, r3, #30
    1752:	d420      	bmi.n	1796 <_spi_m_sync_trans+0x86>
		return ERR_NOT_INITIALIZED;
    1754:	2014      	movs	r0, #20
    1756:	4240      	negs	r0, r0
    1758:	e056      	b.n	1808 <_spi_m_sync_trans+0xf8>
	ASSERT(dev && hw);
    175a:	2000      	movs	r0, #0
    175c:	e7ed      	b.n	173a <_spi_m_sync_trans+0x2a>
    175e:	2000      	movs	r0, #0
    1760:	e7eb      	b.n	173a <_spi_m_sync_trans+0x2a>
		return false;
    1762:	2200      	movs	r2, #0
    1764:	e02d      	b.n	17c2 <_spi_m_sync_trans+0xb2>
			data |= (*ctrl->txbuf) << 8;
    1766:	7848      	ldrb	r0, [r1, #1]
    1768:	0200      	lsls	r0, r0, #8
    176a:	4647      	mov	r7, r8
    176c:	4307      	orrs	r7, r0
    176e:	46b8      	mov	r8, r7
			ctrl->txbuf++;
    1770:	3102      	adds	r1, #2
    1772:	9103      	str	r1, [sp, #12]
	ctrl->txcnt++;
    1774:	3201      	adds	r2, #1
    1776:	9205      	str	r2, [sp, #20]
	((Sercom *)hw)->SPI.DATA.reg = data;
    1778:	4642      	mov	r2, r8
    177a:	62a2      	str	r2, [r4, #40]	; 0x28
	if (SERCOM_SPI_INTFLAG_ERROR & iflag) {
    177c:	b25b      	sxtb	r3, r3
    177e:	2b00      	cmp	r3, #0
    1780:	db35      	blt.n	17ee <_spi_m_sync_trans+0xde>
	return ERR_NONE;
    1782:	2000      	movs	r0, #0
			}
		}

		rc = _spi_err_check(iflag, hw);

		if (rc < 0) {
    1784:	2800      	cmp	r0, #0
    1786:	db3a      	blt.n	17fe <_spi_m_sync_trans+0xee>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
    1788:	9805      	ldr	r0, [sp, #20]
    178a:	68ab      	ldr	r3, [r5, #8]
    178c:	4298      	cmp	r0, r3
    178e:	d302      	bcc.n	1796 <_spi_m_sync_trans+0x86>
    1790:	9a06      	ldr	r2, [sp, #24]
    1792:	4293      	cmp	r3, r2
    1794:	d933      	bls.n	17fe <_spi_m_sync_trans+0xee>
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
    1796:	7e23      	ldrb	r3, [r4, #24]
    1798:	b2db      	uxtb	r3, r3
	if (!(iflag & SERCOM_SPI_INTFLAG_RXC)) {
    179a:	075a      	lsls	r2, r3, #29
    179c:	d5e1      	bpl.n	1762 <_spi_m_sync_trans+0x52>
	return ((Sercom *)hw)->SPI.DATA.reg;
    179e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	if (ctrl->rxbuf) {
    17a0:	9a04      	ldr	r2, [sp, #16]
    17a2:	2a00      	cmp	r2, #0
    17a4:	d008      	beq.n	17b8 <_spi_m_sync_trans+0xa8>
		*ctrl->rxbuf++ = (uint8_t)data;
    17a6:	1c50      	adds	r0, r2, #1
    17a8:	9004      	str	r0, [sp, #16]
    17aa:	7011      	strb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
    17ac:	2e01      	cmp	r6, #1
    17ae:	d903      	bls.n	17b8 <_spi_m_sync_trans+0xa8>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
    17b0:	1c90      	adds	r0, r2, #2
    17b2:	9004      	str	r0, [sp, #16]
    17b4:	0a09      	lsrs	r1, r1, #8
    17b6:	7051      	strb	r1, [r2, #1]
	ctrl->rxcnt++;
    17b8:	9a06      	ldr	r2, [sp, #24]
    17ba:	9201      	str	r2, [sp, #4]
    17bc:	3201      	adds	r2, #1
    17be:	9206      	str	r2, [sp, #24]
	return true;
    17c0:	2201      	movs	r2, #1
		if (!_spi_rx_check_and_receive(hw, iflag, &ctrl)) {
    17c2:	2a00      	cmp	r2, #0
    17c4:	d1da      	bne.n	177c <_spi_m_sync_trans+0x6c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
    17c6:	9906      	ldr	r1, [sp, #24]
    17c8:	9a05      	ldr	r2, [sp, #20]
    17ca:	4291      	cmp	r1, r2
    17cc:	d3d6      	bcc.n	177c <_spi_m_sync_trans+0x6c>
				_spi_tx_check_and_send(hw, iflag, &ctrl, dev->dummy_byte);
    17ce:	4649      	mov	r1, r9
    17d0:	88c8      	ldrh	r0, [r1, #6]
	if (!(SERCOM_SPI_INTFLAG_DRE & iflag)) {
    17d2:	07d9      	lsls	r1, r3, #31
    17d4:	d5d2      	bpl.n	177c <_spi_m_sync_trans+0x6c>
	if (ctrl->txbuf) {
    17d6:	9903      	ldr	r1, [sp, #12]
    17d8:	2900      	cmp	r1, #0
    17da:	d006      	beq.n	17ea <_spi_m_sync_trans+0xda>
		data = *ctrl->txbuf++;
    17dc:	1c48      	adds	r0, r1, #1
    17de:	9003      	str	r0, [sp, #12]
    17e0:	7808      	ldrb	r0, [r1, #0]
    17e2:	4680      	mov	r8, r0
		if (ctrl->char_size > 1) {
    17e4:	2e01      	cmp	r6, #1
    17e6:	d8be      	bhi.n	1766 <_spi_m_sync_trans+0x56>
    17e8:	e7c4      	b.n	1774 <_spi_m_sync_trans+0x64>
		data = dummy;
    17ea:	4680      	mov	r8, r0
    17ec:	e7c2      	b.n	1774 <_spi_m_sync_trans+0x64>
}

static inline void hri_sercomspi_clear_STATUS_reg(const void *const hw, hri_sercomspi_status_reg_t mask)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.STATUS.reg = mask;
    17ee:	2301      	movs	r3, #1
    17f0:	425b      	negs	r3, r3
    17f2:	8363      	strh	r3, [r4, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    17f4:	3381      	adds	r3, #129	; 0x81
    17f6:	7623      	strb	r3, [r4, #24]
		return ERR_OVERFLOW;
    17f8:	2013      	movs	r0, #19
    17fa:	4240      	negs	r0, r0
    17fc:	e7c2      	b.n	1784 <_spi_m_sync_trans+0x74>
	tmp = ((Sercom *)hw)->SPI.INTFLAG.reg;
    17fe:	7e23      	ldrb	r3, [r4, #24]
	while (!(hri_sercomspi_get_INTFLAG_reg(hw, SERCOM_SPI_INTFLAG_TXC | SERCOM_SPI_INTFLAG_DRE))) {
    1800:	079b      	lsls	r3, r3, #30
    1802:	d0fc      	beq.n	17fe <_spi_m_sync_trans+0xee>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
    1804:	2303      	movs	r3, #3
    1806:	7623      	strb	r3, [r4, #24]
	}
	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
    1808:	b009      	add	sp, #36	; 0x24
    180a:	bc0c      	pop	{r2, r3}
    180c:	4690      	mov	r8, r2
    180e:	4699      	mov	r9, r3
    1810:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return ERR_BUSY;
    1812:	2004      	movs	r0, #4
    1814:	4240      	negs	r0, r0
    1816:	e7f7      	b.n	1808 <_spi_m_sync_trans+0xf8>
    1818:	00000a85 	.word	0x00000a85
    181c:	00002304 	.word	0x00002304
    1820:	00000c81 	.word	0x00000c81

00001824 <tc_interrupt_handler>:
 * \internal TC interrupt handler for Timer
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
    1824:	b510      	push	{r4, lr}
	void *const hw = device->hw;
    1826:	68c3      	ldr	r3, [r0, #12]
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_MC1;
}

static inline bool hri_tc_get_interrupt_OVF_bit(const void *const hw)
{
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
    1828:	7a9a      	ldrb	r2, [r3, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
    182a:	07d2      	lsls	r2, r2, #31
    182c:	d400      	bmi.n	1830 <tc_interrupt_handler+0xc>
		hri_tc_clear_interrupt_OVF_bit(hw);
		device->timer_cb.period_expired(device);
	}
}
    182e:	bd10      	pop	{r4, pc}
}

static inline void hri_tc_clear_interrupt_OVF_bit(const void *const hw)
{
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    1830:	2201      	movs	r2, #1
    1832:	729a      	strb	r2, [r3, #10]
		device->timer_cb.period_expired(device);
    1834:	6803      	ldr	r3, [r0, #0]
    1836:	4798      	blx	r3
}
    1838:	e7f9      	b.n	182e <tc_interrupt_handler+0xa>
	...

0000183c <_tc_init_irq_param>:
/**
 * \brief Init irq param with the given tc hardware instance
 */
static void _tc_init_irq_param(const void *const hw, void *dev)
{
	if (hw == TC0) {
    183c:	4b06      	ldr	r3, [pc, #24]	; (1858 <_tc_init_irq_param+0x1c>)
    183e:	4298      	cmp	r0, r3
    1840:	d003      	beq.n	184a <_tc_init_irq_param+0xe>
		_tc0_dev = (struct _timer_device *)dev;
	}
	if (hw == TC1) {
    1842:	4b06      	ldr	r3, [pc, #24]	; (185c <_tc_init_irq_param+0x20>)
    1844:	4298      	cmp	r0, r3
    1846:	d003      	beq.n	1850 <_tc_init_irq_param+0x14>
		_tc1_dev = (struct _timer_device *)dev;
	}
}
    1848:	4770      	bx	lr
		_tc0_dev = (struct _timer_device *)dev;
    184a:	4b05      	ldr	r3, [pc, #20]	; (1860 <_tc_init_irq_param+0x24>)
    184c:	6019      	str	r1, [r3, #0]
    184e:	e7f8      	b.n	1842 <_tc_init_irq_param+0x6>
		_tc1_dev = (struct _timer_device *)dev;
    1850:	4b03      	ldr	r3, [pc, #12]	; (1860 <_tc_init_irq_param+0x24>)
    1852:	6059      	str	r1, [r3, #4]
}
    1854:	e7f8      	b.n	1848 <_tc_init_irq_param+0xc>
    1856:	46c0      	nop			; (mov r8, r8)
    1858:	42003000 	.word	0x42003000
    185c:	42003400 	.word	0x42003400
    1860:	20000228 	.word	0x20000228

00001864 <get_tc_index>:
{
    1864:	b510      	push	{r4, lr}
 *
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	if ((uint32_t)TC4 == (uint32_t)hw) {
    1866:	4b11      	ldr	r3, [pc, #68]	; (18ac <get_tc_index+0x48>)
    1868:	4298      	cmp	r0, r3
    186a:	d011      	beq.n	1890 <get_tc_index+0x2c>
		return 4;
	}
	return (((uint32_t)hw - (uint32_t)TC0) >> 10);
    186c:	4b10      	ldr	r3, [pc, #64]	; (18b0 <get_tc_index+0x4c>)
    186e:	469c      	mov	ip, r3
    1870:	4460      	add	r0, ip
    1872:	0a80      	lsrs	r0, r0, #10
    1874:	b2c2      	uxtb	r2, r0
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
    1876:	2000      	movs	r0, #0
    1878:	2801      	cmp	r0, #1
    187a:	d80d      	bhi.n	1898 <get_tc_index+0x34>
		if (_tcs[i].number == index) {
    187c:	0083      	lsls	r3, r0, #2
    187e:	181b      	adds	r3, r3, r0
    1880:	0099      	lsls	r1, r3, #2
    1882:	4b0c      	ldr	r3, [pc, #48]	; (18b4 <get_tc_index+0x50>)
    1884:	5ccb      	ldrb	r3, [r1, r3]
    1886:	4293      	cmp	r3, r2
    1888:	d004      	beq.n	1894 <get_tc_index+0x30>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
    188a:	3001      	adds	r0, #1
    188c:	b2c0      	uxtb	r0, r0
    188e:	e7f3      	b.n	1878 <get_tc_index+0x14>
		return 4;
    1890:	2204      	movs	r2, #4
    1892:	e7f0      	b.n	1876 <get_tc_index+0x12>
			return i;
    1894:	b240      	sxtb	r0, r0
    1896:	e007      	b.n	18a8 <get_tc_index+0x44>
	ASSERT(false);
    1898:	22a3      	movs	r2, #163	; 0xa3
    189a:	0052      	lsls	r2, r2, #1
    189c:	4906      	ldr	r1, [pc, #24]	; (18b8 <get_tc_index+0x54>)
    189e:	2000      	movs	r0, #0
    18a0:	4b06      	ldr	r3, [pc, #24]	; (18bc <get_tc_index+0x58>)
    18a2:	4798      	blx	r3
	return -1;
    18a4:	2001      	movs	r0, #1
    18a6:	4240      	negs	r0, r0
}
    18a8:	bd10      	pop	{r4, pc}
    18aa:	46c0      	nop			; (mov r8, r8)
    18ac:	42004000 	.word	0x42004000
    18b0:	bdffd000 	.word	0xbdffd000
    18b4:	00002320 	.word	0x00002320
    18b8:	00002348 	.word	0x00002348
    18bc:	00000c81 	.word	0x00000c81

000018c0 <_timer_init>:
{
    18c0:	b570      	push	{r4, r5, r6, lr}
    18c2:	0006      	movs	r6, r0
    18c4:	000c      	movs	r4, r1
	int8_t i = get_tc_index(hw);
    18c6:	0008      	movs	r0, r1
    18c8:	4b65      	ldr	r3, [pc, #404]	; (1a60 <_timer_init+0x1a0>)
    18ca:	4798      	blx	r3
    18cc:	0005      	movs	r5, r0
	device->hw = hw;
    18ce:	60f4      	str	r4, [r6, #12]
	ASSERT(ARRAY_SIZE(_tcs));
    18d0:	228f      	movs	r2, #143	; 0x8f
    18d2:	4964      	ldr	r1, [pc, #400]	; (1a64 <_timer_init+0x1a4>)
    18d4:	2001      	movs	r0, #1
    18d6:	4b64      	ldr	r3, [pc, #400]	; (1a68 <_timer_init+0x1a8>)
    18d8:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
    18da:	6923      	ldr	r3, [r4, #16]
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
    18dc:	07db      	lsls	r3, r3, #31
    18de:	d414      	bmi.n	190a <_timer_init+0x4a>
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    18e0:	6923      	ldr	r3, [r4, #16]
    18e2:	079b      	lsls	r3, r3, #30
    18e4:	d1fc      	bne.n	18e0 <_timer_init+0x20>

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
    18e6:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
    18e8:	079b      	lsls	r3, r3, #30
    18ea:	d509      	bpl.n	1900 <_timer_init+0x40>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
    18ec:	6823      	ldr	r3, [r4, #0]
    18ee:	2202      	movs	r2, #2
    18f0:	4393      	bics	r3, r2
    18f2:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    18f4:	6923      	ldr	r3, [r4, #16]
    18f6:	079b      	lsls	r3, r3, #30
    18f8:	d1fc      	bne.n	18f4 <_timer_init+0x34>
    18fa:	6923      	ldr	r3, [r4, #16]
    18fc:	079b      	lsls	r3, r3, #30
    18fe:	d4fc      	bmi.n	18fa <_timer_init+0x3a>
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    1900:	2301      	movs	r3, #1
    1902:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    1904:	6923      	ldr	r3, [r4, #16]
    1906:	079b      	lsls	r3, r3, #30
    1908:	d1fc      	bne.n	1904 <_timer_init+0x44>
    190a:	6923      	ldr	r3, [r4, #16]
    190c:	07db      	lsls	r3, r3, #31
    190e:	d4fc      	bmi.n	190a <_timer_init+0x4a>
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
    1910:	00ab      	lsls	r3, r5, #2
    1912:	195b      	adds	r3, r3, r5
    1914:	009a      	lsls	r2, r3, #2
    1916:	4b55      	ldr	r3, [pc, #340]	; (1a6c <_timer_init+0x1ac>)
    1918:	189b      	adds	r3, r3, r2
    191a:	685b      	ldr	r3, [r3, #4]
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
    191c:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    191e:	6923      	ldr	r3, [r4, #16]
    1920:	079b      	lsls	r3, r3, #30
    1922:	d1fc      	bne.n	191e <_timer_init+0x5e>
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
    1924:	00aa      	lsls	r2, r5, #2
    1926:	1952      	adds	r2, r2, r5
    1928:	0091      	lsls	r1, r2, #2
    192a:	4b50      	ldr	r3, [pc, #320]	; (1a6c <_timer_init+0x1ac>)
    192c:	185b      	adds	r3, r3, r1
    192e:	7a9a      	ldrb	r2, [r3, #10]
}

static inline void hri_tc_write_DBGCTRL_reg(const void *const hw, hri_tc_dbgctrl_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
    1930:	73e2      	strb	r2, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
    1932:	891a      	ldrh	r2, [r3, #8]
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
    1934:	80e2      	strh	r2, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
    1936:	2201      	movs	r2, #1
    1938:	7322      	strb	r2, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
    193a:	685a      	ldr	r2, [r3, #4]
    193c:	230c      	movs	r3, #12
    193e:	4013      	ands	r3, r2
    1940:	2b08      	cmp	r3, #8
    1942:	d056      	beq.n	19f2 <_timer_init+0x132>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
    1944:	2b00      	cmp	r3, #0
    1946:	d168      	bne.n	1a1a <_timer_init+0x15a>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
    1948:	00ab      	lsls	r3, r5, #2
    194a:	195b      	adds	r3, r3, r5
    194c:	009a      	lsls	r2, r3, #2
    194e:	4b47      	ldr	r3, [pc, #284]	; (1a6c <_timer_init+0x1ac>)
    1950:	189b      	adds	r3, r3, r2
    1952:	899b      	ldrh	r3, [r3, #12]
}

static inline void hri_tccount16_write_CC_reg(const void *const hw, uint8_t index, hri_tccount16_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    1954:	83a3      	strh	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    1956:	6923      	ldr	r3, [r4, #16]
    1958:	22c0      	movs	r2, #192	; 0xc0
    195a:	421a      	tst	r2, r3
    195c:	d1fb      	bne.n	1956 <_timer_init+0x96>
		hri_tccount16_write_CC_reg(hw, 1, (uint16_t)_tcs[i].cc1);
    195e:	00ab      	lsls	r3, r5, #2
    1960:	195b      	adds	r3, r3, r5
    1962:	009a      	lsls	r2, r3, #2
    1964:	4b41      	ldr	r3, [pc, #260]	; (1a6c <_timer_init+0x1ac>)
    1966:	189b      	adds	r3, r3, r2
    1968:	8a1b      	ldrh	r3, [r3, #16]
	((Tc *)hw)->COUNT16.CC[index].reg = data;
    196a:	83e3      	strh	r3, [r4, #30]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    196c:	6923      	ldr	r3, [r4, #16]
    196e:	22c0      	movs	r2, #192	; 0xc0
    1970:	421a      	tst	r2, r3
    1972:	d1fb      	bne.n	196c <_timer_init+0xac>
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
    1974:	2301      	movs	r3, #1
    1976:	7263      	strb	r3, [r4, #9]
	_tc_init_irq_param(hw, (void *)device);
    1978:	0031      	movs	r1, r6
    197a:	0020      	movs	r0, r4
    197c:	4b3c      	ldr	r3, [pc, #240]	; (1a70 <_timer_init+0x1b0>)
    197e:	4798      	blx	r3
	NVIC_DisableIRQ(_tcs[i].irq);
    1980:	00ab      	lsls	r3, r5, #2
    1982:	195b      	adds	r3, r3, r5
    1984:	009a      	lsls	r2, r3, #2
    1986:	4b39      	ldr	r3, [pc, #228]	; (1a6c <_timer_init+0x1ac>)
    1988:	189b      	adds	r3, r3, r2
    198a:	785b      	ldrb	r3, [r3, #1]
    198c:	b25b      	sxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
    198e:	2b00      	cmp	r3, #0
    1990:	db0b      	blt.n	19aa <_timer_init+0xea>
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1992:	221f      	movs	r2, #31
    1994:	4013      	ands	r3, r2
    1996:	3a1e      	subs	r2, #30
    1998:	409a      	lsls	r2, r3
    199a:	0013      	movs	r3, r2
    199c:	2280      	movs	r2, #128	; 0x80
    199e:	4935      	ldr	r1, [pc, #212]	; (1a74 <_timer_init+0x1b4>)
    19a0:	508b      	str	r3, [r1, r2]
  __ASM volatile ("dsb 0xF":::"memory");
    19a2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    19a6:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
    19aa:	00ab      	lsls	r3, r5, #2
    19ac:	195b      	adds	r3, r3, r5
    19ae:	009a      	lsls	r2, r3, #2
    19b0:	4b2e      	ldr	r3, [pc, #184]	; (1a6c <_timer_init+0x1ac>)
    19b2:	189b      	adds	r3, r3, r2
    19b4:	785b      	ldrb	r3, [r3, #1]
    19b6:	b25b      	sxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
    19b8:	2b00      	cmp	r3, #0
    19ba:	db08      	blt.n	19ce <_timer_init+0x10e>
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    19bc:	221f      	movs	r2, #31
    19be:	4013      	ands	r3, r2
    19c0:	3a1e      	subs	r2, #30
    19c2:	409a      	lsls	r2, r3
    19c4:	0013      	movs	r3, r2
    19c6:	22c0      	movs	r2, #192	; 0xc0
    19c8:	0052      	lsls	r2, r2, #1
    19ca:	492a      	ldr	r1, [pc, #168]	; (1a74 <_timer_init+0x1b4>)
    19cc:	508b      	str	r3, [r1, r2]
	NVIC_EnableIRQ(_tcs[i].irq);
    19ce:	00ab      	lsls	r3, r5, #2
    19d0:	195d      	adds	r5, r3, r5
    19d2:	00aa      	lsls	r2, r5, #2
    19d4:	4b25      	ldr	r3, [pc, #148]	; (1a6c <_timer_init+0x1ac>)
    19d6:	189b      	adds	r3, r3, r2
    19d8:	785b      	ldrb	r3, [r3, #1]
    19da:	b25b      	sxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
    19dc:	2b00      	cmp	r3, #0
    19de:	db06      	blt.n	19ee <_timer_init+0x12e>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    19e0:	221f      	movs	r2, #31
    19e2:	4013      	ands	r3, r2
    19e4:	3a1e      	subs	r2, #30
    19e6:	409a      	lsls	r2, r3
    19e8:	0013      	movs	r3, r2
    19ea:	4a22      	ldr	r2, [pc, #136]	; (1a74 <_timer_init+0x1b4>)
    19ec:	6013      	str	r3, [r2, #0]
}
    19ee:	2000      	movs	r0, #0
    19f0:	bd70      	pop	{r4, r5, r6, pc}
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
    19f2:	4b1e      	ldr	r3, [pc, #120]	; (1a6c <_timer_init+0x1ac>)
    19f4:	185b      	adds	r3, r3, r1
    19f6:	68db      	ldr	r3, [r3, #12]
}

static inline void hri_tccount32_write_CC_reg(const void *const hw, uint8_t index, hri_tccount32_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    19f8:	61e3      	str	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    19fa:	6923      	ldr	r3, [r4, #16]
    19fc:	22c0      	movs	r2, #192	; 0xc0
    19fe:	421a      	tst	r2, r3
    1a00:	d1fb      	bne.n	19fa <_timer_init+0x13a>
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
    1a02:	00ab      	lsls	r3, r5, #2
    1a04:	195b      	adds	r3, r3, r5
    1a06:	009a      	lsls	r2, r3, #2
    1a08:	4b18      	ldr	r3, [pc, #96]	; (1a6c <_timer_init+0x1ac>)
    1a0a:	189b      	adds	r3, r3, r2
    1a0c:	691b      	ldr	r3, [r3, #16]
	((Tc *)hw)->COUNT32.CC[index].reg = data;
    1a0e:	6223      	str	r3, [r4, #32]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    1a10:	6923      	ldr	r3, [r4, #16]
    1a12:	22c0      	movs	r2, #192	; 0xc0
    1a14:	421a      	tst	r2, r3
    1a16:	d1fb      	bne.n	1a10 <_timer_init+0x150>
    1a18:	e7ac      	b.n	1974 <_timer_init+0xb4>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
    1a1a:	2b04      	cmp	r3, #4
    1a1c:	d1aa      	bne.n	1974 <_timer_init+0xb4>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
    1a1e:	00ab      	lsls	r3, r5, #2
    1a20:	195b      	adds	r3, r3, r5
    1a22:	009a      	lsls	r2, r3, #2
    1a24:	4b11      	ldr	r3, [pc, #68]	; (1a6c <_timer_init+0x1ac>)
    1a26:	189b      	adds	r3, r3, r2
    1a28:	7b1b      	ldrb	r3, [r3, #12]
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    1a2a:	7723      	strb	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    1a2c:	6923      	ldr	r3, [r4, #16]
    1a2e:	22c0      	movs	r2, #192	; 0xc0
    1a30:	421a      	tst	r2, r3
    1a32:	d1fb      	bne.n	1a2c <_timer_init+0x16c>
		hri_tccount8_write_CC_reg(hw, 1, (uint8_t)_tcs[i].cc1);
    1a34:	00ab      	lsls	r3, r5, #2
    1a36:	195b      	adds	r3, r3, r5
    1a38:	009a      	lsls	r2, r3, #2
    1a3a:	4b0c      	ldr	r3, [pc, #48]	; (1a6c <_timer_init+0x1ac>)
    1a3c:	189b      	adds	r3, r3, r2
    1a3e:	7c1b      	ldrb	r3, [r3, #16]
	((Tc *)hw)->COUNT8.CC[index].reg = data;
    1a40:	7763      	strb	r3, [r4, #29]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    1a42:	6923      	ldr	r3, [r4, #16]
    1a44:	22c0      	movs	r2, #192	; 0xc0
    1a46:	421a      	tst	r2, r3
    1a48:	d1fb      	bne.n	1a42 <_timer_init+0x182>
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
    1a4a:	00ab      	lsls	r3, r5, #2
    1a4c:	195b      	adds	r3, r3, r5
    1a4e:	009a      	lsls	r2, r3, #2
    1a50:	4b06      	ldr	r3, [pc, #24]	; (1a6c <_timer_init+0x1ac>)
    1a52:	189b      	adds	r3, r3, r2
    1a54:	7adb      	ldrb	r3, [r3, #11]
	((Tc *)hw)->COUNT8.PER.reg = data;
    1a56:	76e3      	strb	r3, [r4, #27]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
    1a58:	6923      	ldr	r3, [r4, #16]
    1a5a:	069b      	lsls	r3, r3, #26
    1a5c:	d4fc      	bmi.n	1a58 <_timer_init+0x198>
    1a5e:	e789      	b.n	1974 <_timer_init+0xb4>
    1a60:	00001865 	.word	0x00001865
    1a64:	00002348 	.word	0x00002348
    1a68:	00000c81 	.word	0x00000c81
    1a6c:	00002320 	.word	0x00002320
    1a70:	0000183d 	.word	0x0000183d
    1a74:	e000e100 	.word	0xe000e100

00001a78 <_tc_get_timer>:
}
    1a78:	2000      	movs	r0, #0
    1a7a:	4770      	bx	lr

00001a7c <TC0_Handler>:
{
    1a7c:	b510      	push	{r4, lr}
	tc_interrupt_handler(_tc0_dev);
    1a7e:	4b02      	ldr	r3, [pc, #8]	; (1a88 <TC0_Handler+0xc>)
    1a80:	6818      	ldr	r0, [r3, #0]
    1a82:	4b02      	ldr	r3, [pc, #8]	; (1a8c <TC0_Handler+0x10>)
    1a84:	4798      	blx	r3
}
    1a86:	bd10      	pop	{r4, pc}
    1a88:	20000228 	.word	0x20000228
    1a8c:	00001825 	.word	0x00001825

00001a90 <TC1_Handler>:
{
    1a90:	b510      	push	{r4, lr}
	tc_interrupt_handler(_tc1_dev);
    1a92:	4b02      	ldr	r3, [pc, #8]	; (1a9c <TC1_Handler+0xc>)
    1a94:	6858      	ldr	r0, [r3, #4]
    1a96:	4b02      	ldr	r3, [pc, #8]	; (1aa0 <TC1_Handler+0x10>)
    1a98:	4798      	blx	r3
}
    1a9a:	bd10      	pop	{r4, pc}
    1a9c:	20000228 	.word	0x20000228
    1aa0:	00001825 	.word	0x00001825

00001aa4 <_wdt_init>:

/**
 * \brief WDT initialization function
 */
int32_t _wdt_init(struct wdt_dev *const dev)
{
    1aa4:	b510      	push	{r4, lr}
    1aa6:	1e04      	subs	r4, r0, #0
	/* Sanity check arguments */
	ASSERT(dev && dev->hw);
    1aa8:	d027      	beq.n	1afa <_wdt_init+0x56>
    1aaa:	6803      	ldr	r3, [r0, #0]
    1aac:	2b00      	cmp	r3, #0
    1aae:	d022      	beq.n	1af6 <_wdt_init+0x52>
    1ab0:	2001      	movs	r0, #1
    1ab2:	2250      	movs	r2, #80	; 0x50
    1ab4:	4915      	ldr	r1, [pc, #84]	; (1b0c <_wdt_init+0x68>)
    1ab6:	4b16      	ldr	r3, [pc, #88]	; (1b10 <_wdt_init+0x6c>)
    1ab8:	4798      	blx	r3

	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
    1aba:	6823      	ldr	r3, [r4, #0]
typedef uint8_t  hri_wdt_intenset_reg_t;
typedef uint8_t  hri_wdt_intflag_reg_t;

static inline void hri_wdt_wait_for_sync(const void *const hw, hri_wdt_syncbusy_reg_t reg)
{
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    1abc:	689a      	ldr	r2, [r3, #8]
    1abe:	210e      	movs	r1, #14
    1ac0:	4211      	tst	r1, r2
    1ac2:	d1fb      	bne.n	1abc <_wdt_init+0x18>

static inline bool hri_wdt_get_CTRLA_ALWAYSON_bit(const void *const hw)
{
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	tmp = ((Wdt *)hw)->CTRLA.reg;
    1ac4:	781a      	ldrb	r2, [r3, #0]
	tmp = (tmp & WDT_CTRLA_ALWAYSON) >> WDT_CTRLA_ALWAYSON_Pos;
    1ac6:	09d2      	lsrs	r2, r2, #7
    1ac8:	d119      	bne.n	1afe <_wdt_init+0x5a>
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    1aca:	689a      	ldr	r2, [r3, #8]
    1acc:	210e      	movs	r1, #14
    1ace:	4211      	tst	r1, r2
    1ad0:	d1fb      	bne.n	1aca <_wdt_init+0x26>
	tmp = ((Wdt *)hw)->CTRLA.reg;
    1ad2:	781a      	ldrb	r2, [r3, #0]
    1ad4:	0792      	lsls	r2, r2, #30
    1ad6:	d415      	bmi.n	1b04 <_wdt_init+0x60>
	((Wdt *)hw)->CTRLA.reg &= ~WDT_CTRLA_WEN;
    1ad8:	781a      	ldrb	r2, [r3, #0]
    1ada:	390a      	subs	r1, #10
    1adc:	438a      	bics	r2, r1
    1ade:	701a      	strb	r2, [r3, #0]
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    1ae0:	689a      	ldr	r2, [r3, #8]
    1ae2:	210e      	movs	r1, #14
    1ae4:	4211      	tst	r1, r2
    1ae6:	d1fb      	bne.n	1ae0 <_wdt_init+0x3c>
			hri_wdt_write_CONFIG_WINDOW_bf(dev->hw, CONF_WDT_WINDOW);
		} else {
			hri_wdt_clear_CTRLA_WEN_bit(dev->hw);
		}

		hri_wdt_write_CONFIG_PER_bf(dev->hw, CONF_WDT_PER);
    1ae8:	6822      	ldr	r2, [r4, #0]

static inline void hri_wdt_write_CONFIG_PER_bf(const void *const hw, hri_wdt_config_reg_t data)
{
	uint8_t tmp;
	WDT_CRITICAL_SECTION_ENTER();
	tmp = ((Wdt *)hw)->CONFIG.reg;
    1aea:	7853      	ldrb	r3, [r2, #1]
	tmp &= ~WDT_CONFIG_PER_Msk;
    1aec:	3101      	adds	r1, #1
    1aee:	438b      	bics	r3, r1
	tmp |= WDT_CONFIG_PER(data);
	((Wdt *)hw)->CONFIG.reg = tmp;
    1af0:	7053      	strb	r3, [r2, #1]
	}

	return ERR_NONE;
    1af2:	2000      	movs	r0, #0
}
    1af4:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->hw);
    1af6:	2000      	movs	r0, #0
    1af8:	e7db      	b.n	1ab2 <_wdt_init+0xe>
    1afa:	2000      	movs	r0, #0
    1afc:	e7d9      	b.n	1ab2 <_wdt_init+0xe>
		return ERR_DENIED;
    1afe:	2011      	movs	r0, #17
    1b00:	4240      	negs	r0, r0
    1b02:	e7f7      	b.n	1af4 <_wdt_init+0x50>
    1b04:	2011      	movs	r0, #17
    1b06:	4240      	negs	r0, r0
    1b08:	e7f4      	b.n	1af4 <_wdt_init+0x50>
    1b0a:	46c0      	nop			; (mov r8, r8)
    1b0c:	0000235c 	.word	0x0000235c
    1b10:	00000c81 	.word	0x00000c81

00001b14 <main>:
#include <atmel_start.h>
#include "drv_can.h"
int main(void)
{
    1b14:	b510      	push	{r4, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    1b16:	4b05      	ldr	r3, [pc, #20]	; (1b2c <main+0x18>)
    1b18:	4798      	blx	r3
//	CAN_0_example();
	CAN1_Init();
    1b1a:	4b05      	ldr	r3, [pc, #20]	; (1b30 <main+0x1c>)
    1b1c:	4798      	blx	r3
	/* Replace with your application code */
	while (1) {
		SEGGER_RTT_printf(0,"cnt = %d\r\n", u32cnt);
    1b1e:	4b05      	ldr	r3, [pc, #20]	; (1b34 <main+0x20>)
    1b20:	681a      	ldr	r2, [r3, #0]
    1b22:	4905      	ldr	r1, [pc, #20]	; (1b38 <main+0x24>)
    1b24:	2000      	movs	r0, #0
    1b26:	4b05      	ldr	r3, [pc, #20]	; (1b3c <main+0x28>)
    1b28:	4798      	blx	r3
    1b2a:	e7f8      	b.n	1b1e <main+0xa>
    1b2c:	0000011d 	.word	0x0000011d
    1b30:	0000053d 	.word	0x0000053d
    1b34:	20000044 	.word	0x20000044
    1b38:	00002374 	.word	0x00002374
    1b3c:	00002155 	.word	0x00002155

00001b40 <_GetAvailWriteSpace>:
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
    1b40:	6903      	ldr	r3, [r0, #16]
  WrOff = pRing->WrOff;
    1b42:	68c2      	ldr	r2, [r0, #12]
  if (RdOff <= WrOff) {
    1b44:	4293      	cmp	r3, r2
    1b46:	d902      	bls.n	1b4e <_GetAvailWriteSpace+0xe>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
  } else {
    r = RdOff - WrOff - 1u;
    1b48:	1a98      	subs	r0, r3, r2
    1b4a:	3801      	subs	r0, #1
  }
  return r;
}
    1b4c:	4770      	bx	lr
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
    1b4e:	6880      	ldr	r0, [r0, #8]
    1b50:	1a80      	subs	r0, r0, r2
    1b52:	1818      	adds	r0, r3, r0
    1b54:	3801      	subs	r0, #1
    1b56:	e7f9      	b.n	1b4c <_GetAvailWriteSpace+0xc>

00001b58 <_WriteNoCheck>:
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
    1b58:	b5f0      	push	{r4, r5, r6, r7, lr}
    1b5a:	b083      	sub	sp, #12
    1b5c:	0005      	movs	r5, r0
    1b5e:	9101      	str	r1, [sp, #4]
    1b60:	0016      	movs	r6, r2
  WrOff = pRing->WrOff;
    1b62:	68c7      	ldr	r7, [r0, #12]
  Rem = pRing->SizeOfBuffer - WrOff;
    1b64:	6883      	ldr	r3, [r0, #8]
    1b66:	1bdc      	subs	r4, r3, r7
  if (Rem > NumBytes) {
    1b68:	4294      	cmp	r4, r2
    1b6a:	d80e      	bhi.n	1b8a <_WriteNoCheck+0x32>
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    1b6c:	6843      	ldr	r3, [r0, #4]
    1b6e:	19d8      	adds	r0, r3, r7
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
    1b70:	0022      	movs	r2, r4
    1b72:	9901      	ldr	r1, [sp, #4]
    1b74:	4f08      	ldr	r7, [pc, #32]	; (1b98 <_WriteNoCheck+0x40>)
    1b76:	47b8      	blx	r7
    NumBytesAtOnce = NumBytes - Rem;
    1b78:	1b36      	subs	r6, r6, r4
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    1b7a:	9b01      	ldr	r3, [sp, #4]
    1b7c:	1919      	adds	r1, r3, r4
    1b7e:	0032      	movs	r2, r6
    1b80:	6868      	ldr	r0, [r5, #4]
    1b82:	47b8      	blx	r7
    pRing->WrOff = NumBytesAtOnce;
    1b84:	60ee      	str	r6, [r5, #12]
}
    1b86:	b003      	add	sp, #12
    1b88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    1b8a:	6843      	ldr	r3, [r0, #4]
    1b8c:	19d8      	adds	r0, r3, r7
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
    1b8e:	4b02      	ldr	r3, [pc, #8]	; (1b98 <_WriteNoCheck+0x40>)
    1b90:	4798      	blx	r3
    pRing->WrOff = WrOff + NumBytes;
    1b92:	19be      	adds	r6, r7, r6
    1b94:	60ee      	str	r6, [r5, #12]
    1b96:	e7f6      	b.n	1b86 <_WriteNoCheck+0x2e>
    1b98:	000021bd 	.word	0x000021bd

00001b9c <_WriteBlocking>:
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
    1b9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1b9e:	46ce      	mov	lr, r9
    1ba0:	4647      	mov	r7, r8
    1ba2:	b580      	push	{r7, lr}
    1ba4:	0005      	movs	r5, r0
    1ba6:	4689      	mov	r9, r1
    1ba8:	0016      	movs	r6, r2
  WrOff = pRing->WrOff;
    1baa:	68c4      	ldr	r4, [r0, #12]
  NumBytesWritten = 0u;
    1bac:	2300      	movs	r3, #0
    1bae:	4698      	mov	r8, r3
    1bb0:	e015      	b.n	1bde <_WriteBlocking+0x42>
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
    1bb2:	1b1b      	subs	r3, r3, r4
    1bb4:	68aa      	ldr	r2, [r5, #8]
    1bb6:	4694      	mov	ip, r2
    1bb8:	4463      	add	r3, ip
    1bba:	3b01      	subs	r3, #1
    1bbc:	e014      	b.n	1be8 <_WriteBlocking+0x4c>
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    1bbe:	686b      	ldr	r3, [r5, #4]
    1bc0:	1918      	adds	r0, r3, r4
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
    1bc2:	003a      	movs	r2, r7
    1bc4:	4649      	mov	r1, r9
    1bc6:	4b11      	ldr	r3, [pc, #68]	; (1c0c <_WriteBlocking+0x70>)
    1bc8:	4798      	blx	r3
    NumBytesWritten += NumBytesToWrite;
    1bca:	44b8      	add	r8, r7
    pBuffer         += NumBytesToWrite;
    1bcc:	44b9      	add	r9, r7
    NumBytes        -= NumBytesToWrite;
    1bce:	1bf6      	subs	r6, r6, r7
    WrOff           += NumBytesToWrite;
    1bd0:	19e4      	adds	r4, r4, r7
    if (WrOff == pRing->SizeOfBuffer) {
    1bd2:	68ab      	ldr	r3, [r5, #8]
    1bd4:	429c      	cmp	r4, r3
    1bd6:	d011      	beq.n	1bfc <_WriteBlocking+0x60>
    pRing->WrOff = WrOff;
    1bd8:	60ec      	str	r4, [r5, #12]
  } while (NumBytes);
    1bda:	2e00      	cmp	r6, #0
    1bdc:	d010      	beq.n	1c00 <_WriteBlocking+0x64>
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
    1bde:	692b      	ldr	r3, [r5, #16]
    if (RdOff > WrOff) {
    1be0:	429c      	cmp	r4, r3
    1be2:	d2e6      	bcs.n	1bb2 <_WriteBlocking+0x16>
      NumBytesToWrite = RdOff - WrOff - 1u;
    1be4:	1b1b      	subs	r3, r3, r4
    1be6:	3b01      	subs	r3, #1
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
    1be8:	68aa      	ldr	r2, [r5, #8]
    1bea:	1b12      	subs	r2, r2, r4
    1bec:	4293      	cmp	r3, r2
    1bee:	d900      	bls.n	1bf2 <_WriteBlocking+0x56>
    1bf0:	0013      	movs	r3, r2
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
    1bf2:	0037      	movs	r7, r6
    1bf4:	429e      	cmp	r6, r3
    1bf6:	d9e2      	bls.n	1bbe <_WriteBlocking+0x22>
    1bf8:	001f      	movs	r7, r3
    1bfa:	e7e0      	b.n	1bbe <_WriteBlocking+0x22>
      WrOff = 0u;
    1bfc:	2400      	movs	r4, #0
    1bfe:	e7eb      	b.n	1bd8 <_WriteBlocking+0x3c>
}
    1c00:	4640      	mov	r0, r8
    1c02:	bc0c      	pop	{r2, r3}
    1c04:	4690      	mov	r8, r2
    1c06:	4699      	mov	r9, r3
    1c08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1c0a:	46c0      	nop			; (mov r8, r8)
    1c0c:	000021bd 	.word	0x000021bd

00001c10 <_DoInit>:
static void _DoInit(void) {
    1c10:	b510      	push	{r4, lr}
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
    1c12:	4c14      	ldr	r4, [pc, #80]	; (1c64 <_DoInit+0x54>)
    1c14:	22a8      	movs	r2, #168	; 0xa8
    1c16:	2100      	movs	r1, #0
    1c18:	0020      	movs	r0, r4
    1c1a:	4b13      	ldr	r3, [pc, #76]	; (1c68 <_DoInit+0x58>)
    1c1c:	4798      	blx	r3
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    1c1e:	2303      	movs	r3, #3
    1c20:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    1c22:	6163      	str	r3, [r4, #20]
  p->aUp[0].sName         = "Terminal";
    1c24:	4a11      	ldr	r2, [pc, #68]	; (1c6c <_DoInit+0x5c>)
    1c26:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    1c28:	4b11      	ldr	r3, [pc, #68]	; (1c70 <_DoInit+0x60>)
    1c2a:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
    1c2c:	2380      	movs	r3, #128	; 0x80
    1c2e:	00db      	lsls	r3, r3, #3
    1c30:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
    1c32:	2300      	movs	r3, #0
    1c34:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    1c36:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    1c38:	62e3      	str	r3, [r4, #44]	; 0x2c
  p->aDown[0].sName         = "Terminal";
    1c3a:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    1c3c:	4a0d      	ldr	r2, [pc, #52]	; (1c74 <_DoInit+0x64>)
    1c3e:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
    1c40:	2210      	movs	r2, #16
    1c42:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
    1c44:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    1c46:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    1c48:	6763      	str	r3, [r4, #116]	; 0x74
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
    1c4a:	e007      	b.n	1c5c <_DoInit+0x4c>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
    1c4c:	210f      	movs	r1, #15
    1c4e:	1ac9      	subs	r1, r1, r3
    1c50:	4a09      	ldr	r2, [pc, #36]	; (1c78 <_DoInit+0x68>)
    1c52:	1852      	adds	r2, r2, r1
    1c54:	7c11      	ldrb	r1, [r2, #16]
    1c56:	4a03      	ldr	r2, [pc, #12]	; (1c64 <_DoInit+0x54>)
    1c58:	54d1      	strb	r1, [r2, r3]
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
    1c5a:	3301      	adds	r3, #1
    1c5c:	2b0f      	cmp	r3, #15
    1c5e:	d9f5      	bls.n	1c4c <_DoInit+0x3c>
}
    1c60:	bd10      	pop	{r4, pc}
    1c62:	46c0      	nop			; (mov r8, r8)
    1c64:	20000cc4 	.word	0x20000cc4
    1c68:	000021cf 	.word	0x000021cf
    1c6c:	000023a4 	.word	0x000023a4
    1c70:	20000230 	.word	0x20000230
    1c74:	20000630 	.word	0x20000630
    1c78:	00002380 	.word	0x00002380

00001c7c <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    1c7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1c7e:	000f      	movs	r7, r1
    1c80:	0016      	movs	r6, r2
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
    1c82:	1c42      	adds	r2, r0, #1
    1c84:	0053      	lsls	r3, r2, #1
    1c86:	189b      	adds	r3, r3, r2
    1c88:	00dd      	lsls	r5, r3, #3
    1c8a:	4b17      	ldr	r3, [pc, #92]	; (1ce8 <SEGGER_RTT_WriteNoLock+0x6c>)
    1c8c:	18ed      	adds	r5, r5, r3
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
    1c8e:	0042      	lsls	r2, r0, #1
    1c90:	1810      	adds	r0, r2, r0
    1c92:	00c2      	lsls	r2, r0, #3
    1c94:	189b      	adds	r3, r3, r2
    1c96:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    1c98:	2c01      	cmp	r4, #1
    1c9a:	d011      	beq.n	1cc0 <SEGGER_RTT_WriteNoLock+0x44>
    1c9c:	2c00      	cmp	r4, #0
    1c9e:	d003      	beq.n	1ca8 <SEGGER_RTT_WriteNoLock+0x2c>
    1ca0:	2c02      	cmp	r4, #2
    1ca2:	d01b      	beq.n	1cdc <SEGGER_RTT_WriteNoLock+0x60>
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
    break;
  default:
    Status = 0u;
    1ca4:	2400      	movs	r4, #0
    break;
  }
  //
  // Finish up.
  //
  return Status;
    1ca6:	e017      	b.n	1cd8 <SEGGER_RTT_WriteNoLock+0x5c>
    Avail = _GetAvailWriteSpace(pRing);
    1ca8:	0028      	movs	r0, r5
    1caa:	4b10      	ldr	r3, [pc, #64]	; (1cec <SEGGER_RTT_WriteNoLock+0x70>)
    1cac:	4798      	blx	r3
    if (Avail < NumBytes) {
    1cae:	42b0      	cmp	r0, r6
    1cb0:	d312      	bcc.n	1cd8 <SEGGER_RTT_WriteNoLock+0x5c>
      _WriteNoCheck(pRing, pData, NumBytes);
    1cb2:	0032      	movs	r2, r6
    1cb4:	0039      	movs	r1, r7
    1cb6:	0028      	movs	r0, r5
    1cb8:	4b0d      	ldr	r3, [pc, #52]	; (1cf0 <SEGGER_RTT_WriteNoLock+0x74>)
    1cba:	4798      	blx	r3
      Status = NumBytes;
    1cbc:	0034      	movs	r4, r6
    1cbe:	e00b      	b.n	1cd8 <SEGGER_RTT_WriteNoLock+0x5c>
    Avail = _GetAvailWriteSpace(pRing);
    1cc0:	0028      	movs	r0, r5
    1cc2:	4b0a      	ldr	r3, [pc, #40]	; (1cec <SEGGER_RTT_WriteNoLock+0x70>)
    1cc4:	4798      	blx	r3
    Status = Avail < NumBytes ? Avail : NumBytes;
    1cc6:	0034      	movs	r4, r6
    1cc8:	4286      	cmp	r6, r0
    1cca:	d900      	bls.n	1cce <SEGGER_RTT_WriteNoLock+0x52>
    1ccc:	0004      	movs	r4, r0
    _WriteNoCheck(pRing, pData, Status);
    1cce:	0022      	movs	r2, r4
    1cd0:	0039      	movs	r1, r7
    1cd2:	0028      	movs	r0, r5
    1cd4:	4b06      	ldr	r3, [pc, #24]	; (1cf0 <SEGGER_RTT_WriteNoLock+0x74>)
    1cd6:	4798      	blx	r3
}
    1cd8:	0020      	movs	r0, r4
    1cda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Status = _WriteBlocking(pRing, pData, NumBytes);
    1cdc:	0032      	movs	r2, r6
    1cde:	0028      	movs	r0, r5
    1ce0:	4b04      	ldr	r3, [pc, #16]	; (1cf4 <SEGGER_RTT_WriteNoLock+0x78>)
    1ce2:	4798      	blx	r3
    1ce4:	0004      	movs	r4, r0
    break;
    1ce6:	e7f7      	b.n	1cd8 <SEGGER_RTT_WriteNoLock+0x5c>
    1ce8:	20000cc4 	.word	0x20000cc4
    1cec:	00001b41 	.word	0x00001b41
    1cf0:	00001b59 	.word	0x00001b59
    1cf4:	00001b9d 	.word	0x00001b9d

00001cf8 <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    1cf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1cfa:	0005      	movs	r5, r0
    1cfc:	000e      	movs	r6, r1
    1cfe:	0017      	movs	r7, r2
  unsigned Status;

  INIT();
    1d00:	4b09      	ldr	r3, [pc, #36]	; (1d28 <SEGGER_RTT_Write+0x30>)
    1d02:	781b      	ldrb	r3, [r3, #0]
    1d04:	2b00      	cmp	r3, #0
    1d06:	d00c      	beq.n	1d22 <SEGGER_RTT_Write+0x2a>
  SEGGER_RTT_LOCK();
    1d08:	f3ef 8410 	mrs	r4, PRIMASK
    1d0c:	2101      	movs	r1, #1
    1d0e:	f381 8810 	msr	PRIMASK, r1
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
    1d12:	003a      	movs	r2, r7
    1d14:	0031      	movs	r1, r6
    1d16:	0028      	movs	r0, r5
    1d18:	4b04      	ldr	r3, [pc, #16]	; (1d2c <SEGGER_RTT_Write+0x34>)
    1d1a:	4798      	blx	r3
  SEGGER_RTT_UNLOCK();
    1d1c:	f384 8810 	msr	PRIMASK, r4
  return Status;
}
    1d20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  INIT();
    1d22:	4b03      	ldr	r3, [pc, #12]	; (1d30 <SEGGER_RTT_Write+0x38>)
    1d24:	4798      	blx	r3
    1d26:	e7ef      	b.n	1d08 <SEGGER_RTT_Write+0x10>
    1d28:	20000cc4 	.word	0x20000cc4
    1d2c:	00001c7d 	.word	0x00001c7d
    1d30:	00001c11 	.word	0x00001c11

00001d34 <_StoreChar>:
*/
/*********************************************************************
*
*       _StoreChar
*/
static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
    1d34:	b510      	push	{r4, lr}
    1d36:	0004      	movs	r4, r0
  unsigned Cnt;

  Cnt = p->Cnt;
    1d38:	6882      	ldr	r2, [r0, #8]
  if ((Cnt + 1u) <= p->BufferSize) {
    1d3a:	1c53      	adds	r3, r2, #1
    1d3c:	6840      	ldr	r0, [r0, #4]
    1d3e:	4283      	cmp	r3, r0
    1d40:	d805      	bhi.n	1d4e <_StoreChar+0x1a>
    *(p->pBuffer + Cnt) = c;
    1d42:	6820      	ldr	r0, [r4, #0]
    1d44:	5481      	strb	r1, [r0, r2]
    p->Cnt = Cnt + 1u;
    1d46:	60a3      	str	r3, [r4, #8]
    p->ReturnValue++;
    1d48:	68e3      	ldr	r3, [r4, #12]
    1d4a:	3301      	adds	r3, #1
    1d4c:	60e3      	str	r3, [r4, #12]
  }
  //
  // Write part of string, when the buffer is full
  //
  if (p->Cnt == p->BufferSize) {
    1d4e:	68a2      	ldr	r2, [r4, #8]
    1d50:	6863      	ldr	r3, [r4, #4]
    1d52:	429a      	cmp	r2, r3
    1d54:	d000      	beq.n	1d58 <_StoreChar+0x24>
      p->ReturnValue = -1;
    } else {
      p->Cnt = 0u;
    }
  }
}
    1d56:	bd10      	pop	{r4, pc}
    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
    1d58:	6821      	ldr	r1, [r4, #0]
    1d5a:	6920      	ldr	r0, [r4, #16]
    1d5c:	4b05      	ldr	r3, [pc, #20]	; (1d74 <_StoreChar+0x40>)
    1d5e:	4798      	blx	r3
    1d60:	68a3      	ldr	r3, [r4, #8]
    1d62:	4298      	cmp	r0, r3
    1d64:	d003      	beq.n	1d6e <_StoreChar+0x3a>
      p->ReturnValue = -1;
    1d66:	2301      	movs	r3, #1
    1d68:	425b      	negs	r3, r3
    1d6a:	60e3      	str	r3, [r4, #12]
    1d6c:	e7f3      	b.n	1d56 <_StoreChar+0x22>
      p->Cnt = 0u;
    1d6e:	2300      	movs	r3, #0
    1d70:	60a3      	str	r3, [r4, #8]
}
    1d72:	e7f0      	b.n	1d56 <_StoreChar+0x22>
    1d74:	00001cf9 	.word	0x00001cf9

00001d78 <_PrintUnsigned>:

/*********************************************************************
*
*       _PrintUnsigned
*/
static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    1d78:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d7a:	46de      	mov	lr, fp
    1d7c:	464f      	mov	r7, r9
    1d7e:	4646      	mov	r6, r8
    1d80:	b5c0      	push	{r6, r7, lr}
    1d82:	b082      	sub	sp, #8
    1d84:	0006      	movs	r6, r0
    1d86:	9101      	str	r1, [sp, #4]
    1d88:	0015      	movs	r5, r2
    1d8a:	001c      	movs	r4, r3
    1d8c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1d8e:	4698      	mov	r8, r3
  unsigned Digit;
  unsigned Number;
  unsigned Width;
  char c;

  Number = v;
    1d90:	0008      	movs	r0, r1
  Digit = 1u;
  //
  // Get actual field width
  //
  Width = 1u;
    1d92:	2301      	movs	r3, #1
    1d94:	4699      	mov	r9, r3
  while (Number >= Base) {
    1d96:	e005      	b.n	1da4 <_PrintUnsigned+0x2c>
    Number = (Number / Base);
    1d98:	0029      	movs	r1, r5
    1d9a:	4b38      	ldr	r3, [pc, #224]	; (1e7c <_PrintUnsigned+0x104>)
    1d9c:	4798      	blx	r3
    Width++;
    1d9e:	2301      	movs	r3, #1
    1da0:	469c      	mov	ip, r3
    1da2:	44e1      	add	r9, ip
  while (Number >= Base) {
    1da4:	42a8      	cmp	r0, r5
    1da6:	d2f7      	bcs.n	1d98 <_PrintUnsigned+0x20>
  }
  if (NumDigits > Width) {
    1da8:	45a1      	cmp	r9, r4
    1daa:	d200      	bcs.n	1dae <_PrintUnsigned+0x36>
    Width = NumDigits;
    1dac:	46a1      	mov	r9, r4
  }
  //
  // Print leading chars if necessary
  //
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
    1dae:	2301      	movs	r3, #1
    1db0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    1db2:	401a      	ands	r2, r3
    1db4:	4693      	mov	fp, r2
    1db6:	d11a      	bne.n	1dee <_PrintUnsigned+0x76>
    if (FieldWidth != 0u) {
    1db8:	4643      	mov	r3, r8
    1dba:	2b00      	cmp	r3, #0
    1dbc:	d017      	beq.n	1dee <_PrintUnsigned+0x76>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
    1dbe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1dc0:	079b      	lsls	r3, r3, #30
    1dc2:	d503      	bpl.n	1dcc <_PrintUnsigned+0x54>
    1dc4:	2c00      	cmp	r4, #0
    1dc6:	d017      	beq.n	1df8 <_PrintUnsigned+0x80>
        c = '0';
      } else {
        c = ' ';
    1dc8:	2720      	movs	r7, #32
    1dca:	e000      	b.n	1dce <_PrintUnsigned+0x56>
    1dcc:	2720      	movs	r7, #32
      }
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1dce:	4643      	mov	r3, r8
    1dd0:	2b00      	cmp	r3, #0
    1dd2:	d00c      	beq.n	1dee <_PrintUnsigned+0x76>
    1dd4:	45c8      	cmp	r8, r9
    1dd6:	d90a      	bls.n	1dee <_PrintUnsigned+0x76>
        FieldWidth--;
    1dd8:	2301      	movs	r3, #1
    1dda:	425b      	negs	r3, r3
    1ddc:	469c      	mov	ip, r3
    1dde:	44e0      	add	r8, ip
        _StoreChar(pBufferDesc, c);
    1de0:	0039      	movs	r1, r7
    1de2:	0030      	movs	r0, r6
    1de4:	4b26      	ldr	r3, [pc, #152]	; (1e80 <_PrintUnsigned+0x108>)
    1de6:	4798      	blx	r3
        if (pBufferDesc->ReturnValue < 0) {
    1de8:	68f3      	ldr	r3, [r6, #12]
    1dea:	2b00      	cmp	r3, #0
    1dec:	daef      	bge.n	1dce <_PrintUnsigned+0x56>
          break;
        }
      }
    }
  }
  if (pBufferDesc->ReturnValue >= 0) {
    1dee:	68f3      	ldr	r3, [r6, #12]
    1df0:	2b00      	cmp	r3, #0
    1df2:	db3c      	blt.n	1e6e <_PrintUnsigned+0xf6>
    1df4:	2701      	movs	r7, #1
    1df6:	e008      	b.n	1e0a <_PrintUnsigned+0x92>
        c = '0';
    1df8:	2730      	movs	r7, #48	; 0x30
    1dfa:	e7e8      	b.n	1dce <_PrintUnsigned+0x56>
    //
    while (1) {
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
        NumDigits--;
      } else {
        Div = v / Digit;
    1dfc:	0039      	movs	r1, r7
    1dfe:	9801      	ldr	r0, [sp, #4]
    1e00:	4b1e      	ldr	r3, [pc, #120]	; (1e7c <_PrintUnsigned+0x104>)
    1e02:	4798      	blx	r3
        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
    1e04:	4285      	cmp	r5, r0
    1e06:	d804      	bhi.n	1e12 <_PrintUnsigned+0x9a>
          break;
        }
      }
      Digit *= Base;
    1e08:	436f      	muls	r7, r5
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
    1e0a:	2c01      	cmp	r4, #1
    1e0c:	d9f6      	bls.n	1dfc <_PrintUnsigned+0x84>
        NumDigits--;
    1e0e:	3c01      	subs	r4, #1
    1e10:	e7fa      	b.n	1e08 <_PrintUnsigned+0x90>
    }
    //
    // Output digits
    //
    do {
      Div = v / Digit;
    1e12:	0039      	movs	r1, r7
    1e14:	9801      	ldr	r0, [sp, #4]
    1e16:	4b19      	ldr	r3, [pc, #100]	; (1e7c <_PrintUnsigned+0x104>)
    1e18:	4798      	blx	r3
    1e1a:	0004      	movs	r4, r0
    1e1c:	0039      	movs	r1, r7
    1e1e:	9801      	ldr	r0, [sp, #4]
    1e20:	4b18      	ldr	r3, [pc, #96]	; (1e84 <_PrintUnsigned+0x10c>)
    1e22:	4798      	blx	r3
    1e24:	9101      	str	r1, [sp, #4]
      v -= Div * Digit;
      _StoreChar(pBufferDesc, _aV2C[Div]);
    1e26:	4b18      	ldr	r3, [pc, #96]	; (1e88 <_PrintUnsigned+0x110>)
    1e28:	5d19      	ldrb	r1, [r3, r4]
    1e2a:	0030      	movs	r0, r6
    1e2c:	4b14      	ldr	r3, [pc, #80]	; (1e80 <_PrintUnsigned+0x108>)
    1e2e:	4798      	blx	r3
      if (pBufferDesc->ReturnValue < 0) {
    1e30:	68f3      	ldr	r3, [r6, #12]
    1e32:	2b00      	cmp	r3, #0
    1e34:	db05      	blt.n	1e42 <_PrintUnsigned+0xca>
        break;
      }
      Digit /= Base;
    1e36:	0029      	movs	r1, r5
    1e38:	0038      	movs	r0, r7
    1e3a:	4b10      	ldr	r3, [pc, #64]	; (1e7c <_PrintUnsigned+0x104>)
    1e3c:	4798      	blx	r3
    1e3e:	1e07      	subs	r7, r0, #0
    } while (Digit);
    1e40:	d1e7      	bne.n	1e12 <_PrintUnsigned+0x9a>
    //
    // Print trailing spaces if necessary
    //
    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
    1e42:	465b      	mov	r3, fp
    1e44:	2b00      	cmp	r3, #0
    1e46:	d012      	beq.n	1e6e <_PrintUnsigned+0xf6>
      if (FieldWidth != 0u) {
    1e48:	4643      	mov	r3, r8
    1e4a:	2b00      	cmp	r3, #0
    1e4c:	d00f      	beq.n	1e6e <_PrintUnsigned+0xf6>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1e4e:	4643      	mov	r3, r8
    1e50:	2b00      	cmp	r3, #0
    1e52:	d00c      	beq.n	1e6e <_PrintUnsigned+0xf6>
    1e54:	45c8      	cmp	r8, r9
    1e56:	d90a      	bls.n	1e6e <_PrintUnsigned+0xf6>
          FieldWidth--;
    1e58:	2301      	movs	r3, #1
    1e5a:	425b      	negs	r3, r3
    1e5c:	469c      	mov	ip, r3
    1e5e:	44e0      	add	r8, ip
          _StoreChar(pBufferDesc, ' ');
    1e60:	2120      	movs	r1, #32
    1e62:	0030      	movs	r0, r6
    1e64:	4b06      	ldr	r3, [pc, #24]	; (1e80 <_PrintUnsigned+0x108>)
    1e66:	4798      	blx	r3
          if (pBufferDesc->ReturnValue < 0) {
    1e68:	68f3      	ldr	r3, [r6, #12]
    1e6a:	2b00      	cmp	r3, #0
    1e6c:	daef      	bge.n	1e4e <_PrintUnsigned+0xd6>
          }
        }
      }
    }
  }
}
    1e6e:	b002      	add	sp, #8
    1e70:	bc1c      	pop	{r2, r3, r4}
    1e72:	4690      	mov	r8, r2
    1e74:	4699      	mov	r9, r3
    1e76:	46a3      	mov	fp, r4
    1e78:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1e7a:	46c0      	nop			; (mov r8, r8)
    1e7c:	00001375 	.word	0x00001375
    1e80:	00001d35 	.word	0x00001d35
    1e84:	000013ad 	.word	0x000013ad
    1e88:	000023b0 	.word	0x000023b0

00001e8c <_PrintInt>:

/*********************************************************************
*
*       _PrintInt
*/
static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    1e8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1e8e:	46d6      	mov	lr, sl
    1e90:	464f      	mov	r7, r9
    1e92:	b580      	push	{r7, lr}
    1e94:	b083      	sub	sp, #12
    1e96:	0006      	movs	r6, r0
    1e98:	4689      	mov	r9, r1
    1e9a:	0015      	movs	r5, r2
    1e9c:	469a      	mov	sl, r3
    1e9e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  unsigned Width;
  int Number;

  Number = (v < 0) ? -v : v;
    1ea0:	17ca      	asrs	r2, r1, #31
    1ea2:	1888      	adds	r0, r1, r2
    1ea4:	4050      	eors	r0, r2

  //
  // Get actual field width
  //
  Width = 1u;
    1ea6:	2401      	movs	r4, #1
  while (Number >= (int)Base) {
    1ea8:	e003      	b.n	1eb2 <_PrintInt+0x26>
    Number = (Number / (int)Base);
    1eaa:	0029      	movs	r1, r5
    1eac:	4b34      	ldr	r3, [pc, #208]	; (1f80 <_PrintInt+0xf4>)
    1eae:	4798      	blx	r3
    Width++;
    1eb0:	3401      	adds	r4, #1
  while (Number >= (int)Base) {
    1eb2:	42a8      	cmp	r0, r5
    1eb4:	daf9      	bge.n	1eaa <_PrintInt+0x1e>
  }
  if (NumDigits > Width) {
    1eb6:	4554      	cmp	r4, sl
    1eb8:	d200      	bcs.n	1ebc <_PrintInt+0x30>
    Width = NumDigits;
    1eba:	4654      	mov	r4, sl
  }
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
    1ebc:	2f00      	cmp	r7, #0
    1ebe:	d006      	beq.n	1ece <_PrintInt+0x42>
    1ec0:	464b      	mov	r3, r9
    1ec2:	2b00      	cmp	r3, #0
    1ec4:	db02      	blt.n	1ecc <_PrintInt+0x40>
    1ec6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1ec8:	075b      	lsls	r3, r3, #29
    1eca:	d500      	bpl.n	1ece <_PrintInt+0x42>
    FieldWidth--;
    1ecc:	3f01      	subs	r7, #1
  }

  //
  // Print leading spaces if necessary
  //
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
    1ece:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1ed0:	079b      	lsls	r3, r3, #30
    1ed2:	d502      	bpl.n	1eda <_PrintInt+0x4e>
    1ed4:	4653      	mov	r3, sl
    1ed6:	2b00      	cmp	r3, #0
    1ed8:	d004      	beq.n	1ee4 <_PrintInt+0x58>
    1eda:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1edc:	07db      	lsls	r3, r3, #31
    1ede:	d401      	bmi.n	1ee4 <_PrintInt+0x58>
    if (FieldWidth != 0u) {
    1ee0:	2f00      	cmp	r7, #0
    1ee2:	d121      	bne.n	1f28 <_PrintInt+0x9c>
    }
  }
  //
  // Print sign if necessary
  //
  if (pBufferDesc->ReturnValue >= 0) {
    1ee4:	68f3      	ldr	r3, [r6, #12]
    1ee6:	2b00      	cmp	r3, #0
    1ee8:	db19      	blt.n	1f1e <_PrintInt+0x92>
    if (v < 0) {
    1eea:	464b      	mov	r3, r9
    1eec:	2b00      	cmp	r3, #0
    1eee:	db28      	blt.n	1f42 <_PrintInt+0xb6>
      v = -v;
      _StoreChar(pBufferDesc, '-');
    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
    1ef0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1ef2:	075b      	lsls	r3, r3, #29
    1ef4:	d42c      	bmi.n	1f50 <_PrintInt+0xc4>
      _StoreChar(pBufferDesc, '+');
    } else {

    }
    if (pBufferDesc->ReturnValue >= 0) {
    1ef6:	68f3      	ldr	r3, [r6, #12]
    1ef8:	2b00      	cmp	r3, #0
    1efa:	db10      	blt.n	1f1e <_PrintInt+0x92>
      //
      // Print leading zeros if necessary
      //
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
    1efc:	2303      	movs	r3, #3
    1efe:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    1f00:	4013      	ands	r3, r2
    1f02:	2b02      	cmp	r3, #2
    1f04:	d029      	beq.n	1f5a <_PrintInt+0xce>
              break;
            }
          }
        }
      }
      if (pBufferDesc->ReturnValue >= 0) {
    1f06:	68f3      	ldr	r3, [r6, #12]
    1f08:	2b00      	cmp	r3, #0
    1f0a:	db08      	blt.n	1f1e <_PrintInt+0x92>
        //
        // Print number without sign
        //
        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
    1f0c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1f0e:	9301      	str	r3, [sp, #4]
    1f10:	9700      	str	r7, [sp, #0]
    1f12:	4653      	mov	r3, sl
    1f14:	002a      	movs	r2, r5
    1f16:	4649      	mov	r1, r9
    1f18:	0030      	movs	r0, r6
    1f1a:	4c1a      	ldr	r4, [pc, #104]	; (1f84 <_PrintInt+0xf8>)
    1f1c:	47a0      	blx	r4
      }
    }
  }
}
    1f1e:	b003      	add	sp, #12
    1f20:	bc0c      	pop	{r2, r3}
    1f22:	4691      	mov	r9, r2
    1f24:	469a      	mov	sl, r3
    1f26:	bdf0      	pop	{r4, r5, r6, r7, pc}
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1f28:	2f00      	cmp	r7, #0
    1f2a:	d0db      	beq.n	1ee4 <_PrintInt+0x58>
    1f2c:	42a7      	cmp	r7, r4
    1f2e:	d9d9      	bls.n	1ee4 <_PrintInt+0x58>
        FieldWidth--;
    1f30:	3f01      	subs	r7, #1
        _StoreChar(pBufferDesc, ' ');
    1f32:	2120      	movs	r1, #32
    1f34:	0030      	movs	r0, r6
    1f36:	4b14      	ldr	r3, [pc, #80]	; (1f88 <_PrintInt+0xfc>)
    1f38:	4798      	blx	r3
        if (pBufferDesc->ReturnValue < 0) {
    1f3a:	68f3      	ldr	r3, [r6, #12]
    1f3c:	2b00      	cmp	r3, #0
    1f3e:	daf3      	bge.n	1f28 <_PrintInt+0x9c>
    1f40:	e7d0      	b.n	1ee4 <_PrintInt+0x58>
      v = -v;
    1f42:	425b      	negs	r3, r3
    1f44:	4699      	mov	r9, r3
      _StoreChar(pBufferDesc, '-');
    1f46:	212d      	movs	r1, #45	; 0x2d
    1f48:	0030      	movs	r0, r6
    1f4a:	4b0f      	ldr	r3, [pc, #60]	; (1f88 <_PrintInt+0xfc>)
    1f4c:	4798      	blx	r3
    1f4e:	e7d2      	b.n	1ef6 <_PrintInt+0x6a>
      _StoreChar(pBufferDesc, '+');
    1f50:	212b      	movs	r1, #43	; 0x2b
    1f52:	0030      	movs	r0, r6
    1f54:	4b0c      	ldr	r3, [pc, #48]	; (1f88 <_PrintInt+0xfc>)
    1f56:	4798      	blx	r3
    1f58:	e7cd      	b.n	1ef6 <_PrintInt+0x6a>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
    1f5a:	4653      	mov	r3, sl
    1f5c:	2b00      	cmp	r3, #0
    1f5e:	d1d2      	bne.n	1f06 <_PrintInt+0x7a>
        if (FieldWidth != 0u) {
    1f60:	2f00      	cmp	r7, #0
    1f62:	d0d0      	beq.n	1f06 <_PrintInt+0x7a>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1f64:	2f00      	cmp	r7, #0
    1f66:	d0ce      	beq.n	1f06 <_PrintInt+0x7a>
    1f68:	42a7      	cmp	r7, r4
    1f6a:	d9cc      	bls.n	1f06 <_PrintInt+0x7a>
            FieldWidth--;
    1f6c:	3f01      	subs	r7, #1
            _StoreChar(pBufferDesc, '0');
    1f6e:	2130      	movs	r1, #48	; 0x30
    1f70:	0030      	movs	r0, r6
    1f72:	4b05      	ldr	r3, [pc, #20]	; (1f88 <_PrintInt+0xfc>)
    1f74:	4798      	blx	r3
            if (pBufferDesc->ReturnValue < 0) {
    1f76:	68f3      	ldr	r3, [r6, #12]
    1f78:	2b00      	cmp	r3, #0
    1f7a:	daf3      	bge.n	1f64 <_PrintInt+0xd8>
    1f7c:	e7c3      	b.n	1f06 <_PrintInt+0x7a>
    1f7e:	46c0      	nop			; (mov r8, r8)
    1f80:	0000133f 	.word	0x0000133f
    1f84:	00001d79 	.word	0x00001d79
    1f88:	00001d35 	.word	0x00001d35

00001f8c <SEGGER_RTT_vprintf>:
*
*  Return values
*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
*     < 0:  Error
*/
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
    1f8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1f8e:	46c6      	mov	lr, r8
    1f90:	b500      	push	{lr}
    1f92:	b09a      	sub	sp, #104	; 0x68
    1f94:	4680      	mov	r8, r0
    1f96:	000c      	movs	r4, r1
    1f98:	0015      	movs	r5, r2
  unsigned NumDigits;
  unsigned FormatFlags;
  unsigned FieldWidth;
  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];

  BufferDesc.pBuffer        = acBuffer;
    1f9a:	ab05      	add	r3, sp, #20
    1f9c:	9315      	str	r3, [sp, #84]	; 0x54
  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
    1f9e:	2340      	movs	r3, #64	; 0x40
    1fa0:	9316      	str	r3, [sp, #88]	; 0x58
  BufferDesc.Cnt            = 0u;
    1fa2:	2300      	movs	r3, #0
    1fa4:	9317      	str	r3, [sp, #92]	; 0x5c
  BufferDesc.RTTBufferIndex = BufferIndex;
    1fa6:	9019      	str	r0, [sp, #100]	; 0x64
  BufferDesc.ReturnValue    = 0;
    1fa8:	9318      	str	r3, [sp, #96]	; 0x60
    1faa:	e08d      	b.n	20c8 <STACK_SIZE+0xc8>
    1fac:	2000      	movs	r0, #0
    1fae:	2201      	movs	r2, #1
    1fb0:	e00a      	b.n	1fc8 <SEGGER_RTT_vprintf+0x3c>
      //
      FormatFlags = 0u;
      v = 1;
      do {
        c = *sFormat;
        switch (c) {
    1fb2:	2b23      	cmp	r3, #35	; 0x23
    1fb4:	d118      	bne.n	1fe8 <SEGGER_RTT_vprintf+0x5c>
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
    1fb6:	2308      	movs	r3, #8
    1fb8:	4318      	orrs	r0, r3
    1fba:	3401      	adds	r4, #1
    1fbc:	e002      	b.n	1fc4 <SEGGER_RTT_vprintf+0x38>
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
    1fbe:	2301      	movs	r3, #1
    1fc0:	4318      	orrs	r0, r3
    1fc2:	3401      	adds	r4, #1
        default:  v = 0; break;
        }
      } while (v);
    1fc4:	2a00      	cmp	r2, #0
    1fc6:	d011      	beq.n	1fec <SEGGER_RTT_vprintf+0x60>
        c = *sFormat;
    1fc8:	7823      	ldrb	r3, [r4, #0]
        switch (c) {
    1fca:	2b2b      	cmp	r3, #43	; 0x2b
    1fcc:	d008      	beq.n	1fe0 <SEGGER_RTT_vprintf+0x54>
    1fce:	d9f0      	bls.n	1fb2 <SEGGER_RTT_vprintf+0x26>
    1fd0:	2b2d      	cmp	r3, #45	; 0x2d
    1fd2:	d0f4      	beq.n	1fbe <SEGGER_RTT_vprintf+0x32>
    1fd4:	2b30      	cmp	r3, #48	; 0x30
    1fd6:	d107      	bne.n	1fe8 <SEGGER_RTT_vprintf+0x5c>
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
    1fd8:	2302      	movs	r3, #2
    1fda:	4318      	orrs	r0, r3
    1fdc:	3401      	adds	r4, #1
    1fde:	e7f1      	b.n	1fc4 <SEGGER_RTT_vprintf+0x38>
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
    1fe0:	2304      	movs	r3, #4
    1fe2:	4318      	orrs	r0, r3
    1fe4:	3401      	adds	r4, #1
    1fe6:	e7ed      	b.n	1fc4 <SEGGER_RTT_vprintf+0x38>
        default:  v = 0; break;
    1fe8:	2200      	movs	r2, #0
    1fea:	e7eb      	b.n	1fc4 <SEGGER_RTT_vprintf+0x38>
      //
      // filter out field with
      //
      FieldWidth = 0u;
      do {
        c = *sFormat;
    1fec:	7827      	ldrb	r7, [r4, #0]
        if ((c < '0') || (c > '9')) {
    1fee:	0039      	movs	r1, r7
    1ff0:	3930      	subs	r1, #48	; 0x30
    1ff2:	b2c9      	uxtb	r1, r1
    1ff4:	2909      	cmp	r1, #9
    1ff6:	d807      	bhi.n	2008 <STACK_SIZE+0x8>
          break;
        }
        sFormat++;
    1ff8:	3401      	adds	r4, #1
        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
    1ffa:	0091      	lsls	r1, r2, #2
    1ffc:	188a      	adds	r2, r1, r2
    1ffe:	0053      	lsls	r3, r2, #1
    2000:	19db      	adds	r3, r3, r7
    2002:	3b30      	subs	r3, #48	; 0x30
    2004:	001a      	movs	r2, r3
        c = *sFormat;
    2006:	e7f1      	b.n	1fec <SEGGER_RTT_vprintf+0x60>
      //
      // Filter out precision (number of digits to display)
      //
      NumDigits = 0u;
      c = *sFormat;
      if (c == '.') {
    2008:	2f2e      	cmp	r7, #46	; 0x2e
    200a:	d002      	beq.n	2012 <STACK_SIZE+0x12>
      NumDigits = 0u;
    200c:	2300      	movs	r3, #0
        } while (1);
      }
      //
      // Filter out length modifier
      //
      c = *sFormat;
    200e:	7821      	ldrb	r1, [r4, #0]
    2010:	e011      	b.n	2036 <STACK_SIZE+0x36>
        sFormat++;
    2012:	3401      	adds	r4, #1
      NumDigits = 0u;
    2014:	2300      	movs	r3, #0
          c = *sFormat;
    2016:	7826      	ldrb	r6, [r4, #0]
          if ((c < '0') || (c > '9')) {
    2018:	0037      	movs	r7, r6
    201a:	3f30      	subs	r7, #48	; 0x30
    201c:	b2ff      	uxtb	r7, r7
    201e:	2f09      	cmp	r7, #9
    2020:	d8f5      	bhi.n	200e <STACK_SIZE+0xe>
          sFormat++;
    2022:	3401      	adds	r4, #1
          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
    2024:	009f      	lsls	r7, r3, #2
    2026:	18fb      	adds	r3, r7, r3
    2028:	0059      	lsls	r1, r3, #1
    202a:	1989      	adds	r1, r1, r6
    202c:	000b      	movs	r3, r1
    202e:	3b30      	subs	r3, #48	; 0x30
          c = *sFormat;
    2030:	e7f1      	b.n	2016 <STACK_SIZE+0x16>
      do {
        if ((c == 'l') || (c == 'h')) {
          sFormat++;
    2032:	3401      	adds	r4, #1
          c = *sFormat;
    2034:	7821      	ldrb	r1, [r4, #0]
        if ((c == 'l') || (c == 'h')) {
    2036:	296c      	cmp	r1, #108	; 0x6c
    2038:	d0fb      	beq.n	2032 <STACK_SIZE+0x32>
    203a:	2968      	cmp	r1, #104	; 0x68
    203c:	d0f9      	beq.n	2032 <STACK_SIZE+0x32>
        }
      } while (1);
      //
      // Handle specifiers
      //
      switch (c) {
    203e:	2964      	cmp	r1, #100	; 0x64
    2040:	d04d      	beq.n	20de <STACK_SIZE+0xde>
    2042:	d90f      	bls.n	2064 <STACK_SIZE+0x64>
    2044:	2973      	cmp	r1, #115	; 0x73
    2046:	d055      	beq.n	20f4 <STACK_SIZE+0xf4>
    2048:	d917      	bls.n	207a <STACK_SIZE+0x7a>
    204a:	2975      	cmp	r1, #117	; 0x75
    204c:	d124      	bne.n	2098 <STACK_SIZE+0x98>
      case 'd':
        v = va_arg(*pParamList, int);
        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
        break;
      case 'u':
        v = va_arg(*pParamList, int);
    204e:	6829      	ldr	r1, [r5, #0]
    2050:	1d0f      	adds	r7, r1, #4
    2052:	602f      	str	r7, [r5, #0]
    2054:	6809      	ldr	r1, [r1, #0]
        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
    2056:	9001      	str	r0, [sp, #4]
    2058:	9200      	str	r2, [sp, #0]
    205a:	220a      	movs	r2, #10
    205c:	a815      	add	r0, sp, #84	; 0x54
    205e:	4f39      	ldr	r7, [pc, #228]	; (2144 <STACK_SIZE+0x144>)
    2060:	47b8      	blx	r7
        break;
    2062:	e02d      	b.n	20c0 <STACK_SIZE+0xc0>
      switch (c) {
    2064:	2958      	cmp	r1, #88	; 0x58
    2066:	d019      	beq.n	209c <STACK_SIZE+0x9c>
    2068:	2963      	cmp	r1, #99	; 0x63
    206a:	d022      	beq.n	20b2 <STACK_SIZE+0xb2>
    206c:	2925      	cmp	r1, #37	; 0x25
    206e:	d127      	bne.n	20c0 <STACK_SIZE+0xc0>
      case 'p':
        v = va_arg(*pParamList, int);
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
        break;
      case '%':
        _StoreChar(&BufferDesc, '%');
    2070:	2125      	movs	r1, #37	; 0x25
    2072:	a815      	add	r0, sp, #84	; 0x54
    2074:	4b34      	ldr	r3, [pc, #208]	; (2148 <STACK_SIZE+0x148>)
    2076:	4798      	blx	r3
        break;
    2078:	e022      	b.n	20c0 <STACK_SIZE+0xc0>
      switch (c) {
    207a:	2970      	cmp	r1, #112	; 0x70
    207c:	d120      	bne.n	20c0 <STACK_SIZE+0xc0>
        v = va_arg(*pParamList, int);
    207e:	682b      	ldr	r3, [r5, #0]
    2080:	1d1a      	adds	r2, r3, #4
    2082:	602a      	str	r2, [r5, #0]
    2084:	6819      	ldr	r1, [r3, #0]
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
    2086:	2300      	movs	r3, #0
    2088:	9301      	str	r3, [sp, #4]
    208a:	3308      	adds	r3, #8
    208c:	9300      	str	r3, [sp, #0]
    208e:	2210      	movs	r2, #16
    2090:	a815      	add	r0, sp, #84	; 0x54
    2092:	4f2c      	ldr	r7, [pc, #176]	; (2144 <STACK_SIZE+0x144>)
    2094:	47b8      	blx	r7
        break;
    2096:	e013      	b.n	20c0 <STACK_SIZE+0xc0>
      switch (c) {
    2098:	2978      	cmp	r1, #120	; 0x78
    209a:	d111      	bne.n	20c0 <STACK_SIZE+0xc0>
        v = va_arg(*pParamList, int);
    209c:	6829      	ldr	r1, [r5, #0]
    209e:	1d0f      	adds	r7, r1, #4
    20a0:	602f      	str	r7, [r5, #0]
    20a2:	6809      	ldr	r1, [r1, #0]
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
    20a4:	9001      	str	r0, [sp, #4]
    20a6:	9200      	str	r2, [sp, #0]
    20a8:	2210      	movs	r2, #16
    20aa:	a815      	add	r0, sp, #84	; 0x54
    20ac:	4f25      	ldr	r7, [pc, #148]	; (2144 <STACK_SIZE+0x144>)
    20ae:	47b8      	blx	r7
        break;
    20b0:	e006      	b.n	20c0 <STACK_SIZE+0xc0>
        v = va_arg(*pParamList, int);
    20b2:	682b      	ldr	r3, [r5, #0]
    20b4:	1d1a      	adds	r2, r3, #4
    20b6:	602a      	str	r2, [r5, #0]
        c0 = (char)v;
    20b8:	7819      	ldrb	r1, [r3, #0]
        _StoreChar(&BufferDesc, c0);
    20ba:	a815      	add	r0, sp, #84	; 0x54
    20bc:	4b22      	ldr	r3, [pc, #136]	; (2148 <STACK_SIZE+0x148>)
    20be:	4798      	blx	r3
      default:
        break;
      }
      sFormat++;
    20c0:	3401      	adds	r4, #1
    } else {
      _StoreChar(&BufferDesc, c);
    }
  } while (BufferDesc.ReturnValue >= 0);
    20c2:	9b18      	ldr	r3, [sp, #96]	; 0x60
    20c4:	2b00      	cmp	r3, #0
    20c6:	db24      	blt.n	2112 <STACK_SIZE+0x112>
    c = *sFormat;
    20c8:	7821      	ldrb	r1, [r4, #0]
    sFormat++;
    20ca:	3401      	adds	r4, #1
    if (c == 0u) {
    20cc:	2900      	cmp	r1, #0
    20ce:	d020      	beq.n	2112 <STACK_SIZE+0x112>
    if (c == '%') {
    20d0:	2925      	cmp	r1, #37	; 0x25
    20d2:	d100      	bne.n	20d6 <STACK_SIZE+0xd6>
    20d4:	e76a      	b.n	1fac <SEGGER_RTT_vprintf+0x20>
      _StoreChar(&BufferDesc, c);
    20d6:	a815      	add	r0, sp, #84	; 0x54
    20d8:	4b1b      	ldr	r3, [pc, #108]	; (2148 <STACK_SIZE+0x148>)
    20da:	4798      	blx	r3
    20dc:	e7f1      	b.n	20c2 <STACK_SIZE+0xc2>
        v = va_arg(*pParamList, int);
    20de:	6829      	ldr	r1, [r5, #0]
    20e0:	1d0f      	adds	r7, r1, #4
    20e2:	602f      	str	r7, [r5, #0]
    20e4:	6809      	ldr	r1, [r1, #0]
        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
    20e6:	9001      	str	r0, [sp, #4]
    20e8:	9200      	str	r2, [sp, #0]
    20ea:	220a      	movs	r2, #10
    20ec:	a815      	add	r0, sp, #84	; 0x54
    20ee:	4f17      	ldr	r7, [pc, #92]	; (214c <STACK_SIZE+0x14c>)
    20f0:	47b8      	blx	r7
        break;
    20f2:	e7e5      	b.n	20c0 <STACK_SIZE+0xc0>
          const char * s = va_arg(*pParamList, const char *);
    20f4:	682b      	ldr	r3, [r5, #0]
    20f6:	1d1a      	adds	r2, r3, #4
    20f8:	602a      	str	r2, [r5, #0]
    20fa:	681f      	ldr	r7, [r3, #0]
            c = *s;
    20fc:	7839      	ldrb	r1, [r7, #0]
            s++;
    20fe:	3701      	adds	r7, #1
            if (c == '\0') {
    2100:	2900      	cmp	r1, #0
    2102:	d0dd      	beq.n	20c0 <STACK_SIZE+0xc0>
           _StoreChar(&BufferDesc, c);
    2104:	a815      	add	r0, sp, #84	; 0x54
    2106:	4b10      	ldr	r3, [pc, #64]	; (2148 <STACK_SIZE+0x148>)
    2108:	4798      	blx	r3
          } while (BufferDesc.ReturnValue >= 0);
    210a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    210c:	2b00      	cmp	r3, #0
    210e:	daf5      	bge.n	20fc <STACK_SIZE+0xfc>
    2110:	e7d6      	b.n	20c0 <STACK_SIZE+0xc0>

  if (BufferDesc.ReturnValue > 0) {
    2112:	9b18      	ldr	r3, [sp, #96]	; 0x60
    2114:	2b00      	cmp	r3, #0
    2116:	dd0b      	ble.n	2130 <STACK_SIZE+0x130>
    //
    // Write remaining data, if any
    //
    if (BufferDesc.Cnt != 0u) {
    2118:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    211a:	2a00      	cmp	r2, #0
    211c:	d10d      	bne.n	213a <STACK_SIZE+0x13a>
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
    }
    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
    211e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    2120:	9302      	str	r3, [sp, #8]
    2122:	9b18      	ldr	r3, [sp, #96]	; 0x60
    2124:	9303      	str	r3, [sp, #12]
    2126:	9b02      	ldr	r3, [sp, #8]
    2128:	9a03      	ldr	r2, [sp, #12]
    212a:	4694      	mov	ip, r2
    212c:	4463      	add	r3, ip
    212e:	9318      	str	r3, [sp, #96]	; 0x60
  }
  return BufferDesc.ReturnValue;
}
    2130:	9818      	ldr	r0, [sp, #96]	; 0x60
    2132:	b01a      	add	sp, #104	; 0x68
    2134:	bc04      	pop	{r2}
    2136:	4690      	mov	r8, r2
    2138:	bdf0      	pop	{r4, r5, r6, r7, pc}
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
    213a:	a905      	add	r1, sp, #20
    213c:	4640      	mov	r0, r8
    213e:	4b04      	ldr	r3, [pc, #16]	; (2150 <STACK_SIZE+0x150>)
    2140:	4798      	blx	r3
    2142:	e7ec      	b.n	211e <STACK_SIZE+0x11e>
    2144:	00001d79 	.word	0x00001d79
    2148:	00001d35 	.word	0x00001d35
    214c:	00001e8d 	.word	0x00001e8d
    2150:	00001cf9 	.word	0x00001cf9

00002154 <SEGGER_RTT_printf>:
*          u: Print the argument as an unsigned integer
*          x: Print the argument as an hexadecimal integer
*          s: Print the string pointed to by the argument
*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
*/
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
    2154:	b40e      	push	{r1, r2, r3}
    2156:	b500      	push	{lr}
    2158:	b082      	sub	sp, #8
    215a:	ab03      	add	r3, sp, #12
    215c:	cb02      	ldmia	r3!, {r1}
  int r;
  va_list ParamList;

  va_start(ParamList, sFormat);
    215e:	9301      	str	r3, [sp, #4]
  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
    2160:	aa01      	add	r2, sp, #4
    2162:	4b03      	ldr	r3, [pc, #12]	; (2170 <SEGGER_RTT_printf+0x1c>)
    2164:	4798      	blx	r3
  va_end(ParamList);
  return r;
}
    2166:	b002      	add	sp, #8
    2168:	bc08      	pop	{r3}
    216a:	b003      	add	sp, #12
    216c:	4718      	bx	r3
    216e:	46c0      	nop			; (mov r8, r8)
    2170:	00001f8d 	.word	0x00001f8d

00002174 <__libc_init_array>:
    2174:	b570      	push	{r4, r5, r6, lr}
    2176:	2600      	movs	r6, #0
    2178:	4d0c      	ldr	r5, [pc, #48]	; (21ac <__libc_init_array+0x38>)
    217a:	4c0d      	ldr	r4, [pc, #52]	; (21b0 <__libc_init_array+0x3c>)
    217c:	1b64      	subs	r4, r4, r5
    217e:	10a4      	asrs	r4, r4, #2
    2180:	42a6      	cmp	r6, r4
    2182:	d109      	bne.n	2198 <__libc_init_array+0x24>
    2184:	2600      	movs	r6, #0
    2186:	f000 f91b 	bl	23c0 <_init>
    218a:	4d0a      	ldr	r5, [pc, #40]	; (21b4 <__libc_init_array+0x40>)
    218c:	4c0a      	ldr	r4, [pc, #40]	; (21b8 <__libc_init_array+0x44>)
    218e:	1b64      	subs	r4, r4, r5
    2190:	10a4      	asrs	r4, r4, #2
    2192:	42a6      	cmp	r6, r4
    2194:	d105      	bne.n	21a2 <__libc_init_array+0x2e>
    2196:	bd70      	pop	{r4, r5, r6, pc}
    2198:	00b3      	lsls	r3, r6, #2
    219a:	58eb      	ldr	r3, [r5, r3]
    219c:	4798      	blx	r3
    219e:	3601      	adds	r6, #1
    21a0:	e7ee      	b.n	2180 <__libc_init_array+0xc>
    21a2:	00b3      	lsls	r3, r6, #2
    21a4:	58eb      	ldr	r3, [r5, r3]
    21a6:	4798      	blx	r3
    21a8:	3601      	adds	r6, #1
    21aa:	e7f2      	b.n	2192 <__libc_init_array+0x1e>
    21ac:	000023cc 	.word	0x000023cc
    21b0:	000023cc 	.word	0x000023cc
    21b4:	000023cc 	.word	0x000023cc
    21b8:	000023d0 	.word	0x000023d0

000021bc <memcpy>:
    21bc:	2300      	movs	r3, #0
    21be:	b510      	push	{r4, lr}
    21c0:	429a      	cmp	r2, r3
    21c2:	d100      	bne.n	21c6 <memcpy+0xa>
    21c4:	bd10      	pop	{r4, pc}
    21c6:	5ccc      	ldrb	r4, [r1, r3]
    21c8:	54c4      	strb	r4, [r0, r3]
    21ca:	3301      	adds	r3, #1
    21cc:	e7f8      	b.n	21c0 <memcpy+0x4>

000021ce <memset>:
    21ce:	0003      	movs	r3, r0
    21d0:	1882      	adds	r2, r0, r2
    21d2:	4293      	cmp	r3, r2
    21d4:	d100      	bne.n	21d8 <memset+0xa>
    21d6:	4770      	bx	lr
    21d8:	7019      	strb	r1, [r3, #0]
    21da:	3301      	adds	r3, #1
    21dc:	e7f9      	b.n	21d2 <memset+0x4>
    21de:	0000      	movs	r0, r0
    21e0:	682f2e2e 	.word	0x682f2e2e
    21e4:	692f6c61 	.word	0x692f6c61
    21e8:	756c636e 	.word	0x756c636e
    21ec:	682f6564 	.word	0x682f6564
    21f0:	775f6c61 	.word	0x775f6c61
    21f4:	682e7464 	.word	0x682e7464
    21f8:	00000000 	.word	0x00000000
    21fc:	682f2e2e 	.word	0x682f2e2e
    2200:	732f6c61 	.word	0x732f6c61
    2204:	682f6372 	.word	0x682f6372
    2208:	635f6c61 	.word	0x635f6c61
    220c:	615f6e61 	.word	0x615f6e61
    2210:	636e7973 	.word	0x636e7973
    2214:	0000632e 	.word	0x0000632e
    2218:	682f2e2e 	.word	0x682f2e2e
    221c:	732f6c61 	.word	0x732f6c61
    2220:	682f6372 	.word	0x682f6372
    2224:	665f6c61 	.word	0x665f6c61
    2228:	6873616c 	.word	0x6873616c
    222c:	0000632e 	.word	0x0000632e
    2230:	682f2e2e 	.word	0x682f2e2e
    2234:	732f6c61 	.word	0x732f6c61
    2238:	682f6372 	.word	0x682f6372
    223c:	735f6c61 	.word	0x735f6c61
    2240:	6d5f6970 	.word	0x6d5f6970
    2244:	6e79735f 	.word	0x6e79735f
    2248:	00632e63 	.word	0x00632e63
    224c:	682f2e2e 	.word	0x682f2e2e
    2250:	732f6c61 	.word	0x732f6c61
    2254:	682f6372 	.word	0x682f6372
    2258:	745f6c61 	.word	0x745f6c61
    225c:	72656d69 	.word	0x72656d69
    2260:	0000632e 	.word	0x0000632e
    2264:	682f2e2e 	.word	0x682f2e2e
    2268:	752f6c61 	.word	0x752f6c61
    226c:	736c6974 	.word	0x736c6974
    2270:	6372732f 	.word	0x6372732f
    2274:	6974752f 	.word	0x6974752f
    2278:	6c5f736c 	.word	0x6c5f736c
    227c:	2e747369 	.word	0x2e747369
    2280:	00000063 	.word	0x00000063
    2284:	03020100 	.word	0x03020100
    2288:	07060504 	.word	0x07060504
    228c:	14100c08 	.word	0x14100c08
    2290:	40302018 	.word	0x40302018
    2294:	682f2e2e 	.word	0x682f2e2e
    2298:	6e2f6c70 	.word	0x6e2f6c70
    229c:	74636d76 	.word	0x74636d76
    22a0:	682f6c72 	.word	0x682f6c72
    22a4:	6e5f6c70 	.word	0x6e5f6c70
    22a8:	74636d76 	.word	0x74636d76
    22ac:	632e6c72 	.word	0x632e6c72
    22b0:	00000000 	.word	0x00000000

000022b4 <_usarts>:
	...

000022c8 <_i2cms>:
	...

000022e0 <_i2css>:
	...

000022f0 <sercomspi_regs>:
    22f0:	0001000c 00020000 00000000 01ff0027     ............'...
    2300:	00000001 682f2e2e 732f6c70 6f637265     ....../hpl/serco
    2310:	70682f6d 65735f6c 6d6f6372 0000632e     m/hpl_sercom.c..

00002320 <_tcs>:
    2320:	00001400 00000308 00000000 000001f4     ................
    2330:	00000000 00001501 00000308 00000000     ................
    2340:	000001f4 00000000 682f2e2e 742f6c70     ........../hpl/t
    2350:	70682f63 63745f6c 0000632e 682f2e2e     c/hpl_tc.c..../h
    2360:	772f6c70 682f7464 775f6c70 632e7464     pl/wdt/hpl_wdt.c
    2370:	00000000 20746e63 6425203d 00000a0d     ....cnt = %d....

00002380 <_aTerminalId>:
    2380:	33323130 37363534 42413938 46454443     0123456789ABCDEF

00002390 <_aInitStr.5072>:
    2390:	00000000 54540000 45522052 53454747     ......TTR REGGES
    23a0:	00000000 6d726554 6c616e69 00000000     ....Terminal....

000023b0 <_aV2C.4903>:
    23b0:	33323130 37363534 42413938 46454443     0123456789ABCDEF

000023c0 <_init>:
    23c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    23c2:	46c0      	nop			; (mov r8, r8)
    23c4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    23c6:	bc08      	pop	{r3}
    23c8:	469e      	mov	lr, r3
    23ca:	4770      	bx	lr

000023cc <__init_array_start>:
    23cc:	000000e5 	.word	0x000000e5

000023d0 <_fini>:
    23d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    23d2:	46c0      	nop			; (mov r8, r8)
    23d4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    23d6:	bc08      	pop	{r3}
    23d8:	469e      	mov	lr, r3
    23da:	4770      	bx	lr

000023dc <__fini_array_start>:
    23dc:	000000bd 	.word	0x000000bd
